[{"title":"AJAX","url":"/2020/06/21/AJAX/","content":"AJAX心得体会在接触AJAX这个概念之前，觉得这东西好高端啊，熟悉了之后就觉得也没什么了不起，挺土的。\n在WEB世界里，浏览器向服务器发送一次HTTP请求，服务器返回一个HTML页面。\n栗子\n\n提交表单时，页面会刷新，服务器会返回一个全新的html页面\n百度的搜索框会根据用户输入的内容，即时进行联想，如果总是要刷新，肯定是不行的。\n\n解决方法是，用JavaScript发送新的请求，接受到数据之后，再用JavaScript更新页面数据，这样用户感觉自己始终停留在一个页面（没有刷新）。\n\n\n举个完整的栗子：\n我用Spring Boot在本地部署了一个服务器，访问localhost:8080/greeting可以得到如下的结果：\n返回值会根据请求里的name参数做出改变：\n\n\nAJAX代码：\n文件名：text.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt;    &lt;h1&gt;SOMETHING IS GOING TO HAPPEN&lt;/h1&gt;    &lt;p id=&quot;content&quot;&gt;    &lt;/p&gt;&lt;/article&gt;&lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n文件名：text.js\nlet paragraph = document.getElementById(&#x27;content&#x27;);function success(text) &#123;    paragraph.innerHTML = text;&#125;function fail(code) &#123;    paragraph.innerHTML = &#x27;Error code:&#x27; + code;&#125;paragraph.innerHTML = &#x27;BLACK LIVES MATTER&#x27;;let XHR = new XMLHttpRequest();XHR.onreadystatechange = function () &#123;    if (XHR.readyState === 4) &#123;        if (XHR.status === 200) &#123;            return success(XHR.responseText);        &#125; else &#123;            return fail(XHR.status);        &#125;    &#125; else &#123;        alert(&#x27;还在处理中&#x27;);    &#125;&#125;XHR.open(&#x27;GET&#x27;, &#x27;http://localhost:8080/greeting&#x27;, true);XHR.send();alert(&#x27;请求已发送&#x27;);\n\nAJAX代码的核心是XMLHttpRequest对象，有了这个对象之后，先设置onreadystatechange的回调函数。可以根据readyState的值来判断请求是否已经完成，根据status值来判断响应的结果成功与否。\nXMLHttpRequest对象的open方法有3个参数，第一个参数确定请求类型是GET还是POST，第二个参数是要请求的服务器的URL（此处是我之前部署的本地服务器），第三个参数布尔值指定是否异步执行。\n值得一提的是CORS，我需要在我的服务器应用上设置正确的跨域请求策略（像是白名单的一种东西），才能让我的AJAX代码成功运行。在Spring里，需要这样做：\n\n\n使用@CrossOrigin注解，可以指定允许来自哪些域名的跨域访问，“*” 代表允许任何域的跨域访问。\n","categories":["JavaScript"]},{"title":"Artemis","url":"/2020/07/26/Artemis/","content":"Spring Boot集成Artemis什么是Artemis？Artemis是神啊\nArtemis是一个JMS产品。\n准备工作下载并安装ARTEMIS，在项目根目录创建存储数据的目录文件，并启动Artemis服务器。\n\n\n添加Maven依赖项&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-artemis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置spring:  artemis:    # 指定连接外部Artemis服务器，而不是启动嵌入式服务:    mode: native    # 服务器地址和端口号:    host: 127.0.0.1    port: 61616    # 连接用户名和口令由创建Artemis服务器时指定:    user: ???    password: ????\n\n利用Artemis发送注册成功的邮件Producerpackage eternal.fire.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;@Componentpublic class MessagingService &#123;    JmsTemplate jmsTemplate;    MailService mailService;    @Autowired    public MessagingService(JmsTemplate jmsTemplate, MailService mailService) &#123;        this.jmsTemplate = jmsTemplate;        this.mailService = mailService;    &#125;    public void sendMailRegisterMessage(String email) &#123;        jmsTemplate.send(&quot;jms/queue/mail&quot;,session -&gt; session.createTextMessage(email));    &#125;&#125;\n\nConsumerpackage eternal.fire.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component;import javax.mail.MessagingException;@Componentpublic class MailMessageListener &#123;    MailService mailService;    @Autowired    public MailMessageListener(MailService mailService) &#123;        this.mailService = mailService;    &#125;    @JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)    public void onMessageReceived(String email) throws MessagingException &#123;        mailService.sendRegisterMail(email);    &#125;&#125;\n\nMailService关于MailService可以参考我上一篇文章：\npackage eternal.fire.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mail.MailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMailMessage;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;@Componentpublic class MailService &#123;    JavaMailSender javaMailSender;    @Autowired    public MailService(JavaMailSender javaMailSender) &#123;        this.javaMailSender = javaMailSender;    &#125;    public void sendRegisterMail(String email) throws MessagingException &#123;        MimeMessage mimeMessage = javaMailSender.createMimeMessage();        MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage);        mimeMessageHelper.setFrom(&quot;674602921@qq.com&quot;);        mimeMessageHelper.setTo(email);        mimeMessageHelper.setSubject(&quot;Register successfully&quot;);        mimeMessageHelper.setText(&quot;Congratulations! You have registered successfully&quot;);        javaMailSender.send(mimeMessage);    &#125;&#125;\n\nUserService逻辑public User register(String email, String password, String name) &#123;    log.info(&quot;try to register by &#123;&#125;&quot;, email);    User user = new User(email, password, name, System.currentTimeMillis());    KeyHolder keyHolder = new GeneratedKeyHolder();    try &#123;        jdbcTemplate.update(connection -&gt; &#123;            var ps = connection.prepareStatement(&quot;INSERT INTO users(email,password,name,createdAt) VALUES (?,?,?,?)&quot;, Statement.RETURN_GENERATED_KEYS);            ps.setObject(1, user.getEmail());            ps.setObject(2, user.getPassword());            ps.setObject(3, user.getName());            ps.setObject(4, user.getCreatedAt());            return ps;        &#125;, keyHolder);    &#125; catch (DataAccessException e) &#123;        throw new RuntimeException(&quot;Register failed&quot;);    &#125;    messagingService.sendMailRegisterMessage(user.getEmail());    user.setId(Objects.requireNonNull(keyHolder.getKey()).longValue());    return user;\n\n总结阿尔忒弥斯（希腊语：Ἄρτεμις、英语：Artemis），又名辛西亚，是古希腊神话中的狩猎女神和接生之神，同时也是野兽的女主人与荒野的女领主，奥林匹斯十二主神之一。还是宙斯和勒托之女，是阿波罗的孪生姐姐。 [1] \n阿尔忒弥斯自由独立，热爱野外生活，反对男女婚姻。她喜欢的是不嫁的处女们，以及那些蔑视阿佛洛狄忒的青年，她与赫斯提亚、雅典娜被视为奥林匹斯山上的三处女神。\n她从小就向父亲宙斯许诺做永远的处女，同时索要弓箭、所有的山脉和20个给她保养猎靴的宁芙侍女。在林莽和山野间，阿尔忒弥斯手持弓箭，由猎狗伴随，与侍奉她的众仙女以狩猎为乐。她很喜欢金角鹿，并抓到这种鹿给她拉车。 [2] \n阿尔忒弥斯因被命运女神选为接生神，于是便向宙斯索取主管接生新生儿的权力。她是古希腊人祭祀最多的神祇之一。世界七大奇迹之一的阿尔忒弥斯神庙就是专门为她修建的。\n参考https://www.liaoxuefeng.com/wiki/1252599548343744/1282388602650658\n","categories":["Spring"]},{"title":"Apache POI","url":"/2020/11/24/Apache-POI/","content":"依赖项dependencies &#123;    compile group: &#x27;org.apache.poi&#x27;, name: &#x27;poi&#x27;, version: &#x27;4.1.2&#x27;    compile group: &#x27;org.apache.poi&#x27;, name: &#x27;poi-ooxml&#x27;, version: &#x27;4.1.2&#x27;    compile group: &#x27;org.apache.poi&#x27;, name: &#x27;poi-ooxml-schemas&#x27;, version: &#x27;4.1.2&#x27;&#125;\n\n\n\n常用操作// 获得workbookvar workbook = new XSSFWorkbook(Main.class.getResourceAsStream(String.format(&quot;/%s.xlsx&quot;, fileName)));// 获得sheetvar sheet = workbook.getSheet(&quot;sheet1&quot;);// 获得某一行var row = sheet.getRow(0);// 获得某一列var cell = row.getCell(0);// 遍历每行每列for (var row : sheet) &#123;    for (var cell : row) &#123;        // Todo:    &#125;&#125;// 从cell中获取数值double val = cell.getNumericCellValue());// 从cell中获取字符串String str = cell.getStringCellValue();// 将cell的数值转为指定格式的字符串var formatter = new DecimalFormat(&quot;#&quot;);String str = formatter.format(cell.getNumericCellValue());// 删除某一行的内容sheet.removeRow(row); // 注意别一边遍历一边删，会出问题的// 将一个范围的行进行移动，-1表示上移一行sheet.shiftRows(start, end, -1);// 上面两个方法配合起来可以删除某一行sheet.removeRow(row);sheet.shiftRows(start, end, -1);// 将结果写入表格try (var os = new FileOutputStream(new File(&quot;**********&quot;))) &#123;\t\tworkbook.write(os);&#125;\n\n实战演练任务一接触Apache POI不是心血来潮，不过是主人的任务罢了。\n导员给我的任务是：筛选出成绩表中由导员负责的并且挂科超过3门的同学。\n已有的表格：计科全体学生各科成绩表、软工全体学生各科成绩表、物联网全体学生各科成绩表、导员负责的同学的名单\n\n表格具体内容涉及隐私就不放了，核心代码如下：\npublic class Main &#123;    public static void main(String[] args) throws IOException &#123;        output(&quot;计科&quot;);        output(&quot;软工&quot;);        output(&quot;物联网&quot;);    &#125;    private static void output(String fileName) throws IOException &#123;        System.out.println(&quot;---------------------------------- 优雅的分隔符 ----------------------------------&quot;);        System.out.println(fileName + &quot;:&quot;);        try (var workbook = new XSSFWorkbook(Main.class.getResourceAsStream(String.format(&quot;/%s.xlsx&quot;, fileName)))) &#123;            var sheet = workbook.getSheet(&quot;sheet1&quot;);            var courses = sheet.getRow(0);            List&lt;List&lt;String&gt;&gt; students = new ArrayList&lt;&gt;();            var studentsOfYue = studentOfYue();            for (var row : sheet) &#123;                if (row.getRowNum() == 0 || row.getRowNum() == 1) &#123;                    continue;                &#125;                String id = row.getCell(1).toString();                if (!studentsOfYue.contains(id)) &#123;                    continue;                &#125;                int cnt = 0;                List&lt;String&gt; student = new ArrayList&lt;&gt;();                for (var cell : row) &#123;                    switch (cell.getCellType()) &#123;                        case STRING -&gt; student.add(cell.getStringCellValue());                        case NUMERIC -&gt; &#123;                            if (cell.getNumericCellValue() &lt; 60) &#123;                                cnt++;                                student.add(getCourseName(cell.getColumnIndex(), courses) + &quot;:&quot; + cell.getNumericCellValue());                            &#125;                        &#125;                    &#125;                &#125;                if (cnt &gt;= 3) &#123;                    students.add(student);                &#125;            &#125;            for (var student : students) &#123;                System.out.println(student);            &#125;        &#125;    &#125;    // 月月姐班上的同学    private static Set&lt;String&gt; studentOfYue() throws IOException &#123;        try (var workbook = new XSSFWorkbook(Main.class.getResourceAsStream(&quot;/月.xlsx&quot;))) &#123;            var sheet = workbook.getSheet(&quot;总表&quot;);            Set&lt;String&gt; set = new HashSet&lt;&gt;();            for (var row : sheet) &#123;                if (row.getRowNum() == 0) &#123;                    continue;                &#125;                var cell = row.getCell(2);                var formatter = new DecimalFormat(&quot;#&quot;);                switch (cell.getCellType()) &#123;                    case STRING -&gt; set.add(cell.getStringCellValue());                    case NUMERIC -&gt; set.add(formatter.format(cell.getNumericCellValue()));                &#125;            &#125;            return set;        &#125;    &#125;    private static String getCourseName(int index, XSSFRow courses) &#123;        var name = courses.getCell(index).getStringCellValue();        if (name.isBlank()) &#123;            return getCourseName(index - 1, courses);        &#125; else &#123;            return name;        &#125;    &#125;&#125;\n\n运行结果如下：\n\n效果差强人意。\n任务二导员的任务是：筛选出表中导员负责的同学的得分情况（移除其它同学的得分情况）\n已有的表格：各个学院和书院同学的得分情况、导员负责的同学的名单\n\n核心代码如下：\npackage eternal.fire;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        try (var workbook = new XSSFWorkbook(Main.class.getResourceAsStream(&quot;/学宪法.xlsx&quot;))) &#123;            var sheet = workbook.getSheet(&quot;***&quot;);            var studentsOfYue = studentsNameOfYue();            List&lt;Row&gt; rowsToDel = new ArrayList&lt;&gt;();            for (var row : sheet) &#123;                if (row.getRowNum() == 0 || row.getRowNum() == 1) &#123;                    continue;                &#125;                var name = row.getCell(1).getStringCellValue();                if (!studentsOfYue.contains(name)) &#123;                    rowsToDel.add(row);                &#125;            &#125;            for (var row : rowsToDel) &#123;                sheet.removeRow(row);            &#125;            removeEmptyRow(sheet);                      try (var os = new FileOutputStream(new File(&quot;***********&quot;))) &#123;                workbook.write(os);            &#125;        &#125;    &#125;    /**     * 月月姐班上的同学的姓名     *     * @return 返回月月姐班上的同学的姓名组成的Set     * @throws IOException 找不到人员名单     */    private static Set&lt;String&gt; studentsNameOfYue() throws IOException &#123;        try (var workbook = new XSSFWorkbook(Main.class.getResourceAsStream(&quot;/月.xlsx&quot;))) &#123;            var sheet = workbook.getSheet(&quot;总表&quot;);            Set&lt;String&gt; set = new HashSet&lt;&gt;();            for (var row : sheet) &#123;                if (row.getRowNum() == 0) &#123;                    continue;                &#125;                var cell = row.getCell(1);                set.add(cell.getStringCellValue());            &#125;            return set;        &#125;    &#125;    /**     * 月月姐班上的同学的学号     *     * @return 返回月月姐班上的同学的学号组成的Set     * @throws IOException 找不到人员名单     */    private static Set&lt;String&gt; studentsIdOfYue() throws IOException &#123;        try (var workbook = new XSSFWorkbook(Main.class.getResourceAsStream(&quot;/月.xlsx&quot;))) &#123;            var sheet = workbook.getSheet(&quot;总表&quot;);            Set&lt;String&gt; set = new HashSet&lt;&gt;();            for (var row : sheet) &#123;                if (row.getRowNum() == 0) &#123;                    continue;                &#125;                var cell = row.getCell(2);                var formatter = new DecimalFormat(&quot;#&quot;);                set.add(formatter.format(cell.getNumericCellValue()));            &#125;            return set;        &#125;    &#125;    private static void removeEmptyRow(XSSFSheet sheet) &#123;        int lastRowNum = sheet.getLastRowNum();        for (int i = lastRowNum - 1; i &gt;= 0; i--) &#123;            var row = sheet.getRow(i);            if (isEmptyRow(row)) &#123;                sheet.shiftRows(i + 1, lastRowNum, -1);            &#125;        &#125;    &#125;    private static boolean isEmptyRow(XSSFRow row) &#123;        if (row == null) &#123;            return true;        &#125;        for (var cell : row) &#123;            if (cell != null &amp;&amp; cell.getCellType() != CellType.BLANK) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n运行结果：\n不贴了\nTo be continued…\n","categories":["Java"]},{"title":"Blog Template","url":"/2020/09/21/Blog-Template/","content":"需求我习惯把在LeetCode上写的代码发到博客上，过程中要做一些琐碎的事情，例如：\n先在博客的根目录打开git bash，用hexo命令new一篇新的文章：hexo new “LeetCode-xxx”，用编辑器打开输入分类，题目&lt;!--more--&gt;，结果，代码，复杂度等，如图所示。\n\n\n于是我想借助java稍微简化下步骤，顺便写个GUI，温习一下我的javaFX。\n\n\n产品BETA3.1新特性添加了新功能：树代码生成\n\nBETA3.0新特性添加了新的功能：括号转换和链表代码生成。\n\n\n\nBETA2.0新特性\nGradle也挺好，这次用Gradle。\n增加了Dialog界面\n用JFoenix稍加美化（按钮，输入框）\n调整了一下布局\n\n最终效果\n\nBETA1.0最终效果：\n\n输入文件名和路径（可以设置默认值），点击Execute就可以在对应路径下创建一个模板文件。\n\n\n实现package sample;import javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.control.Label;import javafx.scene.control.TextField;import javafx.scene.image.Image;import javafx.scene.layout.HBox;import javafx.scene.layout.VBox;import javafx.scene.paint.Paint;import javafx.stage.DirectoryChooser;import javafx.stage.Stage;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class Main extends Application &#123;    @Override    public void start(Stage primaryStage) &#123;        VBox vBox = new VBox(20);        HBox hBox1 = new HBox(10);        HBox hBox2 = new HBox(10);        HBox hBox3 = new HBox(10);        vBox.getChildren().addAll(hBox1, hBox2, hBox3);        // HBox-1        Label nameLabel = new Label(&quot;File Name:&quot;);        TextField nameTextField = new TextField(&quot;LeetCode&quot;);        nameTextField.setMinWidth(250);        // HBox-2        Label pathLabel = new Label(&quot;Path:&quot;);        TextField pathTextField = new TextField(&quot;C:\\\\Users\\\\67460\\\\Documents\\\\blog\\\\source\\\\_posts&quot;);        pathTextField.setMinWidth(250);        Button browseButton = new Button(&quot;Browse&quot;);        browseButton.setOnAction(actionEvent -&gt; pathTextField.setText(chooseDirectory(primaryStage).toString()));        // HBox-3        Label infoLabel = new Label();        // Set red color for info label        infoLabel.setTextFill(Paint.valueOf(&quot;#FF0000&quot;));        Button executeButton = new Button(&quot;Execute&quot;);        executeButton.setOnAction(actionEvent -&gt; &#123;            try &#123;                if (createTemplate(pathTextField.getText(), nameTextField.getText())) &#123;                    infoLabel.setText(&quot;Done!&quot;);                &#125; else &#123;                    infoLabel.setText(&quot;The file has already existed!&quot;);                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;);        Button cancelButton = new Button(&quot;Cancel&quot;);        cancelButton.setOnAction(actionEvent -&gt; primaryStage.close());        hBox1.getChildren().addAll(nameLabel, nameTextField);        hBox2.getChildren().addAll(pathLabel, pathTextField, browseButton);        hBox3.getChildren().addAll(infoLabel, executeButton, cancelButton);        hBox1.setPadding(new Insets(20, 20, 10, 20));        hBox1.setAlignment(Pos.CENTER_LEFT);        hBox2.setPadding(new Insets(20));        hBox2.setAlignment(Pos.CENTER);        hBox3.setPadding(new Insets(20));        hBox3.setAlignment(Pos.CENTER_RIGHT);        primaryStage.setTitle(&quot;LeetCode template&quot;);        var image = new Image(&quot;LeetCodeIcon.png&quot;);        primaryStage.getIcons().add(image);        primaryStage.setScene(new Scene(vBox, 400, 240));        primaryStage.show();    &#125;    public static void main(String[] args) &#123;        launch(args);    &#125;    /**     * @param name file name such as LeetCode-233     * @return return true if the file is created successfully and false if the file has already existed     * @throws IOException the operation to file may cause IOException     */    private static boolean createTemplate(String path, String name) throws IOException &#123;        File file = new File(path + &quot;/&quot; + name + &quot;.md&quot;);        if (file.exists()) &#123;            return false;        &#125;        // build the content        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));        String content = String.format(&quot;&quot;&quot;                ---                title: %s                date: %s                tags:                categories: LeetCode                ---                                                ## 题目                                                                                                                &lt;!-- more --&gt;                                                ## 结果                                                                                                                ## 代码                                                                                                                ## 复杂度                                                时间复杂度：O（）                                                空间复杂度：O（）                &quot;&quot;&quot;, name, date);        // Write the content to the file        BufferedWriter writer = new BufferedWriter(new FileWriter(file));        writer.write(content);        writer.flush();        return true;    &#125;    private File chooseDirectory(Stage primaryStage) &#123;        DirectoryChooser directoryChooser = new DirectoryChooser();        directoryChooser.setTitle(&quot;Choose Directory&quot;);        return directoryChooser.showDialog(primaryStage);    &#125;&#125;\n\nWith Go年少不知CLI好，错把GUI当个宝。\n以前总想写个图形界面出来，java的那个用gradle+javafx写的，启动速度好慢啊，费力不讨好，用go重写了一个。\n参数-title：post name\n-tmpl：模板文件的路径，默认在.&#x2F;resources下\n-post：hexo的post路径\n\n\nGithubjava：\nhttps://github.com/carpediemtal/Blog-template\ngo：\nhttps://github.com/carpediemtal/blog-template-with-go\n","categories":["Java"]},{"title":"Bridge","url":"/2020/05/12/Bridge/","content":"桥接\n定义将抽象部分与它的实现部分分离，使它们都可以独立地变化继承存在的问题按特点取名继承\n子类数量爆炸\n\n解决方案在父类里设置一个可以插入的槽位可以将独立的特点划分成不同的Component这些Component可以被插入到槽位里\n\n实现构造方法中添加槽位优点被分离的两个部分可以独立的变化","categories":["Design Patterns"]},{"title":"Command","url":"/2020/05/13/Command/","content":"Command\n我现在是真没有体会到命令模式的必要性，在我看来，这纯粹是脱裤子放屁多此一举。我也看了许多例子，但我都觉得命令模式是没有必要的，他们说的优势在我看来不要命令模式也可以有这种优势，比如封装性好，那不用Command就不封装了吗？我感觉只是多包了一层而已。\n定义将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。\n\n结构Command类\ninterface，有一个execute方法\n\nConcreteCommand类\nCommand的实现类\n\nInvoker类\n调用命令\n\nReceiver\n接收并执行命令\n\n优势封装性好扩展性和复用性很好","categories":["Design Patterns"]},{"title":"Chain Of Responsibility","url":"/2020/05/12/Chain-Of-Responsibility/","content":"责任链\n定义使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。多个处理器按照一定顺序组合排列，依次处理请求\n\n栗子财务申报package eternal.fire;import java.math.BigDecimal;public class Main &#123;    public static void main(String[] args) &#123;        HandlerChain handlerChain = new HandlerChain();        handlerChain.addHandler(new ManagerHandler());        handlerChain.addHandler(new DirectorHandler());        handlerChain.addHandler(new CEOHandler());        handlerChain.process(new Request(&quot;Doomfist&quot;, new BigDecimal(123123)));        handlerChain.process(new Request(&quot;tracer&quot;, new BigDecimal(1231231)));    &#125;&#125;package eternal.fire;import java.util.LinkedList;import java.util.List;public class HandlerChain &#123;    List&lt;Handler&gt; handlerList = new LinkedList&lt;&gt;();    public void addHandler(Handler handler) &#123;        this.handlerList.add(handler);    &#125;        public boolean process(Request request) &#123;        for (var handler : handlerList) &#123;            Boolean result = handler.process(request);            if (result != null) &#123;                if (result) &#123;                    System.out.println(request + &quot; Approved by &quot; + handler.getClass().getSimpleName());                &#125; else &#123;                    System.out.println(request + &quot; Denied by &quot; + handler.getClass().getSimpleName());                &#125;                return result;            &#125;        &#125;        throw new RuntimeException(&quot;idk&quot;);    &#125;&#125;package eternal.fire;import java.math.BigDecimal;public class Request &#123;    private String name;    private BigDecimal amount;    public Request(String name, BigDecimal amount) &#123;        this.name = name;        this.amount = amount;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public BigDecimal getAmount() &#123;        return amount;    &#125;        public void setAmount(BigDecimal amount) &#123;        this.amount = amount;    &#125;        @Override    public String toString() &#123;        return &quot;Request:&quot; + this.name + &quot;,&quot; + this.amount;    &#125;&#125;package eternal.fire;public interface Handler &#123;    /**     *     * @param request the request which are waiting to be handled     * @return true if success, false if refuse, null if pass to next handler     */    Boolean process(Request request);&#125;package eternal.fire;import java.math.BigDecimal;public class ManagerHandler implements Handler&#123;    @Override    public Boolean process(Request request) &#123;        return request.getAmount().compareTo(BigDecimal.valueOf(1000)) &gt; 0 ? null : !request.getName().equals(&quot;Doomfist&quot;);//英雄歧视搞起来    &#125;&#125;\n\n\n\nFilter实现处理器接口\n实现类\n\n组合各种处理器","categories":["Design Patterns"]},{"title":"CROS","url":"/2020/05/14/CROS/","content":"CORS\n全称Cross-Origin Resource SharingRest应用实现\n页面的JavaScript和后端的Rest API互动\n\n限制\n概念：同源\n\n域名相同\n端口相同\n协议相同\n\n\njavaScript只可以访问同源的REST API\n\n想要访问不同源的API要通过CORS\n\n在网站允许的情况下，通过CORS才能访问成功\n\n\n\n\n设置CORS使用@CrossOrigin注解\n允许特定域名跨域访问\n@CrossOrigin(origins = &quot;http://eternalfire.xyz:8080&quot;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;...&#125;\n\n\n\n允许多个域名跨域访问\n@CrossOrigin(origins = &#123;&quot;http://eternalfire.xyz:8080&quot;, &quot;https://www.baidu.com/&quot;&#125;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;...&#125;\n\n\n\n允许所有域名跨域访问\n@CrossOrigin(origins = &quot;*&quot;)@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;...&#125;\n\n使用CorsRegistry\n在WebMvcConfigurer中定义全局配置\n@BeanWebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) &#123;    return new WebMvcConfigurer() &#123;        @Override        public void addInterceptors(InterceptorRegistry registry) &#123;            for (var i : interceptors) &#123;                registry.addInterceptor(i);            &#125;        &#125;        @Override        public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;            registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;/static/&quot;);        &#125;            @Override        public void addCorsMappings(CorsRegistry registry) &#123;            registry.addMapping(&quot;/api/**&quot;)                    .allowedOrigins(&quot;\\&quot;http://eternalfire.xyz:8080\\&quot;&quot;)                    .allowedMethods(&quot;GET&quot;, &quot;POST&quot;);        &#125;    &#125;;&#125;\n\n使用CorsFilter\n和配置Filter的方法一样，一样繁琐\n\n测试用@CrossOrigin(origins &#x3D; “https://www.baidu.com“) 注解我的REST API：\n百度测试：\n\n\n成功；\n京东测试：\n\n\n报错：origin ‘https://www.jd.com‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\n","categories":["Spring"]},{"title":"Composite","url":"/2020/05/12/Composite/","content":"组合\n定义将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。实现统一单个节点以及“容器”节点的接口容器节点可以添加任意个单个节点，形成层级结构\n\n优势Composite模式使得叶子对象和容器对象具有一致性，从而形成统一的树形结构，并用一致的方式去处理它们。\n一致：比如说可以链式操作，很爽\n\n","categories":["Design Patterns"]},{"title":"Cookie、session and token","url":"/2021/04/13/Cookie%E3%80%81session-and-token/","content":"\n\n\n\n\n\n目的由于HTTP请求无状态，需要借助额外的手段来验证用户身份\nsession id方法\n分配给用户session id作为标识\n\n缺陷\n服务器要存所有的session id\n不适合分布式环境或负载均衡\n\ntoken组成\n明文数据\n\n签名\n\n数据+加密算法+秘钥&#x3D;签名\n\n\n\n校验方式\n服务端收到token后用秘钥+加密算法计算签名是否一致\n利用计算时间换取存储空间\n\n优势\n跨程序调用\n因为 用户的身份正确与否 是通过计算得出来的（无状态），不存在session id那样的分布式问题，所以扩展性（随意增加服务器）很好\n\n无状态，可扩展\n因为无状态，所以扩展性好\n\n\ncookie概念\n浏览器提供的数据存储功能\n由服务器生成，存储在客户端\n每个域的cookie数量有限\n\nPS：session，token都可以放在cookie中\n","categories":["计网"]},{"title":"Dead lock","url":"/2020/08/16/Dead-lock/","content":"\n\n\nDead locks概念死锁\n进程永远被阻塞称之为死锁\n\nstarvation\n进程没阻塞但是无限制被推后\n\n资源\n可抢占资源\n不可抢占资源\n\n必要条件\n互斥条件：一个资源每次只能被一个进程使用\n占有和等待条件：已经得到资源的进程可以请求新的资源\n不可抢占条件：被占有的资源只能由占有它的进程显示释放\n环路等待条件：≥2个进程形成一个环，每个进程都在等待下一个进程的资源\n\n处理方法不避免死锁的发生，而是等发生了再解决\n鸵鸟策略\n处理死锁的代价过于高昂\n\n死锁检测\n一对一类型的死锁检测\n每个进程一个资源\n\n检测有向图中环的存在\n\n\n一对多类型的死锁检测\n每个进程多个资源\n\n模拟一下，先执行能执行的，执行完后释放资源。如此往复，最后剩下的都是死锁进程。\n\n\n\n死锁恢复\n抢占\n回滚\nkill进程\n\n死锁预防时间\n程序运行之前\n\n方法\n破坏互斥条件\n\n只读性文件可以不用互斥\n\n\n破坏占有和等待条件\n\n比如让进程在一开始就请求所有所需资源\n\n\n破坏不可抢占条件\n\n破坏环路等待条件\n\n将所有资源编号，进程只能请求比已经持有资源编号更大的资源，这样一来不可能形成环\n\n\n\n死锁避免安全状态\n概念\n\n存在一种调度次序可以使所有进程都能完成\n安全状态也有可能死锁，但一定可以避免死锁\n\n\n\n\n不安全状态\n无法保证所有进程都能完成\n\n银行家算法\n算法\n\n判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。\n\n\n单个资源\n\n多个资源\n\n\n","categories":["OS"]},{"title":"ER图","url":"/2020/12/12/ER%E5%9B%BE/","content":"\n\n\nER图Entity-Relationship\n实体矩形框\n属性圆形框\n联系菱形框\n分类\n一对一\n一对多\n多对多\n\n连线\n实体与属性\n\n实体与联系\n\n联系与属性\n\n\n","categories":["数据库"]},{"title":"DeMon Slayer/鬼灭之刃","url":"/2019/09/28/DeMon-Slayer/","content":"午睡之前有点时间，决心看一集鬼灭之刃然后就去睡觉，结果用了一整个下午把剩下的都看完了。感觉就是很爽，尤其是19集火神，完全不虚巨人的epic time。我想到《了不起的盖茨比》中的一段话，大概是说每个人所经历的不同，你不能去期望别人对于一件事儿和你产生一样的观点，也就是说，不能拿自己的标准去衡量别人。我觉得这部剧很有意思，不论是主角还是反派，每一个角色都有属于自己的故事，因为截然不同的遭遇，所以有完全不同的性格特点，这是一口气25集还能不产生一点儿厌倦心理的主要原因吧。我想对几个主要的出场角色作个简单的分析，除了爽之外，还留下些什么。\n主角：炭治郎\n\n\n故事炭治郎作为主角，他的故事也是整部番的主要剧情。炭治郎作为村里的老好人，下山卖炭，回家时发现除了变成鬼的妹妹Nezuko，都惨遭横祸。之后偶遇鬼杀队的富岗，凭借过人的胆识获得了一封推荐信，在训练师的指导下刻苦训练，最终成功加入鬼杀队，成为带着鬼的鬼杀队员。每个角色在绝境时都会有所回忆，炭治郎在绝境时，回想起的是父亲为火神献上的舞，战斗力爆发，由此斩断了蜘蛛人（忘了叫啥）的蛛丝，火神一集也是全剧的高潮。\n特点：智勇双全 道德模范 坚持不懈 鼻子灵敏###炭治郎的刷怪经历很励志，很热血，但不是毒鸡汤。炭治郎刷怪不只靠主角光环（天赋和运气之类），在战斗过程中，炭治郎即使在战况十分危急，不断遭到挑衅时，还能维持呼吸，不停的在思考，寻求敌人的破绽，而不是一个单纯的奋斗逼，我奋斗还能有错？奋斗逼越努力越傻逼。我很喜欢这个角色。  \n我妻善逸\n故事善逸这个角色的设置，简直不要太真实，和主角真的很互补。善逸的钱财被女人所骗，而且被骗的钱财用来和男人私奔，善逸以又黄又绿的发色登场。一位训练师帮助善逸还了钱，代价是刻苦的训练，以加入鬼杀队。善逸怯懦到极点，总是在逃避，但师傅十分耐心，谆谆教诲。善逸在绝境时，回想到的场景是，师兄指责善逸，说师傅花在善逸身上的时间都是浪费。善逸只会一招，但登峰造极。\n特点：扮猪吃老虎（暂时不知道为什么） 笑点担当 耳朵灵敏###正常情况下，善逸十分怯懦，是战五渣，但是在被吓晕之后，判若两人。善逸是全剧的笑点担当，雷之型有六个种类，然而善逸只能使出雷之呼吸的壹之型，尽管只能使用一个，但善逸凭借自己的努力将其超越极限，磨炼到极限中的极限！在艰难的处境下，善逸的吐槽精神值得学习。\n伊之助\n故事伊之助戴着猪头面具，似乎是想掩盖萌妹长相。伊之助自幼被抛弃，和野兽比力气。因为生活在山中，所以不谙人事，对人的情感难以理解。\n特点：莽夫 触觉灵敏 单纯 好战 不服输 还有猪突猛进###在遇到富冈义勇之前，伊之助无所畏惧，勇往直前，遭遇富冈义勇之后，被社会毒打一蹶不振。随着剧情发展，逐渐懂得人类感情。在与另两位男主的对比之下，性格特点鲜明。头铁的精神是有必要的，但不能如此头铁。。。在三位男主身上，都有不同的值得学习的品质。不同的人生经历，截然不同的性格，十分有趣。我觉得我有时候是伊之助，有时候是善逸，有时候是炭治郎。吹爆鬼灭之刃。\n","categories":["Essay"]},{"title":"FAQ","url":"/2019/10/07/FAQ/","content":"FAQ\n当觉得眼前的事儿很无聊时（比如听无聊的课，做无聊的作业），会感到困倦、瞌睡，这样的机制有什么用？如果非做不可，是应该及时休息还是选择忍受？现在可以公开的情报：排除睡眠不足、气候和疾病，做无聊的事感到困倦的原因是：外部刺激减少，参与欲望下降，从而交感神经兴奋性下降，这是告诉大脑可以休息的信号，控制睡眠的神经元加以影响，睡意就随之而来。作用当然是节能、抓紧时间休息呀。由此看来，这种情况下的困倦是很“良性”的，休息是没有必要的，既然如此，应当加强外部刺激（听课时坐前排和老师互动，回答问题之类的），调动好奇心（哲学三问，栗子代入），体会发现的乐趣。\n\n","categories":["Essay"]},{"title":"Function Prolog","url":"/2021/04/26/Function-Prolog/","content":"","categories":["Go"]},{"title":"Filter模式","url":"/2020/05/12/Filter%E6%A8%A1%E5%BC%8F/","content":"Filter模式\n继承的问题如果新功能的实现依赖于继承（每个新功能对应一个子类）会出现子类数目过多的情况栗子\n给FileInputStream添加解压、签名、加解密\n\n问题的解决分类是不可或缺的\nInputStream\n\nFileInputStream\nByteArrayInputStream\nServletInputStream\nBufferedInputStream\nDigestInputStream\nCipherInputStream\n\n\n\n先new基础类，再以基础类为参数new额外功能类，但统筹调度统一用InputStream\n\n编写FilterInputStreampackage eternal.fire;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;public class CountInputStream extends FilterInputStream &#123;    private int count = 0;    /**     * Creates a &#123;@code FilterInputStream&#125;     * by assigning the  argument &#123;@code in&#125;     * to the field &#123;@code this.in&#125; so as     * to remember it for later use.     *     * @param in the underlying input stream, or &#123;@code null&#125; if     *           this instance is to be created without an underlying stream.     */    public CountInputStream(InputStream in) &#123;        super(in);    &#125;        public int getBytesRead() &#123;        return this.count;    &#125;        @Override    public int read() throws IOException &#123;        int n = in.read();        if (n != -1) &#123;            this.count++;        &#125;        return n;    &#125;        @Override    public int read(byte[] b, int off, int len) throws IOException &#123;        int n = in.read(b, off, len);        this.count++;        return n;    &#125;&#125;\n\n","categories":["Design Patterns"]},{"title":"GO MODULE","url":"/2021/04/11/GO-MODULE/","content":"常用操作开启 GO MODULE 和代理：\ngo env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct\n\n在当前目录初始化新的 MODULE\ngo mod init\n\n在GOLAND中开启GO MODULES\n\n选择：Enable Go Modules Intergration\n\n下载依赖，go get 命令也会自动更新 go.mod 文件\ngo get ./...\n\n添加缺失、移除未用到的 MODULE\ngo mod tidy\n\n下载 MODULE 到本地\ngo mod download\n\n根据依赖创建 vendor 目录\ngo mod vendor\n\n","categories":["Go"]},{"title":"GO GC","url":"/2021/04/26/GO-GC/","content":"","categories":["Go"],"tags":["go","gc"]},{"title":"File System","url":"/2020/08/14/File-System/","content":"相关概念文件系统\n文件+文件管理\n\n文件类型\n普通文件\n目录\n设备文件\n\n\n\n文件访问方法\n顺序访问\n随机访问\n\n文件属性文件结构\nByte\nRecord\nTree\n\nDirectory分级\nSingle Level\n\nTwo Level\n\nHierarchical\n\n优势\n\n定位快\n\n\n劣势\n\n路径可能会很长\n\n\n\n\n\n路径名\n绝对路径\n\n相对路径\n\n.和..\n\n\n\n链接File System ImplementationImplementing Files\n连续分配\n\n增删很麻烦\n\n\n链表分配\n\n随机存取很慢\n\n\nFAT\n\n功能\n\n记录空闲块\n记录文件对应磁盘块的地址\n记录磁盘块的顺序\n\n\n特点\n\n整个FAT表都要放在内存中\n\n\n缺陷\n\n占用内存太大\n\n\n\n\ninode\n\nFAT改进版，只加载打开的文件\n每个文件分配一个inode，其中有文件属性和文件块的地址\n\n\n\nImplementing directtories\n定长存储\n变长存储\n\nLink File Implementation\n软（符号）链接\n\n存目标文件的路径\n需要额外的inode\n\n\n硬链接\n\n目标文件的别名\n硬链接不可以跨文件系统\n\n\n\n","categories":["OS"]},{"title":"Go Slice","url":"/2021/01/26/Go-Slice/","content":"","categories":["Go"],"tags":["go","slice"]},{"title":"GPM","url":"/2021/04/20/GPM/","content":"\n\n\n\n\n\n单进程时代特点\n串行：one by one\n\n缺点\n进程阻塞后，CPU空转\n\n多进程&#x2F;线程时代特点\n并发\n调度\n\n缺点\n进程&#x2F;线程切换代价大\n\n内存占用大\n\n进程：GB\n线程：MB\n\n\n\n协程特点\n非抢占式\n\n协程和线程对应关系\n1:1\n\n1：N\n\n协程阻塞问题\n\n\nM：N\n\n协程调度器\n\n\n\nGoroutine特点\n内存小\n\nKB级别\n\n\n调度灵活\n\nruntime调度\n\n协程阻塞后，其它协程可以被其它线程调用\n\n\n\n\n\n调度器\nGM\n\n组成\n\nG\n\n全局的Goroutine队列\n\n\nM\n\n一组Thread\n\n\n\n\n调度过程\n\n线程互斥的去访问G\n\n创建新Goroutine\n销毁Goroutine\n调度Goroutine\n\n\n\n\n缺点\n\n互斥访问效率低\n\n不满足局部性原理\n\nGoroutine中创建的其它Goroutine由另一个线程负责\n\n\nM之间切换频繁\n\n\n\n\n\nGPM\n\n组成\n\nG\n\n全局Goroutine队列\n\n\nP\n\n持有一个本地Goroutine队列\n数量：$GOMAXPROCS\n\n\nM\n\nThread\n\n\n\n\n调度过程\n\nM访问P中的Goroutine\n\nP不为空\n\nP满了\n\n将本地一半Goroutine移动到全局G队列中\n\n\n\n\nP为空\n\n从其它P中偷取Goroutine加入到P\n从全局队列G中获取Goroutine加入到P\n\n\n\n\nM因G阻塞\n\n释放绑定的P\n创建新的M\n\n\n\n\n\n\n\n","categories":["Go"]},{"title":"HTTP协议","url":"/2020/12/14/HTTP%E5%8D%8F%E8%AE%AE/","content":"\n\n\nHTTP协议相关概念报文\n请求\n\n第一行\n\n请求方法\nURL\n协议版本\n\n\nHeader\n\n空行\n\n请求的内容主体\n\n\n\n响应\n\n第一行\n\n协议版本\n状态码\n描述\n\n\nHeader\n\n空行\n\n响应的内容主体\n\n\n\n\nURLU niform Resource Locator\n\nURI唯一标识一个资源，但可能未定义找的办法\nURL 在 URI 的基础上增加了定位能力\n\nHTTP方法分类\nGET\n\n获取资源\n\n\nHEAD\n\n获取报文首部\n和 GET 方法类似，但不返回报文body部分\n\n\nPOST\n\n传输实体主体\nPOST 主要用来传输数据，而GET 主要用来获取资源\n\n\nPUT\n\n上传文件\n\n\nPATCH\n\n对资源进行部分修改\n\n\nDELETE\n\n删除文件\n\n\nOPTIONS\n\n查询服务器支持的方法\n\n\nCONNECT\n\n要求在与代理服务器通信时建立隧道\n\n\nTRACE\n\n发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输\n\n\n\nGET VS POST\n作用\n\nGET 用于获取资源，而 POST 用于传输实体主体\n\n\n参数\n\nGET 的参数是以查询字符串出现在 URL\n非ASCII需要编码\n\nPOST 的参数存储在实体主体中\n\n\n\n幂等性\n一般来说，服务器不应该因为GET请求而改动（如数据库）\n\nGET幂等，不具有副作用\nPOST不幂等\n\n\n缓存需要满足的条件\n\n方法本身可缓存\n状态码可缓存\nHeader的Cache-Control允许缓存\n\n\nXMLHttpRequest\n\n概念\n\n提供了一个通过 URL 来获取数据的简单方式\n在 AJAX 中被大量使用\n不会使整个页面刷新\n\n\nGET和POST的区别\n\nGET的HEADER和DATA一次性发送\nPOST先后发送\n\n\n\n\n\n状态码响应报文的状态码\n1XX\n\nInformation\n正在处理\n\n\n2XX\n\nSuccess\n正常处理完毕\n\n\n3XX\n\nRedirection\n需要额外操作以完成请求\n\n\n4XX\n\nClient Error\n服务器无法处理请求\n\n\n5XX\n\nSever Error\n服务器处理请求时发生错误\n\n\n\n常见状态码\n200（OK）\n\n3XX\n\n301（永久重定向）\n302（临时重定向）\n\n\n4XX\n\n400（语法错误）\n401（Unauthorized）\n403（Forbidden）\n404（Not Found）\n\n\n\n应用问题连接\n短连接\n\nHTTP 1.0\n一次连接一次请求\n\n\n长连接\n\nHTTP 1.1\n一次连接多次请求\n\n\n流水线\n\n长连接上不等到收到回复就发送新的请求\n\n\n\nCookie\n作用\n\n会话状态管理\n浏览器行为跟踪\n\n\n创建过程\n\n服务器发送的响应报文包含 Set-Cookie 首部字段\n客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器\n\n\n分类\n\n会话期Cookie\n持久性Cookie\n\n\n作用域\n\nDomain 标识指定了哪些主机可以接受 Cookie\nPath 标识指定了主机下的哪些路径可以接受 Cookie\n\n\nHTTP ONLY\n\n标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用\n\n\nCookie VS Session\n\nSession\n\n概念\n\n用户信息通过 Cookie 存储在用户浏览器，利用 Session 存储在服务器端\n\n\n过程\n\n浏览器端存储Session ID，再次请求时Cookie中携带Session ID\n\n\n\n\n禁用Cookie\n\n将Session ID作为URL参数传递\n\n\nSession更安全，但服务器开销更大\n\n\n\n\n缓存\n作用\n\n降低服务器压力\n提高客户端获取资源的速度\n\n\n位置\n\n客户端浏览器缓存\n代理服务器缓存\n\n\nCache-Control\n\n禁止缓存\n\nCache-Control: no-store\n\n\n强制确认缓存\n\nCache-Control: no-cache\n\n\n私有缓存和公有缓存\n\nCache-Control: private（浏览器）\nCache-Control: public（代理服务器）\n\n\n过期机制\n\nmax-age\n\n在请求报文中表示能接受的最大缓存时间\n在响应报文中表示缓存在服务器中存在的时间\n\n\nexpires\n\n\n\n\n\n\n内容\n内容协商\n\n类型\n\n服务端驱动型\n\n概念\n\n服务端根据请求的首部字段Accept-Charset、Accept-Encoding等返回最合适的内容\n\n\n存在的问题\n\n需要额外的冗长的信息\n缓存效率低\n\n\n\n\n代理驱动型\n\n300 Multiple Choices\n406 Not Acceptable\n\n\n\n\nVary\n\n格式\n\nVary: Accept-Language\n\n\n作用\n\n只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源\n\n\n\n\n\n\n内容编码\n\n作用\n\n将实体主体进行压缩，减少传输数据量\n\n\n常见编码方式\n\ngzip\ncompress\ndeflate\nidentity\n\n\n\n\n范围请求\n\n概念\n\n客户端只请求一部分数据\n\n\n字段\n\nRange\nGET &#x2F;z4d4kWk.jpg HTTP&#x2F;1.1Host: i.imgur.comRange: bytes&#x3D;0-1023\n\nAccept-Range\nAccept-Ranges: bytes\n\n\n\n服务端的响应\n\n206 Partial Content\n416 Requested Range Not Satisfiable\n200 OK（不支持范围请求）\n\n\n\n\n\nChunked Transfer Encoding\n可以把数据分割成多块，让浏览器逐步显示页面\n\n多部分对象集合\n报文主体内可含有多种类型的实体同时发送\n\n虚拟主机\nHTTP&#x2F;1.1 使用虚拟主机技术，使得一台服务器拥有多个域名\n\n通信数据转发\n代理\n\n作用\n\n缓存\n负载均衡\n网络访问控制\n访问日志记录\n\n\n分类\n\n正向代理\n\n客户端可以感知代理的存在\n代理客户端\n\n\n反向代理\n\n客户端难以感知代理的存在\n代理服务端\n\n\n\n\n\n\n网关\n\n网关服务器会将 HTTP 转化为其它协议进行通信\n\n\n隧道\n\n使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路\n\n\n\nHTTPSHTTP的安全问题\n明文通信（被窃取）\n不验证对方身份（身份伪装）\n无法验证报文完整性（被篡改）\n\nHTTPS的通信方式\nHTTP–&gt;SSL–&gt;TCP\n\n功能\n加密（防窃取）\n\n对称密钥\n\n速度快\n无法把密钥安全的发送到对方手里\n\n\n非对称密钥\n\n速度慢\n可以把公钥安全的发送到对方手里\n\n\n两种加密方式结合\n\n只用非对称加密方式传对称加密的密钥\n\n\n\n\n认证（防伪装）\n\n作用\n\n向用户保证服务器的身份\n向服务器保证用户的身份\n\n\n\n\n完整性保护（防篡改）\n\nSSL报文摘要\n\n\n\nHTTP 1.1&#x2F;2.0HTTP 1.x的缺陷\n客户端需要使用多个连接才能实现并发和缩短延迟\n不会压缩请求和响应首部，从而导致不必要的网络流量\n不支持有效的资源优先级，致使底层 TCP 连接的利用率低下\n\nHTTP 2.0\n二进制分帧层\n\nHEADERS 帧\nDATA 帧\n\n\n服务端推送附带相关资源\n\nHeader压缩避免重复传输\n\n\n","categories":["计网"]},{"title":"Hello Jlink","url":"/2020/11/22/Hello-Jlink/","content":"概览Java9在package之上引入了一个module（Java Platform Module System）的概念，一些相关的package和resources以及一个描述module的文件就构成了一个module。\n假如我这里有一个简单的java程序：\nimport java.util.logging.Logger;public class Main &#123;\tprivate static final Logger LOG = Logger.getLogger(Main.class.getName());\t    public static void main(String[] args) &#123;        LOG.info(&quot;Hello JLINK and the fucking Modules!&quot;);    &#125;&#125;\t\n\n它只包含4个类：Logger，Main，String和Object，但是在java9之前，要想运行这个程序我们需要JRE的全部，即使是不需要的部分。这是一种浪费。\n所以，一个可以自定义的JRE是最好的选择。\n\n\nDemo准备两个module：hello.modules和main.app\n目录结构\n─simple-module    ├─hello.modules    │  └─module-info.java    │  └─eternal    │      └─fire    │          └─hello    └─main.app    │  └─module-info.java        └─eternal             └─fire                 └─main\n\nhello.modulespackage eternal.fire.hello;public class HelloModules &#123;\tpublic static void func() &#123;\t\tSystem.out.println(&quot;Hello, modules!&quot;);\t&#125;&#125;\n\nmodule hello.modules &#123;\texports eternal.fire.hello;&#125;\n\nmain.apppackage eternal.fire.main;import eternal.fire.hello.HelloModules;public class MainApp&#123;\tpublic static void main(String[] args) &#123;\t\tHelloModules.func();\t&#125;&#125;\n\nmodule main.app &#123;\trequires hello.modules;&#125;\n\n编译javac -d outDir --module-source-path simple-module simple-module/hello.modules/eternal/fire/hello/HelloModules.javajavac -d outDir --module-source-path simple-module simple-module/main.app/eternal/fire/main/MainApp.java\n\n运行java --module-path outDir --module main.app/eternal.fire.main.MainAppHello, modules!\n\n查看依赖关系jdeps --module-path outDir --module main.appmain.app [file:///C:/Users/67460/Desktop/module-project/outDir/main.app/]   requires hello.modules   requires mandated java.base (@15)main.app -&gt; hello.modulesmain.app -&gt; java.base   eternal.fire.main                                  -&gt; eternal.fire.hello                                 hello.modules   eternal.fire.main                                  -&gt; java.lang                                          java.base\n\n使用Jlink生成自定义JREjlink --module-path outDir --add-modules hello.modules,main.app --output jre    jlink --launcher jreLaucher=main.app/eternal.fire.main.MainApp --module-path outDir --add-modules main.app,hello.modules --output jreLauncher\n\n两者的区别在于，后者可以自动生成运行的脚本。\n运行自定义JRE在jre&#x2F;bin目录下和jreLauncher&#x2F;bin目录下，分别运行\nPS C:\\Users\\67460\\Desktop\\module-project\\jre\\bin&gt; ./java --module main.app/eternal.fire.main.MainAppHello, modules!PS C:\\Users\\67460\\Desktop\\module-project\\jreLauncher\\bin&gt; .\\jreLaucherHello, modules!\n\n","categories":["Java"]},{"title":"Heap implementation in Go","url":"/2021/06/18/Heap-implementation-in-Go/","content":"heap最常见的用途就是实现优先级队列，Java、C++库函数中都有PriorityQueue这种数据结构，而Go中的Heap却与众不同。\n\n\n接口heap包中提供了这样一个接口：\ntype Interface interface &#123;\tsort.Interface\tPush(x interface&#123;&#125;) // add x as element Len()\tPop() interface&#123;&#125;   // remove and return element Len() - 1.&#125;\n\n以及Push和Pop两个导出的函数：\n// Push pushes the element x onto the heap.// The complexity is O(log n) where n = h.Len().func Push(h Interface, x interface&#123;&#125;) &#123;\th.Push(x)\tup(h, h.Len()-1)&#125;// Pop removes and returns the minimum element (according to Less) from the heap.// The complexity is O(log n) where n = h.Len().// Pop is equivalent to Remove(h, 0).func Pop(h Interface) interface&#123;&#125; &#123;\tn := h.Len() - 1\th.Swap(0, n)\tdown(h, 0, n)\treturn h.Pop()&#125;\n\n令人困惑的是：这两个函数不是heap.Interface的两个方法，那要如何使用Go提供的Heap呢？\n栗子heap包中Pop和Push函数都要接受heap.Interface类型的参数，因此，要想使用这两个函数，必须先自定义类并实现heap.Interface定义的方法。\n默认建立小顶堆，如果想建立大顶堆，可以重写Heap的Less方法。\ntype Heap []int// sort.Interfacefunc (h Heap) Len() int &#123;\treturn len(h)&#125;// sort.Interfacefunc (h Heap) Less(i, j int) bool &#123;\treturn h[i] &lt; h[j]&#125;// sort.Interfacefunc (h Heap) Swap(i, j int) &#123;\th[i], h[j] = h[j], h[i]&#125;// add x as element Len()func (h *Heap) Push(x interface&#123;&#125;) &#123;\t*h = append(*h, x.(int))&#125;// remove and return element Len() - 1.func (h *Heap) Pop() interface&#123;&#125; &#123;\tv := (*h)[h.Len()-1]\t*h = (*h)[:h.Len()-1]\treturn v&#125;\n\n要注意heap.Interface的Pop和Push方法并非是最终暴露在外让用户调用的接口，而是让heap包去调用的接口。\nPush方法在heap对应底层数据结构（数组）的末尾处加上一个元素，Pop方法删除并返回最后的元素。\n\n上面所做的都是heap包所需的，完整的heap还需要我们提供额外的接口给用户，这一过程需要借助heap包的Push和Pop（不是我们写的Push和Pop）来完成：\ntype Heap []intfunc NewHeap(x ...int) *Heap &#123;   var hp Heap   hp = make([]int, len(x))   copy(hp, x)   heap.Init(&amp;hp)   return &amp;hp&#125;func (h *Heap) Add(x int) &#123;   heap.Push(h, x)&#125;func (h *Heap) Get() int &#123;   return heap.Pop(h).(int)&#125;\n\nPriority Queue可以借助heap来实现Priority Queue：\n// This example demonstrates a priority queue built using the heap interface.package mainimport (\t&quot;container/heap&quot;\t&quot;fmt&quot;)// An Item is something we manage in a priority queue.type Item struct &#123;\tvalue    string // The value of the item; arbitrary.\tpriority int    // The priority of the item in the queue.\t// The index is needed by update and is maintained by the heap.Interface methods.\tindex int // The index of the item in the heap.&#125;// A PriorityQueue implements heap.Interface and holds Items.type PriorityQueue []*Itemfunc (pq PriorityQueue) Len() int &#123; return len(pq) &#125;func (pq PriorityQueue) Less(i, j int) bool &#123;\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\treturn pq[i].priority &gt; pq[j].priority&#125;func (pq PriorityQueue) Swap(i, j int) &#123;\tpq[i], pq[j] = pq[j], pq[i]\tpq[i].index = i\tpq[j].index = j&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123;\tn := len(*pq)\titem := x.(*Item)\titem.index = n\t*pq = append(*pq, item)&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123;\told := *pq\tn := len(old)\titem := old[n-1]\told[n-1] = nil  // avoid memory leak\titem.index = -1 // for safety\t*pq = old[0 : n-1]\treturn item&#125;// update modifies the priority and value of an Item in the queue.func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123;\titem.value = value\titem.priority = priority\theap.Fix(pq, item.index)&#125;// This example creates a PriorityQueue with some items, adds and manipulates an item,// and then removes the items in priority order.func Example_priorityQueue() &#123;\t// Some items and their priorities.\titems := map[string]int&#123;\t\t&quot;banana&quot;: 3, &quot;apple&quot;: 2, &quot;pear&quot;: 4,\t&#125;\t// Create a priority queue, put the items in it, and\t// establish the priority queue (heap) invariants.\tpq := make(PriorityQueue, len(items))\ti := 0\tfor value, priority := range items &#123;\t\tpq[i] = &amp;Item&#123;\t\t\tvalue:    value,\t\t\tpriority: priority,\t\t\tindex:    i,\t\t&#125;\t\ti++\t&#125;\theap.Init(&amp;pq)\t// Insert a new item and then modify its priority.\titem := &amp;Item&#123;\t\tvalue:    &quot;orange&quot;,\t\tpriority: 1,\t&#125;\theap.Push(&amp;pq, item)\tpq.update(item, item.value, 5)\t// Take the items out; they arrive in decreasing priority order.\tfor pq.Len() &gt; 0 &#123;\t\titem := heap.Pop(&amp;pq).(*Item)\t\tfmt.Printf(&quot;%.2d:%s &quot;, item.priority, item.value)\t&#125;\t// Output:\t// 05:orange 04:pear 03:banana 02:apple&#125;\n\nDetail堆（英语：Heap）是计算机科学中的一种特别的完全二叉树。在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。\n对于堆这种数据结构，主要考虑如何建堆（大顶堆或小顶堆）、添加元素或者获取堆顶元素后要维持堆的形态。\n可以参考：堆排序\n建堆对于一颗完全二叉树，最后一个有孩子的节点的下标是：n/2-1，对该节点以及之前的节点进行down操作，即可建成堆。\n// Init establishes the heap invariants required by the other routines in this package.// Init is idempotent with respect to the heap invariants// and may be called whenever the heap invariants may have been invalidated.// The complexity is O(n) where n = h.Len().func Init(h Interface) &#123;\t// heapify\tn := h.Len()\tfor i := n/2 - 1; i &gt;= 0; i-- &#123;\t\tdown(h, i, n)\t&#125;&#125;func down(h Interface, i0, n int) &#123;    // parent\ti := i0    // 也可以用递归的方式\tfor &#123;        // left child\t\tj1 := 2*i + 1        // if left child does not exist\t\tif j1 &gt;= n || j1 &lt; 0 &#123;\t\t\tbreak\t\t&#125;\t\tj := j1 // left child        // if right child exist and smaller than left child\t\tif j2 := j1 + 1; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;\t\t\tj = j2 // = 2*i + 2  // right child\t\t&#125;\t\tif !h.Less(j, i) &#123;\t\t\tbreak\t\t&#125;        // parent swap with the smaller child\t\th.Swap(i, j)\t\ti = j\t&#125;&#125;\n\n插入删除插入：将元素添加到数组末尾，执行up操作\n删除：将堆顶元素和末尾元素互换，数组末尾元素即为索取，再对堆顶元素执行down操作维持堆的形态\n// Push pushes the element x onto the heap.// The complexity is O(log n) where n = h.Len().func Push(h Interface, x interface&#123;&#125;) &#123;\th.Push(x)\tup(h, h.Len()-1)&#125;func up(h Interface, j int) &#123;\tfor &#123;\t\ti := (j - 1) / 2 // parent\t\tif i == j || !h.Less(j, i) &#123;\t\t\tbreak\t\t&#125;\t\th.Swap(i, j)\t\tj = i\t&#125;&#125;// Pop removes and returns the minimum element (according to Less) from the heap.// The complexity is O(log n) where n = h.Len().// Pop is equivalent to Remove(h, 0).func Pop(h Interface) interface&#123;&#125; &#123;\tn := h.Len() - 1\th.Swap(0, n)\tdown(h, 0, n)\treturn h.Pop()&#125;\n\n","categories":["数据结构与算法"],"tags":["heap","Go"]},{"title":"IKBC poker说明书","url":"/2020/07/20/IKBC-poker%E8%AF%B4%E6%98%8E%E4%B9%A6/","content":"键位示意图\n\n\n\n主要功能介绍:\n可携带式 \n60%键盘 搭配 QWERTY 配置(61 Key) \nCherry MX 系列轴 (黑、青、茶、红) \n双层板 PCB \n键帽材质: ABS(喷漆镀膜-LED 专用)、PBT \nLED 背光功能 (LED 专用) \nUSB 介面\n\n包装内容物\n键盘x1\n使用手册 x 1 \nUSB连接线x1\n\n技术性资料键数:US ASCII (61 keys) &#x3D; US 配置尺寸:约. 29.5 x 10.2 x 3.8cm (键盘)连接线:约 1.5 米 (mini USB B type)按键使用寿命:Cherry: &gt;5000 万次\n包装:20 键盘&#x2F;1 纸箱\n介面:USB (DC5V —-100mA)可用配置:US USA\n编程说明\n按 PMode(FN + 右 CTRL) 进入编程模式 (空格右灯闪烁) \n按想要对其编程的键 (空格右灯长亮) \n键入编程内容然后按 PN (空格右灯再次闪烁) 【如果发现没有闪烁，可能是键盘后面第四个开关没有变为off【如果输入着输入着发现空格爆闪，那就是说明超过了14个按键】\n重复步骤 2 和步骤 3 可编程其他键 \n按 PMode(FN + 右 CTRL) 退出编程模式 (空格右灯熄灭)\n\n备注:• 支持 FN 层编程,在选键状态时可以对 FN 组合键(例如: FN + A)编程• 在选键状态(步骤 1)打开文书软件(比如.txt 型文本文档)并按 PN + 任意键可自动分层显示其编程内容• 可以加延时,每按 15ms 键(FN + F) 一次延时 15ms,每按 0.1s 键(FN + G) 一次延时 0.1s,每按 0.5s 键(FN + H) 一次延时 0.5s, 连续多次延时只计一个按键但时间累加• 每个键最多可以编程 14 个按键• 在编程模式 15 秒内没按任何按键会自动退出\n编程使用按 PN + 已编好程的键,或者先按 Toggle(FN+右 SHIFT)让空格左灯亮起,再直接按已编程好的键,此时若按 PN + 已编好程的键会输出原来的键码\n编程示例把A编为123:FN+右CTRL,A,1,2,3,PN继续把FN+A编为456:FN+A,4,5,6,PN继续把 B 编为 CTRL+C: B, CTRL(不放手), 再按 C, 放开 CTRL 和 C, PN继续把 C 编为在 WIN7 下调用 CMD.EXE: WIN, C,FN+G,M,FN+G,D,FN+H,ENTER, PN结束:FN+右CTRL使用已编程的A键:PN+A &#x3D;&gt;输出123使用已编程的FN+A键:PN+FN+A &#x3D;&gt;输出456使用已编程的 C 键: PN + C &#x3D;&gt; CMD.EXE 程序调用\n切换编程直接表达层:Toggle(FN + 右 SHIFT) &#x3D;&gt; 右 FN 灯亮起(1)使用已编程的B键:B &#x3D;&gt;输出CTRL+C的码(注:等如复制)(2)使用已编程的 FN + A 键: FN+ A &#x3D;&gt; 输出 456(注: 不需要再按 PN 键)(3)使用已编程的 C 键: C&#x3D;&gt;调用 CMD.EXE 程序(4)如果要输出 A 键(此时直接按 A 是输出 123): PN + A &#x3D;&gt; A返回出厂设定按住 FN + R, 三秒后 Toggle 灯开始闪烁,继续按住 FN + R 直至空格左灯闪了 9 次便会回复出厂设定\n\n\n","categories":["Experience"]},{"title":"IO","url":"/2020/08/16/IO/","content":"接口IO设备分类\nBlock device\nCharacter divice\n\n\n\n设备接口规范\n可以从硬件手册获取接口规范\n由于机密性，可能只提供开发库\n\n设备控制器\n概念\n\n控制设备的那部分\n\n\n\n地址空间访问内存映射\nIO和内存空间分离\n\n用内存空间\n\n两种挂接方式\n\n\n两者混合\n\n\n访问方法\nDMA controller\n\n地位\n\nCPU代理人\n\n\n工作方式\n\nFly-by mode\ncached mode\n\n\n\n\nInterrupt visit\n\n中断控制器\n精确中断\n非精确中断\n\n\n\n磁臂调度算法FCFSShortest Seek Fist","categories":["OS"]},{"title":"IPC","url":"/2020/08/12/IPC/","content":"IPCinter process communication\nRace Condition2 process want to eat same cake\n\n\n概念\n多个进程访问共享的数据，最终的结果取决于进程运行的时序\n\nhow to avoid\nmutual exclusion\n互斥访问\n\ncritical region\n\n对共享内存进行访问的程序片段\n对关键区提出某种机制避免race condition\n\n\n好的解决方案的原则\n\nno 2 processes may be simultaneously inside their critical regions\n不应对cpu的速度和数量作出任何假设\n临界区外的进程不得阻塞其他进程\n不得使进程无限期的等待进入临界区\n\n\n\n解决方案Mutual Exclusion with Busy waiting\n概念\n\n当一个进程要进入关键区的时候，检查是否可以进入，不能进入就继续检查\n\n\n实现\n\n屏蔽中断（Disable interrupt）\n\n同步顺序执行\n多CPU失效，违背第二条原则\n\n\n锁变量（Lock Variables）\n\n严格轮换法（Strict Alternation）\n\nPeterson‘s solution\n\n相比严格轮换法，引入了一定的随机性\n\n\nTSL指令\n\n需要硬件的帮助\n\n\n\n\n\n\n缺点\n\n浪费CPU时间\n优先级问题\n\n\n\nSleep &amp; Wakeup\n概念\n\n当进程发现自己无法进入关键区时，就sleep，等到它被正要离开关键区的进程wake up\n\n\n栗子\n\nConsumer和Producer\n\n\n实现\n\nSemaphore（信号量）\n\n类比\n\nTraffic Light\n\n\n操作（PV操作）\n\nup\n每次加1会唤醒一个因为down操作陷入睡眠的进程\n\nsamaphore++\n\n\ndown\n如果samaphore&lt;1，调用down方法的进程会陷入睡眠\n\nsamaphore–\n\n\n\n\n数量大小的含义\n\n资源数\n同一个资源可以进入关键区的进程的数量\n\n\n特点\n\n当一个进程结束的时候，其所创建的samaphore对象不会销毁\n\n\n存在位置\n\n内核空间\n如果放在用户空间，进程退出时samaphore会销毁\n\n\n\n缺陷\n\n从用户空间到切换到内核空间需要付出时间代价\n容易死锁\n\n\n\n\nMutex\n\n地位\n\nsimplified Samaphore\n\n\n取值\n\n0\n1\n\n\n状态\n\nlock\nunlock\n\n\n一般用途\n\n单进程里的多线程防止互斥访问\n\n\n存储位置\n\n用户空间\n\n\n和semapahore的区别\n\n进程和线程\n存储位置\n\n\n\n\nMonitor\n\n在pv操作上的一层包装，目的是防止deadlock\n\n栗子\n\njava里的synchronized\n\n\n\n\n\n\n\nMessage PassingBarrier","categories":["OS"]},{"title":"Iterator","url":"/2020/05/15/Iterator/","content":"Iterator\n定义提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n\n需求对数据的集合（不是数学上的集合）进行遍历解决\n通过下标访问集合元素\n集合自身提供一个Iterator\n\n优势不需要知道集合内部的结构是怎样的栗子java中的聚合对象如List都可以通过Iterator遍历For Each简洁的使用Iterator遍历的一种方法编写Iteratorimport java.util.Arrays;import java.util.Iterator;public class ReverseArrayCollection&lt;T&gt; implements Iterable&lt;T&gt; &#123;    private T[] array;    public ReverseArrayCollection(T... obj) &#123;        this.array = Arrays.copyOfRange(obj, 0, obj.length);    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new ReverseIterator();    &#125;    class ReverseIterator implements Iterator&lt;T&gt;&#123;        private int index;        public ReverseIterator() &#123;            this.index = ReverseArrayCollection.this.array.length;        &#125;        @Override        public boolean hasNext() &#123;            return index &gt; 0;        &#125;        @Override        public T next() &#123;            index--;            return array[index];        &#125;    &#125;&#125;\n\n\n\n","categories":["Design Patterns"]},{"title":"Interpreter","url":"/2020/05/14/Interpreter/","content":"Interpreter\n定义给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。针对特定问题设定的解决方案\n\n栗子正则表达式\n字符串变化多端，很难匹配\n整一套新的语法出来——正则表达式\n解释器的实现很复杂，但用正则表达式却很简单\n\n","categories":["Design Patterns"]},{"title":"JIT","url":"/2020/11/16/JIT/","content":"编译与解释共存的java解释\njvm解释执行由javac生成的class字节码\n\n编译\n热点代码通过JIT编译器走编译路线\n\n\n\n编译VS解释编译这种方式速度快不是说编译这个过程本身速度快，而是体现在通过编译生成的机器码可以重复利用，如果代码只执行一遍，解释的方式更快\n编译过程（以HotSpot为例）JIT在最初（JVM刚启动时）并不开始编译\n热点代码检测\n方法\n\n采样\n\n周期性检测线程栈的栈顶，经常出现在栈顶的方法是热点方法\n\n\n计数器\n\n为每个方法甚至是代码块建立计数器，调用一次就加一，超过某个阈值就排队编译\n\n方法调用计数器\n回边计数器（循环）\n\n\n\n\n\n\n对比\n\n周期性检测栈顶得到的结果是执行时间最长的代码而不是使用频率最高的代码，采样法容易受阻塞影响\n计数器法粒度更细，但更麻烦\n\n\n\n开始编译、无缝替换\n问题\n\n采用计数器法检测热点代码，如果遇到死循环（良性），这个方法对应的计数器可能永远不会加一\n\n解决\n\n循环执行完一次两个计数器都会加一\n栈上替换技术，编译版本和解释版本无缝替换\n\n\n\n\n\n\n","categories":["JVM"]},{"title":"JSON","url":"/2020/05/11/JSON/","content":"JSON地位数据传输的一种格式特点UTF-8 Only语法简单，key只能是字符串浏览器认识JSON，可以转为js对象\n开发web应用的不二之选\n\n\n\n支持的数据类型键值对数组字符串数值布尔值空值null用java读写JSON测试函数\npackage eternal.fire;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import java.io.IOException;import java.io.InputStream;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        InputStream inputStream = Main.class.getResourceAsStream(&quot;/book.json&quot;);        ObjectMapper objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        Book book = objectMapper.readValue(inputStream, Book.class);        System.out.println(book.pubDate);        System.out.println(book.price);        System.out.println(book.isbn);        String json = objectMapper.writeValueAsString(book);        System.out.println(json);    &#125;&#125;\n\n自定义解析规则\npackage eternal.fire;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonDeserializer;import java.io.IOException;import java.math.BigInteger;public class IsbnDeserializer extends JsonDeserializer&lt;BigInteger&gt; &#123;    @Override    public BigInteger deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123;        String str = jsonParser.getValueAsString();        if (str != null) &#123;            return new BigInteger(str.replace(&#x27;-&#x27;, &#x27; &#x27;));        &#125;        return null;    &#125;&#125;\n\nJava Beanpackage eternal.fire;import com.fasterxml.jackson.databind.annotation.JsonDeserialize;import java.math.BigDecimal;import java.math.BigInteger;import java.time.LocalDate;import java.util.List;public class Book &#123;    public long id;    public String name;    public String author;    @JsonDeserialize(using = IsbnDeserializer.class)    public BigInteger isbn;    public List&lt;String&gt; tags;    public LocalDate pubDate;    public BigDecimal price;&#125;\n\n要解析的JSON\n&#123;  &quot;id&quot;: 1,  &quot;name&quot;: &quot;Java核心技术&quot;,  &quot;author&quot;: &quot;Cay S. Horstmann&quot;,  &quot;isbn&quot;: &quot;978-7-111-54742-6&quot;,  &quot;tags&quot;: [&quot;Java&quot;, &quot;Network&quot;],  &quot;pubDate&quot;: &quot;2016-09-01&quot;,  &quot;price&quot;: 119.5&#125;\n\n\n\n反序列化\nJSON转化为一般的java对象\nJSON转化为特殊的java对象，例如LocalTime\n自定义解析规则\n\n序列化\n自定义解析规则\n\n","categories":["Java"]},{"title":"JavaFX常用操作","url":"/2020/12/03/JavaFX%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","content":"\n\n运行Mavenpom.xml\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;hellofx&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.release&gt;11&lt;/maven.compiler.release&gt;        &lt;javafx.version&gt;13&lt;/javafx.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;            &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;            &lt;version&gt;$&#123;javafx.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;            &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;            &lt;version&gt;$&#123;javafx.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;release&gt;$&#123;maven.compiler.release&#125;&lt;/release&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.openjfx&lt;/groupId&gt;                &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;0.0.3&lt;/version&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;org.openjfx.App&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n使用HelloFX -&gt; Plugins -&gt; compiler -&gt; compiler:compile 编译项目, 使用 HelloFX -&gt; Plugins -&gt; javafx -&gt; javafx:run 执行项目.\nGradlebuild.gradle\nplugins &#123;  id &#x27;application&#x27;  id &#x27;org.openjfx.javafxplugin&#x27; version &#x27;0.0.8&#x27;&#125;repositories &#123;    mavenCentral()&#125;dependencies &#123;&#125;javafx &#123;    version = &quot;13&quot;    modules = [ &#x27;javafx.controls&#x27;, &#x27;javafx.fxml&#x27; ]&#125;mainClassName = &#x27;org.openjfx.MainApp&#x27;\n\n使用 hellofx -&gt; Tasks -&gt; build -&gt; build 构建项目\n使用 hellofx -&gt; Tasks -&gt; application -&gt; run 运行项目\nJfoenixjfoenix提供了许多漂亮的组件，与JavaFX本身提供的组件完全兼容。\n依赖项：\ndependencies &#123;    compile &#x27;com.jfoenix:jfoenix:9.0.10&#x27;&#125;\n\n将jfoenix-components.css放在Resources&#x2F;css目录下，给Scene设置：\nscene.getStylesheets().add(Draw.class.getResource(&quot;/css/jfoenix-components.css&quot;).toExternalForm());\n\n按钮样例\nJFXButton githubBtn = new JFXButton(&quot;Github&quot;);githubBtn.setMaxWidth(90);githubBtn.getStyleClass().add(&quot;button-raised&quot;);\n\n更换窗口图标将图标置于resources目录下，并：\nprimaryStage.getIcons().add(new Image(Draw.class.getResourceAsStream(&quot;/xxx.png&quot;)));\n\n为按钮添加图标将图标置于resources目录下，并：\nvar githubIcon = new ImageView(new Image(Draw.class.getResourceAsStream(&quot;/github.png&quot;)));githubIcon.setFitWidth(20);githubIcon.setFitHeight(20);btn.setGraphic(githubIcon);","categories":["Java"]},{"title":"JavaScript中的this","url":"/2020/07/18/JavaScript%E4%B8%AD%E7%9A%84this/","content":"关于this到底指向谁这件事\n\n全局环境下的this情况一function f1()&#123;\tconsole.log(this);&#125;f1(); //windowfunction f2()&#123;\t&#x27;use strict&#x27;;\tconsole.log(this);&#125;f2(); //undefined\n\n可见，在非严格模式下直接调用，this指向window；严格模式下，this指向undefined。\n情况二const obj = &#123;    num: 10,    f: function()&#123;        console.log(this);        console.log(this.num);    &#125;&#125;obj.f(); // 输出：&#123;num: 10, f:f&#125;, 10\n\n可见，如果函数被通过上一层对象调用，this会指向上一层的对象。\n情况三const obj = &#123;    num: 10,    f: function()&#123;        console.log(this);        console.log(this.num);    &#125;&#125;const ff = obj.f;ff(); // 输出：window，undefined\n\n可见，如果函数f在window的全局环境中直接执行，this仍然指向window。\n总结在函数被执行时，如果函数中的this是被上一层对象所调用，那么this指向上一层对象，否则指向window。\n上下文对象调用中的 this情况一const game = &#123;    name: &#x27;overwatch&#x27;,    hero: &#123;        name: &#x27;tracer&#x27;,        f: function()&#123;            return this.name;        &#125;    &#125;&#125;console.log(game.hero.f()); // 输出：tarcer\n\n可见，this指向最后调用它的对象hero。\n情况二const obj1 = &#123;    name: &#x27;tracer&#x27;,    f: function()&#123;        return this.name;    &#125;&#125;const obj2 = &#123;    name: &#x27;genji&#x27;,    f: function()&#123;        return obj1.f();    &#125;&#125;const obj3 = &#123;    name: &#x27;doomfist&#x27;,    f: function()&#123;        const ff = obj1.f;        return ff();    &#125;&#125;console.log(obj1.f()); // 输出：tracerconsole.log(obj2.f()); // 输出：tracerconsole.log(obj3.f()); // 输出：undefined\n\n聪明的你告诉我，这是为什么呢？\n第一个调用，this指向obj1，结果无可厚非。\n第二个调用，this仍然指向obj1。\n第三个调用，this指向window，所以结果是undefined。\n箭头函数中的this一言以蔽之，箭头函数中的this指向定义箭头函数时所在的对象。\n","categories":["JavaScript"]},{"title":"Java内存区域与内存溢出异常","url":"/2020/05/12/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","content":"Java内存区域与内存溢出异常\n概述C\\C++\n内存管理区域的土皇帝\n\nJava\nnew操作不需要去写配对的delete代码\n\n不容易内存泄漏和内存溢出\n\n内存泄漏\nMemory Leak程序动态申请的堆内存没有释放或者无法释放，后果可能是运行变慢，也可能是程序崩溃。问题具有积累性。\n\n内存溢出\nOut of Memory意思是内存不够了，你要加内存条了。内存泄漏可能会导致内存溢出。\n\n\n\n一旦泄漏或溢出，不懂JVM没办法Debug\n\n\n\n\n运行时数据区域JVM会把她管理的内存划分为若干个区域\n程序计数器\n\n特点\n\n占用内存空间较少\n线程私有\n\n\n作用\n\n告诉当前线程应该执行哪一行字节码\n\n比如一个条件语句之后的跳转就可以通过设置程序计数器来实现，循环，异常处理也是如此\n\n\n\n\n多线程的实现\n\n线程轮流切换\n分配处理器执行时间\n每个线程要有自己独立的程序计数器\n\n\n值\n\n执行java方法\n\n正在执行的字节码的地址\n\n\n执行native方法\nA native method is a Java method whose implementation is provided by non-java code.\n\nnull\n\n\n\n\n\n\njava虚拟机栈\n\n特点\n\n生命周期和线程相同\n线程私有\n\n\n作用\n\n描述java方法执行的内存模型\n\n栈帧\n\n内容\n\n局部变量表\n\n基本数据类型\n\n对象引用\n\n对象引用不等同于对象本身，可能是指向对象起始地址的指针，这个指针也可能指向其他和这个对象相关的位置\n\n\nreturnAddress类型\n\n指向字节码的指针\n\n\n\n\n\n\n特点\n\n方法被执行时创建\n\n方法执行完成\n\n出栈\n\n\n方法被调用\n\n入栈\n\n\n\n\n\n\n\n\n\n\n笼统的内存划分\n\n栈内存\n\n这个栈内存就指的是虚拟机栈\n\n\n堆内存\n\n\n\n异常\n\n虚拟机栈不可以动态扩展\n\n线程请求的栈深度大于虚拟机所允许的深度会抛出StackOverFlowError\n\n\n虚拟机栈可以动态扩展\n\n扩展时会申请内存，申请不到内存会抛出OutOfMemory异常\n\n\n\n\n\n\n本地方法栈\n\n作用\n\n和Java虚拟机栈类似，只不过为Native Method服务\n\n\n异常\n\n和java虚拟机栈一样\n\n\n有的虚拟机（如HotSpot）把本地方法栈和jvm栈合二为一，不做区别\n\n\n\nJava堆\n\n特点\n\njvm管理内存里最大的一块\n\n所有线程共享\n\nJVM启动时创建\n\n垃圾收集器管理的主要区域\n\n因此得名GC堆（Garbage Collected heap）\n为什么不翻译成垃圾堆？哈哈哈哈哈\n\n\n\n内存空间在物理上可以不连续，逻辑上要连续\n\n主流JVM的java heap可以扩展\n\n\n\n作用\n\n存放对象实例以及数组\n\n\n垃圾收集器\n\n分代收集算法\n\n\n分类\n\n粗分\n\n新生代\n老生代\n\n\n细分\n\nEden空间\nFrom Survivor空间\nTo Survivor空间\n\n\n\n\n异常\n\n\n\n方法区\n有个别名叫Non Heap，许多人称之为永久代\n\n特点\n\n线程共享\n\n不需要物理上连续的内存\n\n大小可扩展\n\n可以选择不进行垃圾回收\n\n回收成果难以令人满意\n不回收可能会导致内存泄漏\n\n\n\n\n作用\n\n已经被jvm加载的类信息\n常量\n静态变量\n即时编译器编译后的代码\n\n\n异常\n\nOutOfMemoryError\n\n\n运行常量池\n方法区的一部分\n\nClass文件\n\n类的版本\n\n字段\n\n方法\n\n接口\n\n常量池（Constant Pool Table）\n\n编译器生成的字面量、符号量\n字面量：    literal我理解是这样的，比如int n &#x3D; 2；这个2就是n的字面量，再比如我有个Hero类，类中有许多属性，所以我不能直接Hero tracer &#x3D; “tracer”，这就没有字面量。意思就是能表示出来的就是字面量。符号量：Symbolic References我觉得这个翻译并不恰当，我还以为这个符号指的是感叹号问号那一类的符号。其实是这样的，在编译期间，编译器可能不知道我的某个类的具体位置，比如我的某个method里有个Undefined类（名字我瞎起的），编译器起初并不知道这个Undefined类在哪里，所以索性先用Undefined这个“符号”标记，以后再说。与之相对的是直接引用，直接应用可以是直接指向变量的指针之类的\n\n这部分内容会在类加载后存放到方法区的运行常量池里\n\n\n\n\n\n翻译出的直接引用也会存到运行常量池里\n\n动态性\n\n运行期间新的常量也可能放入运行常量池中\n\n栗子\npublic class Main &#123;    public static void main(String[] args) &#123;        String s1 = new String(&quot;intern?&quot;);        String s2 = new String(&quot;intern?&quot;);        System.out.println(s1 == s2);   //false​    String s3 = s1.intern();​    String s4 = &quot;intern?&quot;;​    System.out.println(s3 == s4);   //true&#125;&#125;\n\n\n\n\nString类的intern方法\n\nnew出来的String会被放在java Heap里\n通过字面量对String初始化，她会先在运行常量池里寻找，找到则返回池里的引用，否则就在池里创建一个并返回引用。\nnew出来的String调用intern方法会把自己的引用添加到运行常量池里\n\n\n\n\n\n\n异常\n\nOutOfMemoryError\n\n\n\n\n\n\n直接内存\n\n特点\n\n不属于JVM运行时数据区域\n既然不属于，为什么要归在这类呢？原因是这个内存区域访问也很多，也可能OutOfMemory，所以一起看啦。\n\n\n\n异常\n\n既然不属于JVM运行时数据区域，当然不会受到java heap大小的限制，但是会受到电脑物理内存的限制。有些服务器管理员设置参数的时候，直接把直接内存忽略掉了，结果是因为没考虑到直接内存，所以使各个区域内存总和大于物理内存的限制，动态扩展时可能OutOfMemoryError\n\n\n\n\n\n对象访问栗子\nObject object &#x3D; new Object();\nnew出来的Object实例放在java heap里\n左边这个reference放在jvm stack里\n实例还需要一些关于类的信息（可能是为了反射？idk），这些信息放在方法区\n\n引用的定位方式jvm规范只要求这个reference要指向对象，但没说怎么去定位。不同虚拟机定位方式或许不同。\n\n句柄（handle）\n\njava heap中再分出一块内存作为句柄池\nreference中存储对象的句柄地址\n句柄里有对象实例数据的地址和类型数据的地址\n\n\n直接指针\n\nreference中存储对象的实例数据的地址\n实例数据里包含类型数据的地址\n\n\n\n两种定位方式的优劣\n用句柄的话，移动对象不需要改变reference，只需要改变句柄中的实例数据地址\n\n用直接指针的话，访问对象的时候比用句柄少一次指针定位的时间，积少成多，而且访问对象是很频繁的操作。\nSun HotSpot用的直接指针定位\n\n\nOutOfMemory异常java堆溢出\n栗子\n\njava堆里存的是对象实例，只要一直new对象，就会产生内存溢出异常\npublic class Main &#123;    //-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8    public static void main(String[] args) &#123;        List&lt;String&gt; list = new LinkedList&lt;&gt;();        while (true) &#123;            String s = new String(&quot;stack over flow&quot;);            list.add(s);        &#125;    &#125;&#125;\n\n\n\n运行结果\nD:\\Software\\Java\\jdk-14\\bin\\java.exe -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;8 “-javaagent:D:\\Software\\JetBrains\\IntelliJ IDEA 2019.2.2\\lib\\idea_rt.jar&#x3D;49458:D:\\Software\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin” -Dfile.encoding&#x3D;UTF-8 -classpath D:\\Software\\Java\\javafx-sdk-11.0.2\\lib;D:\\Software\\Java\\javafx-sdk-11.0.2\\bin;D:\\Project\\IdeaProjects\\JVM\\out\\production\\JVM eternal.fire.Main[0.017s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.[0.027s][info ][gc,heap] Heap region size: 1M[0.027s][info ][gc,heap,coops] Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit[0.029s][info ][gc      ] Using G1[0.052s][info ][gc      ] Periodic GC disabled[0.142s][info ][gc,start   ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)[0.142s][info ][gc,task   ] GC(0) Using 2 workers of 4 for evacuation[0.162s][info ][gc,phases  ] GC(0)  Pre Evacuate Collection Set: 0.0ms[0.162s][info ][gc,phases  ] GC(0)  Merge Heap Roots: 0.0ms[0.162s][info ][gc,phases  ] GC(0)  Evacuate Collection Set: 19.2ms[0.162s][info ][gc,phases  ] GC(0)  Post Evacuate Collection Set: 0.2ms[0.162s][info ][gc,phases  ] GC(0)  Other: 0.2ms[0.162s][info ][gc,heap   ] GC(0) Eden regions: 10-&gt;0(8)[0.162s][info ][gc,heap   ] GC(0) Survivor regions: 0-&gt;2(2)[0.162s][info ][gc,heap   ] GC(0) Old regions: 0-&gt;7[0.162s][info ][gc,heap   ] GC(0) Archive regions: 0-&gt;0[0.162s][info ][gc,heap   ] GC(0) Humongous regions: 0-&gt;0[0.162s][info ][gc,metaspace ] GC(0) Metaspace: 828K(4864K)-&gt;828K(4864K) NonClass: 752K(4352K)-&gt;752K(4352K) Class: 76K(512K)-&gt;76K(512K)[0.162s][info ][gc      ] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 10M-&gt;8M(20M) 19.717ms[0.162s][info ][gc,cpu    ] GC(0) User&#x3D;0.03s Sys&#x3D;0.00s Real&#x3D;0.02s[0.164s][info ][gc,start   ] GC(1) Pause Young (Normal) (G1 Evacuation Pause)[0.164s][info ][gc,task   ] GC(1) Using 2 workers of 4 for evacuation[0.195s][info ][gc      ] GC(1) To-space exhausted[0.195s][info ][gc,phases  ] GC(1)  Pre Evacuate Collection Set: 0.0ms[0.195s][info ][gc,phases  ] GC(1)  Merge Heap Roots: 0.1ms[0.195s][info ][gc,phases  ] GC(1)  Evacuate Collection Set: 24.8ms[0.195s][info ][gc,phases  ] GC(1)  Post Evacuate Collection Set: 6.1ms[0.195s][info ][gc,phases  ] GC(1)  Other: 0.1ms[0.195s][info ][gc,heap   ] GC(1) Eden regions: 8-&gt;0(9)[0.195s][info ][gc,heap   ] GC(1) Survivor regions: 2-&gt;1(2)[0.195s][info ][gc,heap   ] GC(1) Old regions: 7-&gt;18[0.195s][info ][gc,heap   ] GC(1) Archive regions: 0-&gt;0[0.195s][info ][gc,heap   ] GC(1) Humongous regions: 0-&gt;0[0.195s][info ][gc,metaspace ] GC(1) Metaspace: 860K(4864K)-&gt;860K(4864K) NonClass: 776K(4352K)-&gt;776K(4352K) Class: 83K(512K)-&gt;83K(512K)[0.195s][info ][gc      ] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 16M-&gt;19M(20M) 31.208ms[0.195s][info ][gc,cpu    ] GC(1) User&#x3D;0.05s Sys&#x3D;0.02s Real&#x3D;0.03s[0.196s][info ][gc,start   ] GC(2) Pause Young (Concurrent Start) (G1 Evacuation Pause)[0.196s][info ][gc,task   ] GC(2) Using 2 workers of 4 for evacuation[0.206s][info ][gc      ] GC(2) To-space exhausted[0.206s][info ][gc,phases  ] GC(2)  Pre Evacuate Collection Set: 0.0ms[0.206s][info ][gc,phases  ] GC(2)  Merge Heap Roots: 0.1ms[0.206s][info ][gc,phases  ] GC(2)  Evacuate Collection Set: 7.6ms[0.206s][info ][gc,phases  ] GC(2)  Post Evacuate Collection Set: 2.5ms[0.206s][info ][gc,phases  ] GC(2)  Other: 0.1ms[0.206s][info ][gc,heap   ] GC(2) Eden regions: 1-&gt;0(10)[0.206s][info ][gc,heap   ] GC(2) Survivor regions: 1-&gt;0(0)[0.206s][info ][gc,heap   ] GC(2) Old regions: 18-&gt;20[0.206s][info ][gc,heap   ] GC(2) Archive regions: 0-&gt;0[0.206s][info ][gc,heap   ] GC(2) Humongous regions: 0-&gt;0[0.206s][info ][gc,metaspace ] GC(2) Metaspace: 863K(4864K)-&gt;863K(4864K) NonClass: 779K(4352K)-&gt;779K(4352K) Class: 84K(512K)-&gt;84K(512K)[0.206s][info ][gc      ] GC(2) Pause Young (Concurrent Start) (G1 Evacuation Pause) 20M-&gt;20M(20M) 10.425ms[0.206s][info ][gc,cpu    ] GC(2) User&#x3D;0.03s Sys&#x3D;0.00s Real&#x3D;0.01s[0.206s][info ][gc      ] GC(3) Concurrent Cycle[0.206s][info ][gc,task   ] GC(4) Using 2 workers of 4 for full compaction[0.206s][info ][gc,marking  ] GC(3) Concurrent Clear Claimed Marks[0.206s][info ][gc,marking  ] GC(3) Concurrent Clear Claimed Marks 0.010ms[0.206s][info ][gc,marking  ] GC(3) Concurrent Scan Root Regions[0.206s][info ][gc,marking  ] GC(3) Concurrent Scan Root Regions 0.005ms[0.206s][info ][gc,marking  ] GC(3) Concurrent Mark (0.206s)[0.206s][info ][gc,marking  ] GC(3) Concurrent Mark From Roots[0.206s][info ][gc,task   ] GC(3) Using 1 workers of 1 for marking[0.206s][info ][gc,start   ] GC(4) Pause Full (G1 Evacuation Pause)[0.207s][info ][gc,phases,start] GC(4) Phase 1: Mark live objects[0.222s][info ][gc,phases   ] GC(4) Phase 1: Mark live objects 15.531ms[0.222s][info ][gc,phases,start] GC(4) Phase 2: Prepare for compaction[0.225s][info ][gc,phases   ] GC(4) Phase 2: Prepare for compaction 3.259ms[0.226s][info ][gc,phases,start] GC(4) Phase 3: Adjust pointers[0.230s][info ][gc,phases   ] GC(4) Phase 3: Adjust pointers 4.823ms[0.230s][info ][gc,phases,start] GC(4) Phase 4: Compact heap[0.234s][info ][gc,phases   ] GC(4) Phase 4: Compact heap 3.391ms[0.234s][info ][gc,heap    ] GC(4) Eden regions: 0-&gt;0(10)[0.234s][info ][gc,heap    ] GC(4) Survivor regions: 0-&gt;0(0)[0.234s][info ][gc,heap    ] GC(4) Old regions: 20-&gt;19[0.234s][info ][gc,heap    ] GC(4) Archive regions: 0-&gt;0[0.234s][info ][gc,heap    ] GC(4) Humongous regions: 0-&gt;0[0.234s][info ][gc,metaspace  ] GC(4) Metaspace: 863K(4864K)-&gt;863K(4864K) NonClass: 779K(4352K)-&gt;779K(4352K) Class: 84K(512K)-&gt;84K(512K)[0.234s][info ][gc       ] GC(4) Pause Full (G1 Evacuation Pause) 20M-&gt;17M(20M) 27.490ms[0.234s][info ][gc,cpu     ] GC(4) User&#x3D;0.06s Sys&#x3D;0.00s Real&#x3D;0.03s[0.234s][info ][gc,marking   ] GC(3) Concurrent Mark From Roots 27.911ms[0.234s][info ][gc,marking   ] GC(3) Concurrent Mark Abort[0.234s][info ][gc       ] GC(3) Concurrent Cycle 27.980ms[0.235s][info ][gc,start    ] GC(5) Pause Young (Normal) (G1 Evacuation Pause)[0.235s][info ][gc,task    ] GC(5) Using 2 workers of 4 for evacuation[0.239s][info ][gc       ] GC(5) To-space exhausted[0.239s][info ][gc,phases   ] GC(5)  Pre Evacuate Collection Set: 0.0ms[0.239s][info ][gc,phases   ] GC(5)  Merge Heap Roots: 0.0ms[0.239s][info ][gc,phases   ] GC(5)  Evacuate Collection Set: 2.7ms[0.239s][info ][gc,phases   ] GC(5)  Post Evacuate Collection Set: 1.5ms[0.239s][info ][gc,phases   ] GC(5)  Other: 0.1ms[0.239s][info ][gc,heap    ] GC(5) Eden regions: 1-&gt;0(10)[0.239s][info ][gc,heap    ] GC(5) Survivor regions: 0-&gt;0(0)[0.239s][info ][gc,heap    ] GC(5) Old regions: 19-&gt;20[0.239s][info ][gc,heap    ] GC(5) Archive regions: 0-&gt;0[0.239s][info ][gc,heap    ] GC(5) Humongous regions: 0-&gt;0[0.239s][info ][gc,metaspace  ] GC(5) Metaspace: 877K(4864K)-&gt;877K(4864K) NonClass: 791K(4352K)-&gt;791K(4352K) Class: 85K(512K)-&gt;85K(512K)[0.239s][info ][gc       ] GC(5) Pause Young (Normal) (G1 Evacuation Pause) 18M-&gt;18M(20M) 4.331ms[0.239s][info ][gc,cpu     ] GC(5) User&#x3D;0.00s Sys&#x3D;0.00s Real&#x3D;0.00s[0.239s][info ][gc,task    ] GC(6) Using 2 workers of 4 for full compaction[0.239s][info ][gc,start    ] GC(6) Pause Full (G1 Evacuation Pause)[0.239s][info ][gc,phases,start] GC(6) Phase 1: Mark live objects[0.260s][info ][gc,phases   ] GC(6) Phase 1: Mark live objects 20.870ms[0.260s][info ][gc,phases,start] GC(6) Phase 2: Prepare for compaction[0.265s][info ][gc,phases   ] GC(6) Phase 2: Prepare for compaction 4.449ms[0.265s][info ][gc,phases,start] GC(6) Phase 3: Adjust pointers[0.270s][info ][gc,phases   ] GC(6) Phase 3: Adjust pointers 4.844ms[0.270s][info ][gc,phases,start] GC(6) Phase 4: Compact heap[0.273s][info ][gc,phases   ] GC(6) Phase 4: Compact heap 2.932ms[0.273s][info ][gc,heap    ] GC(6) Eden regions: 0-&gt;0(10)[0.273s][info ][gc,heap    ] GC(6) Survivor regions: 0-&gt;0(0)[0.273s][info ][gc,heap    ] GC(6) Old regions: 20-&gt;19[0.273s][info ][gc,heap    ] GC(6) Archive regions: 0-&gt;0[0.273s][info ][gc,heap    ] GC(6) Humongous regions: 0-&gt;0[0.273s][info ][gc,metaspace  ] GC(6) Metaspace: 877K(4864K)-&gt;877K(4864K) NonClass: 791K(4352K)-&gt;791K(4352K) Class: 85K(512K)-&gt;85K(512K)[0.273s][info ][gc       ] GC(6) Pause Full (G1 Evacuation Pause) 18M-&gt;18M(20M) 33.448ms[0.273s][info ][gc,cpu     ] GC(6) User&#x3D;0.03s Sys&#x3D;0.00s Real&#x3D;0.03s[0.274s][info ][gc,start    ] GC(7) Pause Young (Concurrent Start) (G1 Evacuation Pause)[0.274s][info ][gc,task    ] GC(7) Using 2 workers of 4 for evacuation[0.279s][info ][gc       ] GC(7) To-space exhausted[0.279s][info ][gc,phases   ] GC(7)  Pre Evacuate Collection Set: 0.0ms[0.279s][info ][gc,phases   ] GC(7)  Merge Heap Roots: 0.0ms[0.279s][info ][gc,phases   ] GC(7)  Evacuate Collection Set: 2.6ms[0.279s][info ][gc,phases   ] GC(7)  Post Evacuate Collection Set: 2.0ms[0.279s][info ][gc,phases   ] GC(7)  Other: 0.1ms[0.279s][info ][gc,heap    ] GC(7) Eden regions: 1-&gt;0(10)[0.279s][info ][gc,heap    ] GC(7) Survivor regions: 0-&gt;0(0)[0.279s][info ][gc,heap    ] GC(7) Old regions: 19-&gt;20[0.279s][info ][gc,heap    ] GC(7) Archive regions: 0-&gt;0[0.279s][info ][gc,heap    ] GC(7) Humongous regions: 0-&gt;0[0.279s][info ][gc,metaspace  ] GC(7) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.279s][info ][gc       ] GC(7) Pause Young (Concurrent Start) (G1 Evacuation Pause) 19M-&gt;19M(20M) 4.810ms[0.279s][info ][gc,cpu     ] GC(7) User&#x3D;0.02s Sys&#x3D;0.00s Real&#x3D;0.01s[0.279s][info ][gc,task    ] GC(8) Using 2 workers of 4 for full compaction[0.279s][info ][gc,start    ] GC(8) Pause Full (G1 Evacuation Pause)[0.279s][info ][gc       ] GC(9) Concurrent Cycle[0.279s][info ][gc,marking   ] GC(9) Concurrent Clear Claimed Marks[0.279s][info ][gc,marking   ] GC(9) Concurrent Clear Claimed Marks 0.007ms[0.279s][info ][gc,marking   ] GC(9) Concurrent Scan Root Regions[0.279s][info ][gc,marking   ] GC(9) Concurrent Scan Root Regions 0.004ms[0.279s][info ][gc,marking   ] GC(9) Concurrent Mark (0.279s)[0.279s][info ][gc,phases,start] GC(8) Phase 1: Mark live objects[0.297s][info ][gc,phases   ] GC(8) Phase 1: Mark live objects 17.333ms[0.297s][info ][gc,phases,start] GC(8) Phase 2: Prepare for compaction[0.300s][info ][gc,phases   ] GC(8) Phase 2: Prepare for compaction 3.819ms[0.300s][info ][gc,phases,start] GC(8) Phase 3: Adjust pointers[0.306s][info ][gc,phases   ] GC(8) Phase 3: Adjust pointers 5.189ms[0.306s][info ][gc,phases,start] GC(8) Phase 4: Compact heap[0.309s][info ][gc,phases   ] GC(8) Phase 4: Compact heap 3.243ms[0.309s][info ][gc,heap    ] GC(8) Eden regions: 0-&gt;0(10)[0.309s][info ][gc,heap    ] GC(8) Survivor regions: 0-&gt;0(0)[0.309s][info ][gc,heap    ] GC(8) Old regions: 20-&gt;20[0.309s][info ][gc,heap    ] GC(8) Archive regions: 0-&gt;0[0.309s][info ][gc,heap    ] GC(8) Humongous regions: 0-&gt;0[0.309s][info ][gc,metaspace  ] GC(8) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.309s][info ][gc       ] GC(8) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 29.953ms[0.309s][info ][gc,cpu     ] GC(8) User&#x3D;0.02s Sys&#x3D;0.00s Real&#x3D;0.03s[0.309s][info ][gc,task    ] GC(10) Using 2 workers of 4 for full compaction[0.310s][info ][gc,start    ] GC(10) Pause Full (G1 Evacuation Pause)[0.310s][info ][gc,phases,start] GC(10) Phase 1: Mark live objects[0.327s][info ][gc,phases   ] GC(10) Phase 1: Mark live objects 17.019ms[0.327s][info ][gc,phases,start] GC(10) Phase 2: Prepare for compaction[0.331s][info ][gc,phases   ] GC(10) Phase 2: Prepare for compaction 3.941ms[0.331s][info ][gc,phases,start] GC(10) Phase 3: Adjust pointers[0.335s][info ][gc,phases   ] GC(10) Phase 3: Adjust pointers 4.810ms[0.335s][info ][gc,phases,start] GC(10) Phase 4: Compact heap[0.338s][info ][gc,phases   ] GC(10) Phase 4: Compact heap 2.592ms[0.338s][info ][gc,heap    ] GC(10) Eden regions: 0-&gt;0(10)[0.338s][info ][gc,heap    ] GC(10) Survivor regions: 0-&gt;0(0)[0.338s][info ][gc,heap    ] GC(10) Old regions: 20-&gt;20[0.338s][info ][gc,heap    ] GC(10) Archive regions: 0-&gt;0[0.338s][info ][gc,heap    ] GC(10) Humongous regions: 0-&gt;0[0.338s][info ][gc,metaspace  ] GC(10) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.338s][info ][gc       ] GC(10) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 28.726ms[0.339s][info ][gc,cpu     ] GC(10) User&#x3D;0.06s Sys&#x3D;0.00s Real&#x3D;0.03s[0.339s][info ][gc,marking   ] GC(9) Concurrent Mark Abort[0.339s][info ][gc       ] GC(9) Concurrent Cycle 59.644ms[0.339s][info ][gc,start    ] GC(11) Pause Young (Normal) (G1 Evacuation Pause)[0.339s][info ][gc,task    ] GC(11) Using 2 workers of 4 for evacuation[0.339s][info ][gc,phases   ] GC(11)  Pre Evacuate Collection Set: 0.0ms[0.339s][info ][gc,phases   ] GC(11)  Merge Heap Roots: 0.0ms[0.339s][info ][gc,phases   ] GC(11)  Evacuate Collection Set: 0.0ms[0.339s][info ][gc,phases   ] GC(11)  Post Evacuate Collection Set: 0.1ms[0.339s][info ][gc,phases   ] GC(11)  Other: 0.1ms[0.339s][info ][gc,heap    ] GC(11) Eden regions: 0-&gt;0(10)[0.339s][info ][gc,heap    ] GC(11) Survivor regions: 0-&gt;0(0)[0.339s][info ][gc,heap    ] GC(11) Old regions: 20-&gt;20[0.339s][info ][gc,heap    ] GC(11) Archive regions: 0-&gt;0[0.339s][info ][gc,heap    ] GC(11) Humongous regions: 0-&gt;0[0.339s][info ][gc,metaspace  ] GC(11) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.339s][info ][gc       ] GC(11) Pause Young (Normal) (G1 Evacuation Pause) 19M-&gt;19M(20M) 0.268ms[0.339s][info ][gc,cpu     ] GC(11) User&#x3D;0.00s Sys&#x3D;0.00s Real&#x3D;0.00s[0.339s][info ][gc,task    ] GC(12) Using 2 workers of 4 for full compaction[0.339s][info ][gc,start    ] GC(12) Pause Full (G1 Evacuation Pause)[0.339s][info ][gc,phases,start] GC(12) Phase 1: Mark live objects[0.356s][info ][gc,phases   ] GC(12) Phase 1: Mark live objects 16.720ms[0.356s][info ][gc,phases,start] GC(12) Phase 2: Prepare for compaction[0.367s][info ][gc,phases   ] GC(12) Phase 2: Prepare for compaction 10.800ms[0.367s][info ][gc,phases,start] GC(12) Phase 3: Adjust pointers[0.372s][info ][gc,phases   ] GC(12) Phase 3: Adjust pointers 5.027ms[0.372s][info ][gc,phases,start] GC(12) Phase 4: Compact heap[0.376s][info ][gc,phases   ] GC(12) Phase 4: Compact heap 4.215ms[0.376s][info ][gc,heap    ] GC(12) Eden regions: 0-&gt;0(10)[0.376s][info ][gc,heap    ] GC(12) Survivor regions: 0-&gt;0(0)[0.376s][info ][gc,heap    ] GC(12) Old regions: 20-&gt;20[0.376s][info ][gc,heap    ] GC(12) Archive regions: 0-&gt;0[0.376s][info ][gc,heap    ] GC(12) Humongous regions: 0-&gt;0[0.376s][info ][gc,metaspace  ] GC(12) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.376s][info ][gc       ] GC(12) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 37.163ms[0.377s][info ][gc,cpu     ] GC(12) User&#x3D;0.09s Sys&#x3D;0.00s Real&#x3D;0.04s[0.377s][info ][gc,task    ] GC(13) Using 2 workers of 4 for full compaction[0.377s][info ][gc,start    ] GC(13) Pause Full (G1 Evacuation Pause)[0.377s][info ][gc,phases,start] GC(13) Phase 1: Mark live objects[0.394s][info ][gc,phases   ] GC(13) Phase 1: Mark live objects 16.754ms[0.394s][info ][gc,phases,start] GC(13) Phase 2: Prepare for compaction[0.397s][info ][gc,phases   ] GC(13) Phase 2: Prepare for compaction 3.615ms[0.397s][info ][gc,phases,start] GC(13) Phase 3: Adjust pointers[0.402s][info ][gc,phases   ] GC(13) Phase 3: Adjust pointers 4.787ms[0.402s][info ][gc,phases,start] GC(13) Phase 4: Compact heap[0.405s][info ][gc,phases   ] GC(13) Phase 4: Compact heap 2.556ms[0.405s][info ][gc,heap    ] GC(13) Eden regions: 0-&gt;0(10)[0.405s][info ][gc,heap    ] GC(13) Survivor regions: 0-&gt;0(0)[0.405s][info ][gc,heap    ] GC(13) Old regions: 20-&gt;20[0.405s][info ][gc,heap    ] GC(13) Archive regions: 0-&gt;0[0.405s][info ][gc,heap    ] GC(13) Humongous regions: 0-&gt;0[0.405s][info ][gc,metaspace  ] GC(13) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.405s][info ][gc       ] GC(13) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 28.025ms[0.405s][info ][gc,cpu     ] GC(13) User&#x3D;0.06s Sys&#x3D;0.00s Real&#x3D;0.03s[0.405s][info ][gc,start    ] GC(14) Pause Young (Concurrent Start) (G1 Evacuation Pause)[0.406s][info ][gc,task    ] GC(14) Using 2 workers of 4 for evacuation[0.406s][info ][gc,phases   ] GC(14)  Pre Evacuate Collection Set: 0.0ms[0.406s][info ][gc,phases   ] GC(14)  Merge Heap Roots: 0.0ms[0.406s][info ][gc,phases   ] GC(14)  Evacuate Collection Set: 0.1ms[0.406s][info ][gc,phases   ] GC(14)  Post Evacuate Collection Set: 0.1ms[0.406s][info ][gc,phases   ] GC(14)  Other: 0.1ms[0.406s][info ][gc,heap    ] GC(14) Eden regions: 0-&gt;0(10)[0.406s][info ][gc,heap    ] GC(14) Survivor regions: 0-&gt;0(0)[0.406s][info ][gc,heap    ] GC(14) Old regions: 20-&gt;20[0.406s][info ][gc,heap    ] GC(14) Archive regions: 0-&gt;0[0.406s][info ][gc,heap    ] GC(14) Humongous regions: 0-&gt;0[0.406s][info ][gc,metaspace  ] GC(14) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.406s][info ][gc       ] GC(14) Pause Young (Concurrent Start) (G1 Evacuation Pause) 19M-&gt;19M(20M) 0.332ms[0.406s][info ][gc,cpu     ] GC(14) User&#x3D;0.00s Sys&#x3D;0.00s Real&#x3D;0.00s[0.406s][info ][gc,task    ] GC(15) Using 2 workers of 4 for full compaction[0.406s][info ][gc       ] GC(16) Concurrent Cycle[0.406s][info ][gc,marking   ] GC(16) Concurrent Clear Claimed Marks[0.406s][info ][gc,marking   ] GC(16) Concurrent Clear Claimed Marks 0.006ms[0.406s][info ][gc,marking   ] GC(16) Concurrent Scan Root Regions[0.406s][info ][gc,marking   ] GC(16) Concurrent Scan Root Regions 0.005ms[0.406s][info ][gc,marking   ] GC(16) Concurrent Mark (0.406s)[0.406s][info ][gc,marking   ] GC(16) Concurrent Mark From Roots[0.406s][info ][gc,task    ] GC(16) Using 1 workers of 1 for marking[0.406s][info ][gc,start    ] GC(15) Pause Full (G1 Evacuation Pause)[0.406s][info ][gc,phases,start] GC(15) Phase 1: Mark live objects[0.423s][info ][gc,phases   ] GC(15) Phase 1: Mark live objects 16.596ms[0.423s][info ][gc,phases,start] GC(15) Phase 2: Prepare for compaction[0.427s][info ][gc,phases   ] GC(15) Phase 2: Prepare for compaction 4.129ms[0.427s][info ][gc,phases,start] GC(15) Phase 3: Adjust pointers[0.432s][info ][gc,phases   ] GC(15) Phase 3: Adjust pointers 5.072ms[0.432s][info ][gc,phases,start] GC(15) Phase 4: Compact heap[0.436s][info ][gc,phases   ] GC(15) Phase 4: Compact heap 3.706ms[0.436s][info ][gc,heap    ] GC(15) Eden regions: 0-&gt;0(10)[0.436s][info ][gc,heap    ] GC(15) Survivor regions: 0-&gt;0(0)[0.436s][info ][gc,heap    ] GC(15) Old regions: 20-&gt;20[0.436s][info ][gc,heap    ] GC(15) Archive regions: 0-&gt;0[0.436s][info ][gc,heap    ] GC(15) Humongous regions: 0-&gt;0[0.436s][info ][gc,metaspace  ] GC(15) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.436s][info ][gc       ] GC(15) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 29.957ms[0.437s][info ][gc,cpu     ] GC(15) User&#x3D;0.05s Sys&#x3D;0.00s Real&#x3D;0.03s[0.437s][info ][gc,task    ] GC(17) Using 2 workers of 4 for full compaction[0.437s][info ][gc,start    ] GC(17) Pause Full (G1 Evacuation Pause)[0.437s][info ][gc,phases,start] GC(17) Phase 1: Mark live objects[0.456s][info ][gc,phases   ] GC(17) Phase 1: Mark live objects 19.597ms[0.456s][info ][gc,phases,start] GC(17) Phase 2: Prepare for compaction[0.462s][info ][gc,phases   ] GC(17) Phase 2: Prepare for compaction 5.797ms[0.462s][info ][gc,phases,start] GC(17) Phase 3: Adjust pointers[0.467s][info ][gc,phases   ] GC(17) Phase 3: Adjust pointers 4.970ms[0.467s][info ][gc,phases,start] GC(17) Phase 4: Compact heap[0.470s][info ][gc,phases   ] GC(17) Phase 4: Compact heap 3.354ms[0.471s][info ][gc,heap    ] GC(17) Eden regions: 0-&gt;0(10)[0.471s][info ][gc,heap    ] GC(17) Survivor regions: 0-&gt;0(0)[0.471s][info ][gc,heap    ] GC(17) Old regions: 20-&gt;20[0.471s][info ][gc,heap    ] GC(17) Archive regions: 0-&gt;0[0.471s][info ][gc,heap    ] GC(17) Humongous regions: 0-&gt;0[0.471s][info ][gc,metaspace  ] GC(17) Metaspace: 898K(4864K)-&gt;898K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.471s][info ][gc       ] GC(17) Pause Full (G1 Evacuation Pause) 19M-&gt;19M(20M) 34.180ms[0.471s][info ][gc,cpu     ] GC(17) User&#x3D;0.06s Sys&#x3D;0.00s Real&#x3D;0.03s[0.471s][info ][gc,marking   ] GC(16) Concurrent Mark From Roots 65.292ms[0.471s][info ][gc,marking   ] GC(16) Concurrent Mark Abort[0.471s][info ][gc       ] GC(16) Concurrent Cycle 65.353ms[0.471s][info ][gc,start    ] GC(18) Pause Young (Normal) (G1 Evacuation Pause)[0.471s][info ][gc,task    ] GC(18) Using 2 workers of 4 for evacuation[0.471s][info ][gc,phases   ] GC(18)  Pre Evacuate Collection Set: 0.0ms[0.471s][info ][gc,phases   ] GC(18)  Merge Heap Roots: 0.0ms[0.471s][info ][gc,phases   ] GC(18)  Evacuate Collection Set: 0.0ms[0.471s][info ][gc,phases   ] GC(18)  Post Evacuate Collection Set: 0.1ms[0.471s][info ][gc,phases   ] GC(18)  Other: 0.1ms[0.471s][info ][gc,heap    ] GC(18) Eden regions: 0-&gt;0(10)[0.472s][info ][gc,heap    ] GC(18) Survivor regions: 0-&gt;0(0)[0.472s][info ][gc,heap    ] GC(18) Old regions: 20-&gt;20[0.472s][info ][gc,heap    ] GC(18) Archive regions: 0-&gt;0[0.472s][info ][gc,heap    ] GC(18) Humongous regions: 0-&gt;0[0.472s][info ][gc,metaspace  ] GC(18) Metaspace: 899K(4864K)-&gt;899K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.472s][info ][gc       ] GC(18) Pause Young (Normal) (G1 Evacuation Pause) 19M-&gt;19M(20M) 0.265ms[0.472s][info ][gc,cpu     ] GC(18) User&#x3D;0.00s Sys&#x3D;0.00s Real&#x3D;0.00s[0.472s][info ][gc,task    ] GC(19) Using 2 workers of 4 for full compaction[0.472s][info ][gc,start    ] GC(19) Pause Full (G1 Evacuation Pause)[0.472s][info ][gc,phases,start] GC(19) Phase 1: Mark live objects[0.472s][info ][gc,phases   ] GC(19) Phase 1: Mark live objects 0.749ms[0.472s][info ][gc,phases,start] GC(19) Phase 2: Prepare for compaction[0.473s][info ][gc,phases   ] GC(19) Phase 2: Prepare for compaction 0.233ms[0.473s][info ][gc,phases,start] GC(19) Phase 3: Adjust pointers[0.473s][info ][gc,phases   ] GC(19) Phase 3: Adjust pointers 0.566ms[0.473s][info ][gc,phases,start] GC(19) Phase 4: Compact heap[0.473s][info ][gc,phases   ] GC(19) Phase 4: Compact heap 0.244ms[0.474s][info ][gc,heap    ] GC(19) Eden regions: 0-&gt;0(10)[0.474s][info ][gc,heap    ] GC(19) Survivor regions: 0-&gt;0(0)[0.474s][info ][gc,heap    ] GC(19) Old regions: 20-&gt;2[0.474s][info ][gc,heap    ] GC(19) Archive regions: 0-&gt;0[0.474s][info ][gc,heap    ] GC(19) Humongous regions: 0-&gt;0[0.474s][info ][gc,metaspace  ] GC(19) Metaspace: 899K(4864K)-&gt;899K(4864K) NonClass: 811K(4352K)-&gt;811K(4352K) Class: 87K(512K)-&gt;87K(512K)[0.474s][info ][gc       ] GC(19) Pause Full (G1 Evacuation Pause) 19M-&gt;0M(20M) 2.030ms[0.474s][info ][gc,cpu     ] GC(19) User&#x3D;0.00s Sys&#x3D;0.00s Real&#x3D;0.00s[0.475s][info ][gc,heap,exit  ] Heap[0.475s][info ][gc,heap,exit  ] garbage-first heap  total 20480K, used 938K [0x00000000fec00000, 0x0000000100000000)[0.475s][info ][gc,heap,exit  ]  region size 1024K, 1 young (1024K), 0 survivors (0K)[0.475s][info ][gc,heap,exit  ] Metaspace    used 935K, capacity 4537K, committed 4864K, reserved 1056768K[0.475s][info ][gc,heap,exit  ]  class space  used 92K, capacity 404K, committed 512K, reserved 1048576KException in thread “main” java.lang.OutOfMemoryError: Java heap spaceat eternal.fire.Main.main(Main.java:10)Process finished with exit code 1\n\n\n\n关键提示\n\njava.lang.OutOfMemoryError: Java heap space\n\n\nDebug\n\n先看内存中的对象是否有必要存在\n\n有必要存在就不是内存泄漏\n\n调参：看看物理内存能不能加\n看看对象的生命周期是不是太长\n\n\n没必要存在就是内存泄漏\n\n是不是垃圾收集器出了问题\n\n\n\n\n\n\n\n虚拟机栈和本地方法栈溢出\nStackOverFlowError\npackage eternal.fire;public class JVMStackOverFlow &#123;    private int stackLength;public void stackLeak() &#123;    stackLength++;    stackLeak();;&#125;public static void main(String[] args) &#123;    JVMStackOverFlow jvmStackOverFlow = new JVMStackOverFlow();    try &#123;        jvmStackOverFlow.stackLeak();    &#125; catch (StackOverflowError e) &#123;        System.out.println(&quot;stack length:&quot; + jvmStackOverFlow.stackLength);        throw e;    &#125;&#125;&#125;\n\n输出：stack length:19056Exception in thread &quot;main&quot; java.lang.StackOverflowError\n\n单线程内存不够分只会触发Stack OverflowError\n\n\nOutOfMemoryError\npackage eternal.fire;public class JVMOutOfMemory &#123;    private void dontStop() &#123;        while (true) &#123;​    &#125;&#125;public void stackLeakByThread() &#123;    while (true) &#123;        Thread thread = new Thread(this::dontStop);        thread.start();    &#125;&#125;public static void main(String[] args) &#123;    JVMOutOfMemory jvmOutOfMemory = new JVMOutOfMemory();    jvmOutOfMemory.stackLeakByThread();&#125;&#125;\n\n\n\n\n多线程可能触发OutOfMemoryError\n比如windows 32位，每个进程的最大内存是2GB，除去java堆、方法区之类的空间，剩下的由虚拟机栈和本地方法栈瓜分，给每个线程分的栈越大，能建立线程的数量就越小，建立线程需要耗费内存，所以更容易OutOfMemoryError\n\n可以说是创建线程导致的\n一般人肯定想不到，我分给她的内存越多，她反倒越容易OutOfMemory。OutOfMemory之后可以先考虑减少线程数，如果线程数不能减少，那就换64位机器，如果换不了，那就减少Java堆和方法区的内存。啥？内存不够我还要减少java堆的内存？这一般人肯定想不到啊。\n\n说明\n按理说我的这个测试应该会OutOfMemory的，但是跑了半天却跑不出个bug来，只是我的电脑变得很卡，变得很卡是有道理的，但为啥跑不出bug呀，我猜可能是idea或者是java8以后对这个有所优化，ByTheWay，我的输入法突然崩了，但能打字，不只是搜狗输入法，我的日语输入法也出了毛病，kind of weird. 刚切到桌面，我的桌面图标的名字也变成马赛克了？？？神奇。我的整个系统都出了毛病。希望重启能解决问题\n\n\n\n\n运行时常量池溢出package eternal.fire;import java.util.ArrayList;import java.util.List;public class RuntimeConstantPoolOutOfMemory &#123;    //-XX:PermSize=10M    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        int i = 0;        while (true) &#123;            list.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;\n\n\n\n\n无限intern就是很好的方法\n\n为了防止GC回收，可以用一个List去持续持有这些String的引用\n\n运行结果\n理论结果应该是：OutOfMemoryError：PermGen space，意思是方法区空间不够了，从中也可以看出运行时常量池是方法区的一部分\n\n我不敢继续运行了，我害怕对我的机器造成一些损害。\n按理说方法区应该大小有限制的啊，怎么内存一直暴涨啊\n\n\n\n方法区溢出\n方法区存放类的信息\n\n类名\n访问修饰符\n常量池\n字段描述\n方法描述\n\n\n造bug方法：产生大量的类，但是比较麻烦，所以就不做了。\n\n\n直接内存 溢出package eternal.fire;import sun.misc.Unsafe;import java.lang.reflect.Field;public class DirectMemoryOOM &#123;    private static final int _1MB = 1024 * 1024;    public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException &#123;//        -Xmx20M -XX:MaxDirectMemorySize=10M        Field unsafeField = Unsafe.class.getDeclaredField()[0];        unsafeField.setAccessible(true);        Unsafe unsafe = (Unsafe) unsafeField.get(null);        while (true) &#123;            unsafe.allocateMemory(_1MB);        &#125;    &#125;&#125;\n\n\n\n\n\n说明\n\n这代码可能太老了，我编译都通过不了\n\n\n\n","categories":["JVM"]},{"title":"Java并发","url":"/2020/12/15/Java%E5%B9%B6%E5%8F%91/","content":"\n\n\n\n\n线程使用方法\n实现Runnable接口\n\n实现Callable接口\n\n可以用Future获得返回值\n\n\n继承Thread类\n\n\nJava提供的机制\n线程池\n\nFuture submit\nvoid execute\n\n\nDaemon(守护线程)\n\nJVM在所有非守护线程结束时退出\n栗子：负责GC的线程\n\n\nsleep\n\n休眠当前正在执行的线程\n异常不能跨线程传播，所以必须在本地处理异常\n\n\nyield\n\n告知线程调度者可以切换到其他线程了，但线程调度者未必听从\n\n\nsetPriority\n\n优先级高的线程被操作系统调度的优先级较高，但不能确保优先级高的线程一定先被执行\n\n\n\n状态特指 Java 虚拟机的线程状态\n\nnew\n\n创建后尚未启动\n\n\nRunnable\n\n在JVM层面可运行，具体有没有运行要看底层操作系统的资源调度\n\n\nblocked\n\n因为请求锁而不能得陷入阻塞\n\n\nwaiting\n\nblocked是被动的，waiting是主动的\n\n进入\n\nwait（无时间参数）\njoin（无时间参数）\npark\n\n\n退出\n\nnotify&#x2F;notifyAll\n目标线程执行完毕\nunpark\n\n\n\n\ntimed_waiting\n\n在一定时间后被唤醒\n\n进入\n\nwait（有时间参数）\njoin（有时间参数）\nparkNanos&#x2F;parkUtil\n\n\n\n\nterminated\n\n线程任务执行完毕或异常\n\n\n\n中断线程\ninterrupt\n\n可以立即停止一个正在阻塞、等待的线程\n\n\nInterruptedException\n\n如果线程正处于阻塞、等待的状态，interrupt会使线程发生interruptedException\n\n\ninterrupted\n\ninterrupt会标记目标线程，使线程的interrupted返回true\n\n\n\n线程池\nshutdown\n\n所有线程执行完后关闭\n\n\nshutdownNow\n\n对每个线程调用interrupt方法\n\n\n\n互斥同步方法\nsynchronized\n\n同步代码块\n同步方法\n同步一个类\n同步一个静态方法\n\n\nReentrantLock\n\nlock\nunlock\ntryLock(long timeout,TimeUnit unit)\n\n\n\n比较\n实现者\n\nsynchronized由jvm实现\nReentrantLock由jdk实现\n\n\n性能\n\n新版本性能相似\n\n\n等待锁的线程是否可中断\n\nsynchronized：否\nReentrantLock：是\n\n\n公平锁\n\nsynchronized：只能非公平锁\nReentrantLock：默认非公平锁\n\n\n死锁\n\n使用synchronized，jvm确保不会死锁\n\n\n\n选择\n优先synchronized\n\n多线程协作join\n将当前线程挂起直到目标线程结束\n\nsynchronized\nwait\n\n将当前线程挂起等待notify或notifyAll\n\nwait VS sleep\n\nwait会释放锁，而sleep不会\n\n\n\n\nnotify\n\n唤醒一个因为请求锁而阻塞的线程\n\n\nnotifyAll\n\n\nReentrantLock\nawait\n\n将当前线程挂起等待signal或signalAll\n\n\nsignal\n\nsignalAll\n\n\nJava内存模型作用\n屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果\n\n内存\n分类\n\n主内存\n工作内存\n\n\n\n内存间交互\n\n\n特点\n原子性\n\n内存间的交互操作具有原子性\n使用原子类（AtomicInteger）确保操作的原子性\n使用synchronized确保操作的原子性\n\n\n可见性\n\nvolatile\nsynchronized\nfinal\n\n\n重排\n\n编译器和处理器的指令重排可能会影响并发的正确性\nvolatile\nsynchronized\n\n\n\n先行发生原则\nsingle thread rule\n\n单线程内严格串行\n\n\nmonitor lock rule\n\nunlock先于lock\n\n\nvolatile variable rule\n\n对volatile变量的写操作先于读操作\n\n\n\n线程安全不可变\nfinal\nString\n枚举类型\nCollections.unmodifiableXXX()\n\n互斥（阻塞）同步\nsynchronized\nReentrantLock\n\n非阻塞同步\n乐观锁\n\nStampedLock\n\ntryOptimisticRead\nvalidate\n\n\n\n\n\n无同步\n栈封闭\n\n并发访问方法局部变量不会有线程安全问题\n\n\n线程本地存储\n\n可重入代码（pure code）\n\n\n","categories":["Java"]},{"title":"LCS","url":"/2021/04/19/LCS/","content":"最长公共子序列（LCS）是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。这与查找最长公共子串的问题不同的地方是：子序列不需要在原序列中占用连续的位置 。最长公共子序列问题是一个经典的计算机科学问题，也是数据比较程序，比如Diff工具，和生物信息学应用的基础。它也被广泛地应用在版本控制，比如Git用来调和文件之间的改变。\n\n\n最长公共子序列问题存在最优子结构：这个问题可以分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。最长公共子序列问题的子问题的解是可以重复使用的，也就是说，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以被储存起来，而不用重复计算。这个过程需要在一个表中储存同一级别的子问题的解，因此这个解可以被更高级的子问题使用。\nLCS问题的子问题是什么？子问题和原问题有什么联系呢？\n子问题：dp[i-1][j-1] dp[i][j-1] dp[i-1][j]\n如果s1[i]==s2[j]，则dp[i][j]和dp[i-1][j-1]必然有直接的联系\n否则，与 dp[i][j-1] dp[i-1][j]两个子问题有直接联系。\npackage mainimport (\t&quot;fmt&quot;)func main() &#123;\tfmt.Println(longestCommonSubsequence(&quot;xzyzzyx&quot;, &quot;zxyyzxz&quot;))\tfmt.Println(longestCommonSubsequence(&quot;MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD&quot;, &quot;MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG&quot;))&#125;func longestCommonSubsequence(text1 string, text2 string) int &#123;\t// dp[i][j] 表示 text1长度为i的前缀 和 text2长度为j的前缀 的 LCS\tdp := make([][]int, len(text1)+1)\tfor i := range dp &#123;\t\tdp[i] = make([]int, len(text2)+1)\t&#125;\tdp[1][1] = same(text1[0], text2[0])\tfor i := 1; i &lt; len(dp); i++ &#123;\t\tfor j := 1; j &lt; len(dp[0]); j++ &#123;\t\t\tdp[i][j] = max3(dp[i-1][j-1]+same(text1[i-1], text2[j-1]), dp[i-1][j], dp[i][j-1])\t\t&#125;\t&#125;\treturn dp[len(dp)-1][len(dp[0])-1]&#125;// 两个字符相同时返回1，否则返回0func same(a, b uint8) int &#123;\tif a == b &#123;\t\treturn 1\t&#125;\treturn 0&#125;func max3(a, b, c int) int &#123;\treturn max(max(a, b), c)&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n","categories":["数据结构与算法"]},{"title":"LRU","url":"/2021/04/25/LRU/","content":"缓存文件置换机制是电脑处理缓存存储器的一种机制。\n电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存文件置换机制。\n缓存文件置换方法有：\n\n先进先出算法（FIFO）：最先进入的内容作为替换对象\n最近最少使用算法（LFU）：最近最少使用的内容作为替换对象\n最久未使用算法（LRU）：最久没有访问的内容作为替换对象\n非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象\n\n\n\n用GO实现简单的LRU：\n大致思路是，用一个双向链表，链表头部存储最近使用过的缓存，尾部存储最近最久未使用过的缓存。\n插入的时候，如果缓存未满，直接插到链表头部即可，否则将尾部的缓存移除，再插入。\n因为涉及到插入删除操作，加入头结点（dummy node）可以更方便。\n双向链表速度还不够快，再引入一个map来存储链表所有的节点。\npackage mainimport &quot;fmt&quot;type LRUCache struct &#123;\tlimit   int\thashMap map[int]*Node\thead    *Node\ttail    *Node&#125;type Node struct &#123;\tkey  int\tval  int\tpre  *Node\tnext *Node&#125;func NewNode(k, v int) *Node &#123;\treturn &amp;Node&#123;\t\tkey: k,\t\tval: v,\t&#125;&#125;func NewLRUCache(cap int) LRUCache &#123;\tc := LRUCache&#123;\t\tlimit:   cap,\t\thashMap: make(map[int]*Node),\t\thead:    NewNode(0, 0), // dummy node\t\ttail:    NewNode(0, 0), // dummy node\t&#125;\tc.head.next = c.tail\tc.tail.pre = c.head\treturn c&#125;func (c *LRUCache) Get(key int) int &#123;\tif node, ok := c.hashMap[key]; ok &#123;\t\tc.moveToHead(node)\t\treturn node.val\t&#125;\t// if not found, return -1\treturn -1&#125;func (c *LRUCache) Put(k, v int) &#123;\tif node, ok := c.hashMap[k]; !ok &#123;\t\tif len(c.hashMap) &gt;= c.limit &#123;\t\t\ttail := c.removeTail()\t\t\tdelete(c.hashMap, tail.key)\t\t&#125;\t\tnode = NewNode(k, v)\t\tc.hashMap[k] = node\t\tc.addToHead(node)\t&#125; else &#123;\t\tnode.val = v\t\tc.moveToHead(node)\t&#125;&#125;func (c *LRUCache) moveToHead(node *Node) &#123;\tc.removeNode(node)\tc.addToHead(node)&#125;func (c *LRUCache) removeNode(node *Node) &#123;\tnode.pre.next = node.next\tnode.next.pre = node.pre&#125;func (c *LRUCache) removeTail() *Node &#123;\ttail := c.tail.pre\tc.removeNode(tail)\treturn tail&#125;func (c *LRUCache) addToHead(node *Node) &#123;\tnode.pre = c.head\tnode.next = c.head.next\tc.head.next.pre = node\tc.head.next = node&#125;func main() &#123;\tcache := NewLRUCache(3)\tcache.Put(1,1)\tcache.Put(2,2)\tcache.Put(3,3)\tcache.Put(4,4)\tfmt.Println(cache.Get(3))&#125;\n\n"},{"title":"Last Month","url":"/2020/07/17/Last-Month/","content":"回忆下个月的今天就开学了，我已经待在家半年之久。\n今年发生了很多事情，这些事情一定程度上让我做出了很大的改变。\n如果没有这些事情，此时的我又在干什么呢？\n\n\n现状这几天又遇到了很大的瓶颈，spring很复杂，vue半途而废，我没有足够的信心和毅力去克服这些困难，也不愿意去探索新的技术，这些天总是在回避这些问题。\n我花很多时间在斗鱼、b站、守望先锋上，还看了好几部精彩的电影。\n可是，这些很放松的事情，并没有给我留下太多印象。好像，如云烟，轻轻地散了。只有我敲过的代码、部署的程序、写过的博客留在那里，成为历史短暂的一部分。\n这些活动在我很忙碌的时候，能给我带来很大的愉悦。但倘若我总是沉浸其中，这些事就变得平淡无奇了。\n聪明的，你告诉我，这是为什么呢？\n大概是因为，我对自己的要求有些松懈了，劳和逸的天平朝一边倾斜，如果一个事物的对立面消失了，那这个事物也就消失了。\n心愿\n通过最后一段时间的复习，开学后的期末考试取得理想的分数，拿到奖学金。\n通过对技术的不断探索，明年春招找到很棒的实习，收获人生用专业知识获得的第一桶金。\n通过精心的准备，明年秋招拿到很多月入过万的大厂offer，择优而从之。\n通过合理的饮食和运动，使我的体重到达一个令人满意的程度。\n\n机会留给我的时间刚刚好，足够我有条不紊的做些什么，要是再晚一点儿，可能真就来不及了。\n现在我身体健康，精力充沛，没有很多顾虑，可以随时进入状态。\n以前的关键时期，我都做的不错。如今又是一个关键时期，我有一些资本去抓住这次机会。\n如果这些心愿一个挨着一个落空，我会陷入极度焦虑的境地，我不想变成那样。\n改变想要什么就想法设法去追求啊。\n\n调整作息\n上下求索\n健康饮食\n合理运动\n\n我看到自己的愿望一个个的出现在我面前\n","categories":["Essay"]},{"title":"LeetCode-1024","url":"/2020/10/24/LeetCode-1024/","content":"题目\n\n\n\n\n\n结果\n\n代码class Solution &#123;    public int videoStitching(int[][] clips, int T) &#123;        // 初始化数组range，range[i]值为0~i都可达的情况下最远的距离，-1说明不可达        int[] range = new int[T + 1];        Arrays.fill(range, -1);        for (int[] clip : clips) &#123;            if (clip[0] == 0) &#123;                range[0] = Math.max(range[0], clip[1]);            &#125;        &#125;        if (range[0] == -1) &#123;            return -1;        &#125;        // 所需片段数，初始化为1        int count = 1;        for (int i = 1; i &lt; range.length; i++) &#123;            if (range[i - 1] &gt;= i) &#123; // 不用额外的片段                range[i] = range[i - 1];            &#125; else &#123; // 需要额外的片段                for (int[] clip : clips) &#123;                    if (i &gt; clip[0] &amp;&amp; i &lt;= clip[1]) &#123; // 包含i的最大范围                        range[i] = Math.max(range[i], clip[1]);                    &#125;                &#125;                if (range[i] != -1) &#123;                    count++;                &#125; else &#123; // 如果片段i不可达                    return -1;                &#125;            &#125;        &#125;        return range[T] == -1 ? -1 : count;    &#125;&#125;\n\n有点dp，但好像又不是dp。\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-1002","url":"/2020/10/14/LeetCode-1002/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public List&lt;String&gt; commonChars(String[] A) &#123;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        List&lt;String&gt; ans = new LinkedList&lt;&gt;();        String str = A[0];        for (char ch : str.toCharArray()) &#123;            if (bothHave(A, ch)) &#123;                map.put(ch, 1);            &#125;        &#125;        for (char key : map.keySet()) &#123;            map.put(key, minTime(key, A));            for (int i = 0; i &lt; map.get(key); i++) &#123;                ans.add(&quot;&quot; + key);            &#125;        &#125;        return ans;    &#125;    private boolean bothHave(String[] strings, char ch) &#123;        for (String str : strings) &#123;            if (!str.contains(&quot;&quot; + ch)) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int minTime(char key, String[] strings) &#123;        int ans = Integer.MAX_VALUE;        for (String s : strings) &#123;            int time = 0;            for (char ch : s.toCharArray()) &#123;                if (ch == key) &#123;                    time++;                &#125;            &#125;            ans = Math.min(ans, time);        &#125;        return ans;    &#125;&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-1025","url":"/2020/07/24/LeetCode-1025/","content":"LeetCode-1025  除数博弈题目\n\n\n\n结果DP的结果\n\n\n代码公式法class Solution &#123;    public boolean divisorGame(int N) &#123;        return N % 2 == 0;    &#125;&#125;\n\nDP\nclass Solution &#123;    public boolean divisorGame(int N) &#123;        // Alice先手情况下的获胜方，true代表Alice，false代表Bob        Boolean[] dp = N &gt;= 4 ? new Boolean[N + 1] : new Boolean[4];        for (int i = 1; i &lt;= N; i++) &#123;            dp[i] = choose(dp, i);        &#125;        return dp[N];    &#125;    public boolean choose(Boolean[] dp, int index) &#123;        // 如果选择之后存在一种情况Alice必败，那么Alice必胜        for (int i = 1; i &lt; index; i++) &#123;            if (index % i == 0 &amp;&amp; !dp[index - i]) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n\n复杂度公式法\n时间复杂度O（1）\n空间复杂度O（1）\n\nDP\n时间复杂度：O（n²）\n\n空间复杂度：O（n）\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-103","url":"/2020/11/22/LeetCode-103/","content":"题目\n\n\n结果\n代码终稿class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        if (root == null) &#123;            return new LinkedList&lt;&gt;();        &#125;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        List&lt;TreeNode&gt; treeNodes = new ArrayList&lt;&gt;();        treeNodes.add(root);        boolean direction = false;        while (!treeNodes.isEmpty()) &#123;            List&lt;Integer&gt; integers = new LinkedList&lt;&gt;();            // Left to right            if (!direction) &#123;                for (TreeNode node : treeNodes) &#123;                    integers.add(node.val);                &#125;            &#125; else &#123; // Right to left                for (int i = treeNodes.size() - 1; i &gt;= 0; i--) &#123;                    integers.add(treeNodes.get(i).val);                &#125;            &#125;            ans.add(integers);            // Next level            List&lt;TreeNode&gt; tmp = new LinkedList&lt;&gt;(treeNodes);            treeNodes.clear();            for (TreeNode node : tmp) &#123;                if (node.left != null) &#123;                    treeNodes.add(node.left);                &#125;                if (node.right != null) &#123;                    treeNodes.add(node.right);                &#125;            &#125;            direction = !direction;        &#125;        return ans;    &#125;&#125;\n\n初稿class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        if (root == null) &#123;            return new LinkedList&lt;&gt;();        &#125;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        ans.add(List.of(root.val));        boolean direction = false;        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.add(root);        while (!deque.isEmpty()) &#123;            List&lt;TreeNode&gt; row = new ArrayList&lt;&gt;(deque);            deque.clear();            for (TreeNode node : row) &#123;                if (node.left != null) &#123;                    deque.add(node.left);                &#125;                if (node.right != null) &#123;                    deque.add(node.right);                &#125;            &#125;            List&lt;Integer&gt; currLevel = new LinkedList&lt;&gt;();            // Left to right            if (direction) &#123;                for (TreeNode node : row) &#123;                    if (node.left != null) &#123;                        currLevel.add(node.left.val);                    &#125;                    if (node.right != null) &#123;                        currLevel.add(node.right.val);                    &#125;                &#125;            &#125; else &#123; // Right to left                for (int i = row.size() - 1; i &gt;= 0; i--) &#123;                    TreeNode node = row.get(i);                    if (node.right != null) &#123;                        currLevel.add(node.right.val);                    &#125;                    if (node.left != null) &#123;                        currLevel.add(node.left.val);                    &#125;                &#125;            &#125;            if (!currLevel.isEmpty()) &#123;                ans.add(currLevel);            &#125;            direction = !direction;        &#125;        return ans;    &#125;&#125;\n\n\n\nGolangfunc zigzagLevelOrder(root *TreeNode) (ans [][]int) &#123;\tif root == nil &#123;\t\treturn\t&#125;\tvar queue []*TreeNode\tqueue = append(queue, root)\tvar direction bool\tfor len(queue) != 0 &#123;\t\tvar level []int\t\tvar tmp []*TreeNode\t\tfor _, node := range queue &#123;\t\t\tlevel = append(level, node.Val)\t\t\tif node.Left != nil &#123;\t\t\t\ttmp = append(tmp, node.Left)\t\t\t&#125;\t\t\tif node.Right != nil &#123;\t\t\t\ttmp = append(tmp, node.Right)\t\t\t&#125;\t\t&#125;\t\tif direction &#123;\t\t\tans = append(ans, level)\t\t&#125; else &#123;\t\t\tans = append(ans, rvs(level))\t\t&#125;\t\tqueue = tmp\t\tdirection = !direction\t&#125;\treturn&#125;func rvs(nums []int) (ans []int) &#123;\tfor i := len(nums) - 1; i &gt;= 0; i-- &#123;\t\tans = append(ans, nums[i])\t&#125;\treturn&#125;\n\n\n\n复杂度时间复杂度：O（N）\n空间复杂度：O（N）\n疑惑\n初稿通过之后，感觉代码写的不美观，我稍加调整了一下，算法明明是一样的，但是速度反而慢了1ms，我认为这是误差，但重复试了很多遍之后，就是有这1ms的差距，怪事。\n","categories":["LeetCode"]},{"title":"LeetCode-1030","url":"/2020/11/17/LeetCode-1030/","content":"题目\n\n\n结果\n代码ARRAYS.SORT根据曼哈顿距离直接快排\nclass Solution &#123;    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) &#123;        int[][] ans = new int[R * C][2];        initialize(ans, R, C);        Arrays.sort(ans, Comparator.comparingInt(o -&gt; distance(r0, c0, o[0], o[1])));        return ans;    &#125;    private int distance(int r0, int c0, int r, int c) &#123;        return abs(r0 - r) + abs(c0 - c);    &#125;    private int abs(int x) &#123;        return x &gt;= 0 ? x : -x;    &#125;    private void initialize(int[][] arr, int R, int C) &#123;        for (int i = 0; i &lt; R; i++) &#123;            for (int j = 0; j &lt; C; j++) &#123;                arr[i * C + j][0] = i;                arr[i * C + j][1] = j;            &#125;        &#125;    &#125;&#125;\n\n桶排序对于值域已知的序列，可以使用桶排序加速。这道题可以用曼哈顿距离作为分桶的依据，而且桶内不用再继续排序，一步到位。\nclass Solution &#123;    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) &#123;        // 若干个桶的集合        List&lt;List&lt;int[]&gt;&gt; buckets = new ArrayList&lt;&gt;();        // 桶的个数        int nums = Math.max(r0, R - r0 - 1) + Math.max(c0, C - c0 - 1) + 1;        // 添加nums个桶到集合里        for (int i = 0; i &lt; nums; i++) &#123;            buckets.add(new ArrayList&lt;&gt;());        &#125;        // 根据曼哈顿距离，把每个元素添加到不同的桶里        for (int i = 0; i &lt; R; i++) &#123;            for (int j = 0; j &lt; C; j++) &#123;                buckets.get(distance(r0, c0, i, j)).add(new int[]&#123;i, j&#125;);            &#125;        &#125;        int[][] ans = new int[R * C][2];        int index = 0;        for (var bucket : buckets) &#123;            for (var rc : bucket) &#123;                ans[index] = rc;                index++;            &#125;        &#125;        return ans;    &#125;    private int distance(int r0, int c0, int r, int c) &#123;        return abs(r0 - r) + abs(c0 - c);    &#125;    private int abs(int x) &#123;        return x &gt;= 0 ? x : -x;    &#125;&#125;\n\n复杂度（桶排序的算法）时间复杂度：O（n）\n空间复杂度：O（n），n为元素个数R×C\n","categories":["LeetCode"]},{"title":"LeetCode-104","url":"/2020/07/28/LeetCode-104/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125;        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;    &#125;&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-1047","url":"/2021/03/09/LeetCode-1047/","content":"题目\n\n\n\n结果\n\n代码func removeDuplicates(S string) string &#123;\tstk := make([]rune, 0)\tfor _, v := range S &#123;\t\tif len(stk) != 0 &amp;&amp; stk[len(stk)-1] == v &#123;\t\t\tstk = stk[:len(stk)-1]\t\t&#125; else &#123;\t\t\tstk = append(stk, v)\t\t&#125;\t&#125;\treturn string(stk)&#125;","categories":["LeetCode"]},{"title":"LeetCode-106","url":"/2020/09/25/LeetCode-106/","content":"题目\n\n\n\n结果\n\n代码标准版class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        // 特殊情况        if (inorder.length == 0 || postorder.length == 0) &#123;            return null;        &#125;        int root = postorder[postorder.length - 1];        TreeNode ans = new TreeNode(root);        // 计算根节点在inorder中的位置        int index = 0;        for (int i = 0; i &lt; inorder.length; i++) &#123;            if (inorder[i] == root) &#123;                index = i;                break;            &#125;        &#125;                // 求得左子树的先序遍历和中序遍历结果，递归构造左子树        int[] nextInOrderLeft = Arrays.copyOfRange(inorder, 0, index);        int[] nextPostOrderLeft = Arrays.copyOf(postorder, nextInOrderLeft.length);        ans.left = buildTree(nextInOrderLeft, nextPostOrderLeft);                // 求得右子树的先序遍历结果和中序遍历结果，递归构造右子树        int[] nextInOrderRight = Arrays.copyOfRange(inorder, index + 1, inorder.length);        int[] nextPostOrderRight = Arrays.copyOfRange(postorder, nextInOrderLeft.length, nextInOrderLeft.length + nextInOrderRight.length);        ans.right = buildTree(nextInOrderRight, nextPostOrderRight);        return ans;    &#125;&#125;\n\n优化版可以不new新的数组，传参时只传下标，能有效节省空间。考虑下标好麻烦，算了不想了。\n复杂度时间复杂度：应该挺慢的\n空间复杂度：应该占用了很多空间\n","categories":["LeetCode"]},{"title":"LeetCode-114","url":"/2020/08/02/LeetCode-114/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public void flatten(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        List&lt;Integer&gt; preOrder = new ArrayList&lt;&gt;();        dfs(root, preOrder);        root.left = null;        TreeNode tmp = root;        for (int i = 1; i &lt; preOrder.size(); i++) &#123;            if (tmp.right == null) &#123;                tmp.right = new TreeNode(preOrder.get(i));            &#125; else &#123;                tmp.right.val = preOrder.get(i);                tmp.right.left = null;            &#125;            tmp = tmp.right;        &#125;    &#125;    private void dfs(TreeNode root, List&lt;Integer&gt; ans) &#123;        if (root == null) &#123;            return;        &#125;        ans.add(root.val);        dfs(root.left, ans);        dfs(root.right, ans);    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-113","url":"/2020/09/26/LeetCode-113/","content":"题目\n\n\n\n结果\n\n代码这个应该叫回溯算法？\nclass Solution &#123;    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;        dfs(root, new LinkedList&lt;&gt;(), sum);        return ans;    &#125;    private void dfs(TreeNode root, List&lt;Integer&gt; path, int sum) &#123;        // 停止递归        if (root == null) &#123;            return;        &#125;        // copy一份path备用，这样也许会多耗很多空间，我想jvm或者编译器应该对此有优化吧        List&lt;Integer&gt; branch = new LinkedList&lt;&gt;(path);        branch.add(root.val);        if (isLeaf(root) &amp;&amp; branch.stream().reduce(0, Integer::sum) == sum) &#123;            ans.add(branch);            return;        &#125;                // 递归        dfs(root.left, branch, sum);        dfs(root.right, branch, sum);    &#125;        // 判断是否为叶子结点    private boolean isLeaf(TreeNode node) &#123;        return node.left == null &amp;&amp; node.right == null;    &#125;&#125;\n\n复杂度时间复杂度：&gt;O（n），因为还求和了\n空间复杂度：O（不计其数）\n","categories":["LeetCode"]},{"title":"LeetCode-1143","url":"/2021/04/19/LeetCode-1143/","content":"题目1143. 最长公共子序列\n\n\n\n结果\n\n代码func longestCommonSubsequence(text1 string, text2 string) int &#123;\t// dp[i][j] 表示 text1长度为i的前缀 和 text2长度为j的前缀 的 LCS\tdp := make([][]int, len(text1)+1)\tfor i := range dp &#123;\t\tdp[i] = make([]int, len(text2)+1)\t&#125;\tdp[1][1] = same(text1[0], text2[0])\tfor i := 1; i &lt; len(dp); i++ &#123;\t\tfor j := 1; j &lt; len(dp[0]); j++ &#123;\t\t\tdp[i][j] = max3(dp[i-1][j-1]+same(text1[i-1], text2[j-1]), dp[i-1][j], dp[i][j-1])\t\t&#125;\t&#125;\treturn dp[len(dp)-1][len(dp[0])-1]&#125;func same(a, b uint8) int &#123;\tif a == b &#123;\t\treturn 1\t&#125;\treturn 0&#125;func max3(a, b, c int) int &#123;\treturn max(max(a, b), c)&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n\n\n复杂度时间复杂度：O（m x n）\n空间复杂度：O（m x n）\n","categories":["LeetCode"]},{"title":"LeetCode-117","url":"/2020/09/28/LeetCode-117/","content":"题目\n\n\n\n\n\n结果\n\n代码class Node &#123;    public int val;    public Node left;    public Node right;    public Node next;    public Node() &#123;    &#125;    public Node(int _val) &#123;        val = _val;    &#125;    Node(int _val, Node _left, Node _right, Node _next) &#123;        val = _val;        left = _left;        right = _right;        next = _next;    &#125;&#125;class Solution &#123;    public Node connect(Node root) &#123;        bfs(root);        return root;    &#125;    private void bfs(Node root) &#123;        if (root == null) &#123;            return;        &#125;        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();        queue.add(root);        while (!queue.isEmpty()) &#123;            int size = queue.size();            Node pre = null;            for (int i = 0; i &lt; size; i++) &#123;                Node node = queue.poll();                if (node.left != null) &#123;                    queue.add(node.left);                &#125;                if (node.right != null) &#123;                    queue.add(node.right);                &#125;                if (pre != null) &#123;                    pre.next = node;                &#125;                pre = node;            &#125;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n），n为节点个数\n空间复杂度：O（n），队列\n","categories":["LeetCode"]},{"title":"LeetCode-118","url":"/2020/12/06/LeetCode-118/","content":"题目\n\n\n结果\n代码七个月前的代码class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        if (numRows == 0) &#123;            return ans;        &#125;        ans.add(List.of(1));        if (numRows == 1) &#123;            return ans;        &#125;        ans.add(List.of(1, 1));        for (int i = 2; i &lt; numRows; i++) &#123;            List&lt;Integer&gt; list = new LinkedList&lt;&gt;();            list.add(1);            for (int j = 0; j + 1 &lt; ans.get(i - 1).size(); j++) &#123;                list.add(ans.get(i - 1).get(j) + ans.get(i - 1).get(j + 1));            &#125;            list.add(1);            ans.add(list);        &#125;        return ans;    &#125;&#125;\n\n七个月后的代码class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; numRows; i++) &#123;            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();            for (int j = 0; j &lt;= i; j++) &#123;                if (j == 0 || j == i) &#123;                    row.add(1);                &#125; else &#123;                    row.add(ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));                &#125;            &#125;            ans.add(row);        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-120","url":"/2020/07/14/LeetCode-120/","content":"LeetCode-120  三角形最小路径和题目\n\n\n\n结果\n\n代码算法一：深度优先遍历二叉树（超时了）class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        return goDown(triangle, 0, 0, 0, Integer.MAX_VALUE);    &#125;    private int goDown(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int col, int sum, Integer ans) &#123;        // 如果是叶子节点        if (row == triangle.size() - 1) &#123;            sum += triangle.get(row).get(col);            ans = Math.min(ans, sum);            return ans;        &#125;        int a = goDown(triangle, row + 1, col, sum + triangle.get(row).get(col), ans);        int b = goDown(triangle, row + 1, col + 1, sum + triangle.get(row).get(col), ans);        return Math.min(a, b);    &#125;&#125;\n\n\n\n思路：找出从根节点到叶子节点路径和最小的那一个。\n算法二：动态规划class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        // 初始化        int[][] dp = new int[triangle.size()][triangle.size()];        dp[0][0] = triangle.get(0).get(0);                for (int i = 1; i &lt; triangle.size(); i++) &#123;            // 边界情况            dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0);            int last = triangle.get(i).size() - 1;            dp[i][last] = dp[i - 1][last - 1] + triangle.get(i).get(last);                                    for (int j = 1; j &lt; triangle.get(i).size() - 1; j++) &#123;                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j);            &#125;        &#125;                // 排序后返回最小值        Arrays.sort(dp[triangle.size() - 1]);        return dp[triangle.size() - 1][0];    &#125;&#125;\n\n算法三：优化动态规划class Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;        // 特殊情况        if (triangle.size() == 1) &#123;            return triangle.get(0).get(0);        &#125;        // 初始化        int[][] dp = new int[2][triangle.size()];        dp[0][0] = triangle.get(0).get(0);        for (int i = 1; i &lt; triangle.size(); i++) &#123;            // 边界情况            dp[1][0] = dp[0][0] + triangle.get(i).get(0);            int last = triangle.get(i).size() - 1;            dp[1][last] = dp[0][last - 1] + triangle.get(i).get(last);            for (int j = 1; j &lt; triangle.get(i).size() - 1; j++) &#123;                dp[1][j] = Math.min(dp[0][j], dp[0][j - 1]) + triangle.get(i).get(j);            &#125;            // 重置dp            System.arraycopy(dp[1], 0, dp[0], 0, dp[0].length);        &#125;        // 排序后返回最小值        Arrays.sort(dp[1]);        return dp[1][0];    &#125;&#125;\n\n复杂度算法一：时间复杂度：大于O(n²)\n空间复杂度：O(n)\n算法二：时间复杂度：O(n²)\n空间复杂度：O(n²)\n算法三：时间复杂度：O(n²)\n空间复杂度：O(n)\n","categories":["LeetCode"]},{"title":"LeetCode-1190","url":"/2021/04/17/LeetCode-1190/","content":"题目1190. 反转每对括号间的子串这是星期三HW机试的第一道原题，而机试满分600分，通过只要求100分。\n这个题目借助栈，很容易直接写出来\n\n\n\n\n结果\n\n代码和机试不同的是，牛客上的要去处理输入输出\nfunc reverseParentheses(s string) string &#123;\tvar stack []rune\tfor _, ch := range s &#123;\t\tif ch == &#x27;)&#x27; &#123;\t\t\tvar buf bytes.Buffer\t\t\tfor &#123;\t\t\t\ttop := stack[len(stack)-1]\t\t\t\tstack = stack[:len(stack)-1]\t\t\t\tif top == &#x27;(&#x27; &#123;\t\t\t\t\tstack = append(stack, unzip(buf.String())...)\t\t\t\t\tbreak\t\t\t\t&#125; else &#123;\t\t\t\t\tbuf.WriteRune(top)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; else &#123;\t\t\tstack = append(stack, ch)\t\t&#125;\t&#125;\treturn string(stack)&#125;func unzip(s string) (arr []rune) &#123;\tfor _, v := range s &#123;\t\tarr = append(arr, v)\t&#125;\treturn&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-1239","url":"/2021/06/19/LeetCode-1239/","content":"题目1239. 串联字符串的最大长度\n\n代码思路：回溯\n因为最终结果由子序列字符串连接而成，考虑到顺序和每个元素只能选取一次，以arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]为例，可以画出这样的树状图：\n\n\n遇到非法情况或递归到最后一个元素时，要回溯：\n\n\n可以用一个集合set记录已有的字符。\nPS：map是“引用类型”，对它的操作会影响到上一级函数\nSet + Closurefunc maxLength(arr []string) (ans int) &#123;\tarr = removeRepeat(arr) // 去除自身包含重复项的元素\t// 使用魔法：closure\tvar backtrack func(int, map[rune]bool)\tbacktrack = func(index int, set map[rune]bool) &#123;\t\t// 递归终止条件\t\tif index == len(arr) &#123;\t\t\tans = max(ans, len(set))\t\t\treturn\t\t&#125;\t\tstr := arr[index]\t\tvar repeat bool // 记录当前字符串是否和已有的相冲突\t\tfor _, v := range str &#123;\t\t\tif _, ok := set[v]; ok &#123;\t\t\t\trepeat = true\t\t\t&#125;\t\t&#125;\t\tif !repeat &#123;\t\t\t// map是“引用类型”，对它的操作会影响到上一级函数\t\t\tnewSet := make(map[rune]bool)\t\t\tfor k, v := range set &#123;\t\t\t\tnewSet[k] = v\t\t\t&#125;\t\t\tfor _, v := range str &#123;\t\t\t\tnewSet[v] = true\t\t\t&#125;\t\t\t// 向下走\t\t\tbacktrack(index+1, newSet)\t\t&#125;\t\t// 向右走\t\tbacktrack(index+1, set)\t&#125;\t\tbacktrack(0, make(map[rune]bool))\treturn ans&#125;// 去除自身包含重复项的元素func removeRepeat(arr []string) (ans []string) &#123;\tfor _, s := range arr &#123;\t\tflag := true\t\tset := make(map[rune]bool)\t\tfor _, ch := range s &#123;\t\t\tif _, ok := set[ch]; ok &#123;\t\t\t\tflag = false\t\t\t&#125; else &#123;\t\t\t\tset[ch] = true\t\t\t&#125;\t\t&#125;\t\tif flag &#123;\t\t\tans = append(ans, s)\t\t&#125;\t&#125;\treturn&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n位运算 + Closure用一个二进制数字mask标记被选中的元素，如arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]，mask = 101表示unue。\nfunc maxLength(arr []string) (ans int) &#123;\t// 筛选出无重复项的元素\tvar masks []int\tfor _, str := range arr &#123;\t\t// 魔法：位运算，用第i位是否为1标识masks的第i个元素是否被选中\t\tmask := 0\t\t// 标记是否有重复的\t\tflag := true\t\tfor _, ch := range str &#123;\t\t\t// 输入为纯小写 a-z\t\t\tch = ch - &#x27;a&#x27;\t\t\t// 有冲突\t\t\tif mask&gt;&gt;ch&amp;1 != 0 &#123;\t\t\t\tflag = false\t\t\t\tbreak\t\t\t&#125; else &#123;\t\t\t\tmask |= 1 &lt;&lt; ch\t\t\t&#125;\t\t&#125;\t\tif flag &#123;\t\t\tmasks = append(masks, mask)\t\t&#125;\t&#125;\tvar backtrack func(int, int)\tbacktrack = func(index int, mask int) &#123;\t\t// 递归终止条件\t\tif index == len(masks) &#123;\t\t\tans = max(bits.OnesCount(uint(mask)), ans)\t\t\treturn\t\t&#125;\t\ts := masks[index]\t\t// 无冲突\t\tif s&amp;mask == 0 &#123;\t\t\tbacktrack(index+1, mask|s)\t\t&#125;\t\tbacktrack(index+1, mask)\t&#125;\tbacktrack(0, 0)\treturn ans&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n","categories":["LeetCode"],"tags":["LeetCode","backtrack","回溯","位运算"]},{"title":"LeetCode-129","url":"/2020/10/30/LeetCode-129/","content":"题目\n\n\n\n结果代码费时费力的算法class Solution &#123;    // 全局变量，存储每条路径上从根节点到叶子结点的数字    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    public int sumNumbers(TreeNode root) &#123;        dfs(root, new LinkedList&lt;&gt;());        List&lt;Integer&gt; nums = new LinkedList&lt;&gt;();        ans.forEach(path -&gt; nums.add(parse(path)));        // 求和并返回        return nums.stream().reduce(0, Integer::sum);    &#125;    // 拼接字符再parse    private Integer parse(List&lt;Integer&gt; path) &#123;        StringBuilder s = new StringBuilder();        for (int num : path) &#123;            s.append(num);        &#125;        return Integer.parseInt(s.toString());    &#125;    // 深度优先遍历，途中将数字记录在path里，如果到了叶子结点，将path加到全局变量ans里    private void dfs(TreeNode root, List&lt;Integer&gt; path) &#123;        if (root == null) &#123;            return;        &#125;        List&lt;Integer&gt; _path = new LinkedList&lt;&gt;(path);        _path.add(root.val);        if (root.left == null &amp;&amp; root.right == null) &#123;            ans.add(new LinkedList&lt;&gt;(_path));        &#125;        dfs(root.left, _path);        dfs(root.right, _path);    &#125;&#125;\n\n上面的代码基本思路是，先遍历二叉树得到数字，再求和。\n如果可以遍历和求和同时进行，事半功倍。\nez wayclass Solution &#123;    public int sumNumbers(TreeNode root) &#123;        return dfs(root, 0);    &#125;    private int dfs(TreeNode root, int sum) &#123;        if (root == null) &#123;            return 0;        &#125;        sum = sum * 10 + root.val;        if (root.left == null &amp;&amp; root.right == null) &#123;            return sum;        &#125;        return dfs(root.left, sum) + dfs(root.right, sum);    &#125;&#125;\n\n\n\n复杂度时间复杂度：O（n），遍历\n空间复杂度：O（n），栈\n","categories":["LeetCode"]},{"title":"LeetCode-131","url":"/2021/03/07/LeetCode-131/","content":"题目\n\n\n\n结果\n\n代码思路挺简单的：枚举出所有可能的分割方法，然后逐一判断是否构成回文，难点在于如何枚举。\nfunc partition(s string) [][]string &#123;   paths := make([][]string, 0)   for _, ch := range s &#123;      // 1st element      if len(paths) == 0 &#123;         paths = append(paths, []string&#123;string(ch)&#125;)         continue      &#125;      // do not modify array when iterating      toAppend := make([][]string, 0)      for _, row := range paths &#123;         tmp := _copy(row)         toAppend = append(toAppend, copyAndAppend(tmp, string(ch)))         row[len(row)-1] += string(ch)      &#125;      for _, v := range toAppend &#123;         paths = append(paths, v)      &#125;   &#125;   ans := make([][]string, 0)   // filter   for _, v := range paths &#123;      if isPalindromes(v) &#123;         ans = append(ans, v)      &#125;   &#125;   return ans&#125;func isPalindromes(ss []string) bool &#123;   for _, v := range ss &#123;      if !isPalindrome(v) &#123;         return false      &#125;   &#125;   return true&#125;// is a palindromefunc isPalindrome(s string) bool &#123;   for i, j := 0, len(s)-1; i &lt; j; &#123;      if s[i] != s[j] &#123;         return false      &#125;      i++      j--   &#125;   return true&#125;func copyAndAppend(ss []string, s string) []string &#123;   ans := make([]string, 0, len(ss)+1)   for _, v := range ss &#123;      ans = append(ans, v)   &#125;   ans = append(ans, s)   return ans&#125;func _copy(ss []string) []string &#123;   ans := make([]string, 0, len(ss))   for _, v := range ss &#123;      ans = append(ans, v)   &#125;   return ans&#125;\n\n复杂度有点算不明白，应该复杂度很高\n","categories":["LeetCode"]},{"title":"LeetCode-127","url":"/2020/11/05/LeetCode-127/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final Set&lt;String&gt; visited = new HashSet&lt;&gt;();    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;        if (!contain(endWord, wordList) || beginWord.equals(endWord)) &#123;            return 0;        &#125;        visited.add(beginWord);        return bfs(branches(beginWord, wordList), endWord, wordList, 2);    &#125;    private int bfs(List&lt;String&gt; branches, String endWord, List&lt;String&gt; wordList, int level) &#123;        // if the target is in this level        if (branches.contains(endWord)) &#123;            return level;        &#125;        Set&lt;String&gt; nextLevel = new HashSet&lt;&gt;();        for (String branch : branches) &#123;            visited.add(branch);            nextLevel.addAll(branches(branch, wordList));        &#125;        // it seems that you can never reach the destination        if (nextLevel.isEmpty()) &#123;            return 0;        &#125;        return bfs(new LinkedList&lt;&gt;(nextLevel), endWord, wordList, level + 1);    &#125;    // If wordList does not have the target word    private boolean contain(String endWord, List&lt;String&gt; wordList) &#123;        for (String word : wordList) &#123;            if (word.equals(endWord)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    // show me the way forward    private List&lt;String&gt; branches(String beginWord, List&lt;String&gt; wordList) &#123;        Set&lt;String&gt; branches = new HashSet&lt;&gt;();        for (String word : wordList) &#123;            // I can&#x27;t make same mistakes once again            if (!visited.contains(word) &amp;&amp; changeable(beginWord, word)) &#123;                branches.add(word);            &#125;        &#125;        return new LinkedList&lt;&gt;(branches);    &#125;    // whether it can be done in one step    private boolean changeable(String beginWord, String word) &#123;        int difference = 0;        for (int i = 0; i &lt; word.length(); i++) &#123;            if (difference &gt; 1) &#123;                return false;            &#125;            if (beginWord.charAt(i) != word.charAt(i)) &#123;                difference++;            &#125;        &#125;        return difference == 1;    &#125;&#125;\n\n复杂度不好算啊\n","categories":["LeetCode"]},{"title":"LeetCode-130","url":"/2020/11/19/LeetCode-130/","content":"题目\n\n\n结果\n代码如果一个‘O’没有被包围，一定是因为他在边界或者他跟边界的‘O’有勾连，所以边界的‘O’是始作俑者，罪魁祸首。所以从边界的‘O’出发，把与其有勾连的全部标记一遍，就知道board里的每个‘O’是什么成分。\nclass Solution &#123;    public void solve(char[][] board) &#123;        if (board.length == 0) &#123;            return;        &#125;        boolean[][] flag = new boolean[board.length][board[0].length];        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                if (board[i][j] == &#x27;O&#x27; &amp;&amp; onBoundary(board, i, j) &amp;&amp; !flag[i][j]) &#123;                    flag[i][j] = true;                    spread(board, flag, i, j);                &#125;            &#125;        &#125;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                if (board[i][j] == &#x27;O&#x27; &amp;&amp; !flag[i][j]) &#123;                    board[i][j] = &#x27;X&#x27;;                &#125;            &#125;        &#125;    &#125;    private void spread(char[][] board, boolean[][] flag, int row, int col) &#123;        if (row &gt; 0 &amp;&amp; board[row - 1][col] == &#x27;O&#x27; &amp;&amp; !flag[row - 1][col]) &#123;            flag[row - 1][col] = true;            spread(board, flag, row - 1, col);        &#125;        if (row &lt; board.length - 1 &amp;&amp; board[row + 1][col] == &#x27;O&#x27; &amp;&amp; !flag[row + 1][col]) &#123;            flag[row + 1][col] = true;            spread(board, flag, row + 1, col);        &#125;        if (col &gt; 0 &amp;&amp; board[row][col - 1] == &#x27;O&#x27; &amp;&amp; !flag[row][col - 1]) &#123;            flag[row][col - 1] = true;            spread(board, flag, row, col - 1);        &#125;        if (col &lt; board[0].length - 1 &amp;&amp; board[row][col + 1] == &#x27;O&#x27; &amp;&amp; !flag[row][col + 1]) &#123;            flag[row][col + 1] = true;            spread(board, flag, row, col + 1);        &#125;    &#125;    private boolean onBoundary(char[][] board, int row, int col) &#123;        return row == 0 || row == board.length - 1 || col == 0 || col == board[0].length - 1;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n），n为元素个数row×col。\n","categories":["LeetCode"]},{"title":"LeetCode-134","url":"/2020/11/18/LeetCode-134/","content":"题目\n\n\n结果\n代码class Solution &#123;    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        for (int i = 0; i &lt; gas.length; i++) &#123;            if (winnable(gas, cost, i)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    private boolean winnable(int[] gas, int[] cost, int startPos) &#123;        int index = startPos;        int gasLeft = 0;        do &#123;            gasLeft += gas[index];            if (gasLeft &gt;= cost[index]) &#123;                gasLeft -= cost[index];                index++;                if (index &gt;= gas.length) &#123;                    index -= gas.length;                &#125;            &#125; else &#123;                return false;            &#125;        &#125; while (index != startPos);        return true;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-136","url":"/2020/12/18/LeetCode-136/","content":"题目\n\n\n结果\n代码func singleNumber(nums []int) int &#123;\tx := 0\tfor _, num := range nums &#123;\t\tx ^= num\t&#125;\treturn x&#125;\n\n异或运算有交换律和结合律\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-1370","url":"/2020/11/25/LeetCode-1370/","content":"题目\n\n\n结果\n代码class Solution &#123;    public String sortString(String s) &#123;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; i++) &#123;            map.put((char) i, 0);        &#125;        for (int i = 0; i &lt; s.length(); i++) &#123;            map.put(s.charAt(i), map.get(s.charAt(i)) + 1);        &#125;        StringBuilder sb = new StringBuilder();        while (sb.length() &lt; s.length()) &#123;            for (int i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; i++) &#123;                if (map.get((char) i) &gt; 0) &#123;                    sb.append((char) i);                    map.put((char) i, map.get((char) i) - 1);                &#125;            &#125;            for (int i = &#x27;z&#x27;; i &gt;= &#x27;a&#x27;; i--) &#123;                if (map.get((char) i) &gt; 0) &#123;                    sb.append((char) i);                    map.put((char) i, map.get((char) i) - 1);                &#125;            &#125;        &#125;        return sb.toString();    &#125;&#125;\n\n复杂度时间复杂度：O（n）, 26n也是n\n空间复杂度：O（n），map常数，StringBuilder是n\n","categories":["LeetCode"]},{"title":"LeetCode-140","url":"/2020/11/01/LeetCode-140/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    // 存储结果    private final List&lt;String&gt; ans = new LinkedList&lt;&gt;();    // 将s作为全局变量    private String target;    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;        // 预判断        if (!quickJudge(s, wordDict)) &#123;            return ans;        &#125;        // 将s作为全局变量        this.target = s;        TreeNode root = new TreeNode(&quot;root&quot;);        buildTree(s, wordDict, root);        for (TreeNode node : root.getChildren()) &#123;            dfs(node, &quot;&quot;);        &#125;        return ans;    &#125;    private void dfs(TreeNode root, String str) &#123;        // 如果是叶子节点        if (root.getChildren().size() == 0) &#123;            str += root.getVal();            if (str.replaceAll(&quot; &quot;, &quot;&quot;).equals(this.target)) &#123;                ans.add(str);            &#125;            return;        &#125; else &#123; // 如果不是叶子节点            str += root.getVal() + &quot; &quot;;        &#125;        // 递归        for (var node : root.getChildren()) &#123;            dfs(node, str);        &#125;    &#125;    // 递归建树    private void buildTree(String s, List&lt;String&gt; dict, TreeNode root) &#123;        for (var word : dict) &#123;            if (s.startsWith(word)) &#123;                TreeNode node = new TreeNode(word);                root.getChildren().add(node);                int index = word.length();                buildTree(s.substring(index), dict, node);            &#125;        &#125;    &#125;    // 判断s中是否有dict不含的字母    private boolean quickJudge(String s, List&lt;String&gt; dict) &#123;        Set&lt;Character&gt; set = new HashSet&lt;&gt;();        for (String str : dict) &#123;            for (char ch : str.toCharArray()) &#123;                set.add(ch);            &#125;        &#125;        for (char ch : s.toCharArray()) &#123;            if (!set.contains(ch)) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;class TreeNode &#123;    private String val;    private final List&lt;TreeNode&gt; children;    public String getVal() &#123;        return val;    &#125;    public List&lt;TreeNode&gt; getChildren() &#123;        return children;    &#125;    TreeNode(String x) &#123;        children = new LinkedList&lt;&gt;();        val = x;    &#125;&#125;\n\n复杂度时间复杂度：不知道replaceAll这种函数复杂度是多少\n空间复杂度：不计其数\n","categories":["LeetCode"]},{"title":"LeetCode-141","url":"/2020/10/09/LeetCode-141/","content":"题目\n\n\n\n结果\n\n代码SETclass ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;        next = null;    &#125;&#125;class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null) return false;        Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();        while (head != null) &#123;            if (!set.add(head)) return true;            head = head.next;        &#125;        return false;    &#125;&#125;\n\n快慢指针（使用常数内存空间）class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null) return false;        ListNode fast = head, slow = head;        boolean flag = false;        while (true) &#123;            fast = fast.next;            if (flag) slow = slow.next;            flag = !flag;            if (fast == null) return false;            if (fast == slow) return true;        &#125;    &#125;&#125;\n\n复杂度SET：\n时间复杂度：O（N）\n\n空间复杂度：O（N）\n\n\n快慢指针\n时间复杂度：O（N）\n空间复杂度：O（1）\n\n","categories":["LeetCode"]},{"title":"LeetCode-143","url":"/2020/10/20/LeetCode-143/","content":"题目\n\n\n\n结果\n\n代码双指针class Solution &#123;    public void reorderList(ListNode head) &#123;        if (head == null) &#123;            return;        &#125;        List&lt;ListNode&gt; arrayList = new ArrayList&lt;&gt;();        ListNode p = head;        while (p != null) &#123;            arrayList.add(p);            p = p.next;        &#125;        int left = 0, right = arrayList.size() - 1;        while (left &lt; right) &#123;            ListNode node1 = arrayList.get(left);            ListNode node2 = arrayList.get(right);            node2.next = node1.next;            node1.next = node2;            left++;            right--;        &#125;        arrayList.get(arrayList.size() / 2).next = null;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-1438","url":"/2021/03/06/LeetCode-1438/","content":"题目\n\n\n\n结果\n\n代码func longestSubarray(nums []int, limit int) int &#123;\tcnt := make(map[int]int)\tcnt[nums[0]]++\tminN, maxN := nums[0], nums[0]\tmaxLen := 0\tfor ptr1, ptr2 := 0, 0; ; &#123;\t\tif maxN-minN &lt;= limit &#123;\t\t\tmaxLen = max(maxLen, ptr2-ptr1+1)\t\t\tptr2++\t\t\tif ptr2 &gt;= len(nums) &#123;\t\t\t\tbreak\t\t\t&#125;\t\t\tcnt[nums[ptr2]]++\t\t\tminN = min(minN, nums[ptr2])\t\t\tmaxN = max(maxN, nums[ptr2])\t\t&#125; else &#123;\t\t\tif (nums[ptr1] == maxN &amp;&amp; cnt[maxN] == 1) || (nums[ptr1] == minN &amp;&amp; cnt[minN] == 1) &#123;\t\t\t\tminN, maxN = nums[ptr1+1], nums[ptr1+1]\t\t\t\tfor i := ptr1 + 1; i &lt;= ptr2; i++ &#123;\t\t\t\t\tmaxN = max(maxN, nums[i])\t\t\t\t\tminN = min(minN, nums[i])\t\t\t\t&#125;\t\t\t&#125;\t\t\tptr1++\t\t\tif ptr1 &gt;= len(nums) &#123;\t\t\t\tbreak\t\t\t&#125;\t\t\tcnt[nums[ptr1-1]]--\t\t&#125;\t&#125;\treturn maxLen&#125;func max(x, y int) int &#123;\tif x &gt; y &#123;\t\treturn x\t&#125;\treturn y&#125;func min(x, y int) int &#123;\tif x &gt; y &#123;\t\treturn y\t&#125;\treturn x&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-144","url":"/2020/10/27/LeetCode-144/","content":"题目\n\n\n\n结果\n\n代码递归class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        pot(ans, root);        return ans;    &#125;    private void pot(List&lt;Integer&gt; ans, TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        ans.add(root.val);        pot(ans, root.left);        pot(ans, root.right);    &#125;&#125;\n\n迭代class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        if (root == null) &#123;            return ans;        &#125;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode node = root;        while (!stack.isEmpty() || node != null) &#123;            while (node != null) &#123;                ans.add(node.val);                stack.push(node);                node = node.left;            &#125;            node = stack.pop();            node = node.right;        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n两种算法做了同样的事情，迭代的算法是用栈模拟递归隐式产生的栈。\n","categories":["LeetCode"]},{"title":"LeetCode-147","url":"/2020/11/20/LeetCode-147/","content":"题目\n\n\n结果\n代码class Solution &#123;    public ListNode insertionSortList(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;        ListNode ans = new ListNode(0);        ListNode p = head;        while (p != null) &#123;            insert(ans, new ListNode(p.val));            p = p.next;        &#125;        return ans.next;    &#125;    private void insert(ListNode list, ListNode node) &#123;        if (list.next == null) &#123;            list.next = node;            return;        &#125;        ListNode pre = list;        ListNode p = list.next;        while (p != null) &#123;            if (node.val &lt; p.val) &#123;                pre.next = node;                node.next = p;                return;            &#125;            pre = pre.next;            p = p.next;        &#125;        pre.next = node;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-145","url":"/2020/09/29/LeetCode-145/","content":"题目\n\n\n\n结果\n\n代码递归class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; path = new LinkedList&lt;&gt;();        dfs(path, root);        return path;    &#125;    private void dfs(List&lt;Integer&gt; path, TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        dfs(path, root.left);        dfs(path, root.right);        path.add(root.val);    &#125;&#125;\n\n迭代class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; path = new LinkedList&lt;&gt;();        if (root == null) &#123;            return path;        &#125;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        // dejavu的作用是判断右子树是否遍历过        TreeNode dejavu = null;        while (root != null || !stack.isEmpty()) &#123;            // 左子树            while (root != null) &#123;                stack.push(root);                root = root.left;            &#125;            // 回溯            root = stack.pop();            // 操作            if (root.right == null || root.right == dejavu) &#123;                path.add(root.val);                dejavu = root;                // 将root置为null是为了跳过添加左子树的环节                root = null;            &#125; else &#123; // 右子树                stack.push(root);                root = root.right;            &#125;        &#125;        return path;    &#125;&#125;\n\n复杂度时间复杂度：O（n），遍历每个节点\n空间复杂度：O（n），栈的开销\n","categories":["LeetCode"]},{"title":"LeetCode-148","url":"/2020/11/21/LeetCode-148/","content":"题目\n\n\n结果\n代码直接快排。。。。。。。。。。。。。。。。。。。。\nclass Solution &#123;    public ListNode sortList(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;        List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;();        ListNode p = head;        while (p != null) &#123;            nodes.add(p);            p = p.next;        &#125;        nodes.sort(Comparator.comparingInt(node -&gt; node.val));        for (int i = 0; i &lt; nodes.size() - 1; i++) &#123;            nodes.get(i).next = nodes.get(i + 1);        &#125;        nodes.get(nodes.size() - 1).next = null;        return nodes.get(0);    &#125;&#125;\n\n复杂度时间复杂度：O（nlogn）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-150","url":"/2021/03/20/LeetCode-150/","content":"题目150. 逆波兰表达式求值\n\n\n\n结果\n\n代码func evalRPN(tokens []string) int &#123;\tvar stack []int\tfor _, v := range tokens &#123;\t\tif isDigit(v) &#123;\t\t\tnum, _ := strconv.Atoi(v)\t\t\tstack = append(stack, num)\t\t&#125; else &#123;\t\t\ta, b := stack[len(stack)-2], stack[len(stack)-1]\t\t\t// stack pop\t\t\tstack = stack[:len(stack)-2]\t\t\tswitch v &#123;\t\t\tcase &quot;+&quot;:\t\t\t\tstack = append(stack, a+b)\t\t\tcase &quot;-&quot;:\t\t\t\tstack = append(stack, a-b)\t\t\tcase &quot;*&quot;:\t\t\t\tstack = append(stack, a*b)\t\t\tcase &quot;/&quot;:\t\t\t\tstack = append(stack, a/b)\t\t\t&#125;\t\t&#125;\t&#125;\treturn stack[0]&#125;func isDigit(val string) bool &#123;\tfor _, v := range val &#123;\t\tif unicode.IsDigit(v) &#123;\t\t\treturn true\t\t&#125;\t&#125;\treturn false&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-1539","url":"/2021/03/18/LeetCode-1539/","content":"题目1539. 第 k 个缺失的正整数\n\n\n\n结果代码我的笨办法func findKthPositive(arr []int, k int) int &#123;\tvar list []int\tset := make(map[int]bool)\tfor _, v := range arr &#123;\t\tset[v] = true\t&#125;\tfor i := 1; len(list) &lt; k; i++ &#123;\t\t_, ok := set[i]\t\tif !ok &#123;\t\t\tlist = append(list, i)\t\t&#125;\t&#125;\treturn list[k-1]&#125;\n\n好办法func findKthPositive(arr []int, k int) int &#123;\tfor _,v:=range arr&#123;\t\tif v &lt;= k &#123;\t\t\tk++\t\t&#125;\t&#125;\treturn k&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-154","url":"/2020/07/11/LeetCode-154/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int findMin(int[] nums) &#123;        Arrays.sort(nums);        return nums[0];    &#125;&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-160","url":"/2021/06/16/LeetCode-160/","content":"题目160. 相交链表\n\n代码求两个链表的相交部分（共同部分），很容易想到的是用集合（指针也能作为Map的key）：\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode &#123;\tset := make(map[*ListNode]bool)\tfor p := headA; p != nil; p = p.Next &#123;\t\tset[p] = true\t&#125;\tfor p := headB; p != nil; p = p.Next &#123;\t\tif _, ok := set[p]; ok &#123;\t\t\treturn p\t\t&#125;\t&#125;\treturn nil&#125;\n\n这种方法有线性级别的时间和空间复杂度。\n我想到一种精彩的譬喻，可以把两个链表看做是两个赛道，这两个赛道长度不同但终点却在同一处。\n位于两个赛道上的两个速度相同的选手同时出发，因为赛道长度不同，到达终点的时刻必然不同，但两条赛道的长度和却是一样的（A+B&#x3D;B+A）。\n如果让到达终点的选手立即再去以相同的速度跑另一个赛道，两个选手必能同时到达终点：\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode &#123;\tpa, pb := headA, headB\tfor pa != pb &#123;\t\tif pa != nil &#123;\t\t\tpa = pa.Next\t\t&#125; else &#123;\t\t\tpa = headB\t\t&#125;\t\tif pb != nil &#123;\t\t\tpb = pb.Next\t\t&#125; else &#123;\t\t\tpb = headA\t\t&#125;\t&#125;\treturn pa&#125;\n\n上面的方法拥有线性级别的时间复杂度和常数级别的空间复杂度。\n此前还想到这种解法，复杂度都差不多，因为“本质”都一样，但我很难描述这种“本质”。。T—T\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode &#123;\tlenA := length(headA)\tlenB := length(headB)\tfor &#123;\t\tif lenA == 0 || lenB == 0 &#123;\t\t\treturn nil\t\t&#125;\t\tif headA == headB &#123;\t\t\treturn headA\t\t&#125; else &#123;\t\t\tif lenA &gt; lenB &#123;\t\t\t\theadA = headA.Next\t\t\t\tlenA--\t\t\t&#125; else if lenA == lenB &#123;\t\t\t\theadA = headA.Next\t\t\t\tlenA--\t\t\t\theadB = headB.Next\t\t\t\tlenB--\t\t\t&#125; else &#123;\t\t\t\theadB = headB.Next\t\t\t\tlenB--\t\t\t&#125;\t\t&#125;\t&#125;&#125;func length(head *ListNode) (ans int) &#123;\tfor p := head; p != nil; p = p.Next &#123;\t\tans++\t&#125;\treturn&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-1603","url":"/2021/03/20/LeetCode-1603/","content":"题目1603. 设计停车系统\n\n\n\n结果\n\n代码type ParkingSystem struct &#123;\ts, m, l    int // threshold\tss, mm, ll int // current status&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123;\treturn ParkingSystem&#123;\t\ts: small,\t\tm: medium,\t\tl: big,\t&#125;&#125;func (ps *ParkingSystem) AddCar(carType int) bool &#123;\tswitch carType &#123;\tcase 3:\t\tif ps.ss+1 &lt;= ps.s &#123;\t\t\tps.ss++\t\t\treturn true\t\t&#125;\tcase 2:\t\tif ps.mm+1 &lt;= ps.m &#123;\t\t\tps.mm++\t\t\treturn true\t\t&#125;\tcase 1:\t\tif ps.ll+1 &lt;= ps.l &#123;\t\t\tps.ll++\t\t\treturn true\t\t&#125;\t&#125;\treturn false&#125;/** * Your ParkingSystem object will be instantiated and called as such: * obj := Constructor(big, medium, small); * param_1 := obj.AddCar(carType); */\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-164","url":"/2020/11/26/LeetCode-164/","content":"题目\n\n\n结果\n代码快排class Solution &#123;    public int maximumGap(int[] nums) &#123;        if (nums.length &lt;= 1) &#123;            return 0;        &#125;        Arrays.sort(nums);        int gap = Integer.MIN_VALUE;        for (int i = 0; i &lt; nums.length - 1; i++) &#123;            gap = Math.max(gap, nums[i + 1] - nums[i]);        &#125;        return gap;    &#125;&#125;\n\n基数排序class Solution &#123;    public int maximumGap(int[] nums) &#123;        if (nums.length &lt;= 1) &#123;            return 0;        &#125;        radixSort(nums);        int max = Integer.MIN_VALUE;        for (int i = 0; i &lt; nums.length - 1; i++) &#123;            max = Math.max(max, nums[i + 1] - nums[i]);        &#125;        return max;    &#125;    private void radixSort(int[] nums) &#123;        long exp = 1;        int[] buf = new int[nums.length];        int max = Arrays.stream(nums).max().getAsInt();        while (max &gt;= exp) &#123;            int[] cnt = new int[10];            for (int num : nums) &#123;                int digit = (int) ((num / exp) % 10);                cnt[digit]++;            &#125;            // 我前面有多少人？            for (int i = 1; i &lt; 10; i++) &#123;                cnt[i] += cnt[i - 1];            &#125;            for (int i = nums.length - 1; i &gt;= 0; i--) &#123;                int digit = (int) (nums[i] / exp) % 10;                // cnt[digit]&gt;0                buf[cnt[digit] - 1] = nums[i];                cnt[digit]--;            &#125;            System.arraycopy(buf, 0, nums, 0, nums.length);            exp *= 10;        &#125;    &#125;&#125;\n\n复杂度快排：时间复杂度：O（N log N）\n空间复杂度：O（log N），快排过程中递归需要的栈空间\n基数排序：时间复杂度：O（N）\n空间复杂度：O（N）\n","categories":["LeetCode"]},{"title":"LeetCode-167","url":"/2020/07/20/LeetCode-167/","content":"LeetCode-167  两数之和II - 输入有序数组题目\n\n\n\n结果\n\n代码暴力法class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        for (int i = 0; i &lt; numbers.length; i++) &#123;            for (int j = i + 1; j &lt; numbers.length; j++) &#123;                if (numbers[i] + numbers[j] == target) &#123;                    return new int[]&#123;i + 1, j + 1&#125;;                &#125;            &#125;        &#125;        return null;    &#125;&#125;\n\n二分法class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        for (int i = 0; i &lt; numbers.length; i++) &#123;            // 如果加上最大的都小于target，那就可以进入下一轮了            if (numbers[i] + numbers[numbers.length - 1] &lt; target) &#123;                continue;            &#125;            int index = search(numbers, target - numbers[i], i + 1);            // 如果没找到            if (index == -1) &#123;                continue;            &#125;            return new int[]&#123;i + 1, index + 1&#125;;        &#125;        return null;    &#125;    // 二分法搜索target    public int search(int[] numbers, int target, int begin) &#123;        int end = numbers.length - 1;        while (begin &lt;= end) &#123;            int mid = (begin + end) / 2;            if (numbers[mid] == target) &#123;                return mid;            &#125; else if (numbers[mid] &lt; target) &#123;                begin = mid + 1;            &#125; else &#123;                end = mid - 1;            &#125;        &#125;        return -1;    &#125;&#125;\n\n双指针法class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        int begin = 0, end = numbers.length - 1;        while (begin &lt; end) &#123;            int sum = numbers[begin] + numbers[end];            if (sum == target) &#123;                return new int[]&#123;begin + 1, end + 1&#125;;            &#125; else if (sum &lt; target) &#123;                begin++;            &#125; else &#123;                end--;            &#125;        &#125;        return null;    &#125;&#125;\n\n复杂度暴力法时间复杂度：O（n²）\n空间复杂度：O（1）\n二分法时间复杂度：O（nlogn）\n空间复杂度：O（1）\n双指针法时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-17","url":"/2020/08/26/LeetCode-17/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private static final Map&lt;Character, List&lt;Character&gt;&gt; num2Alpha = new HashMap&lt;&gt;();    private static final StringBuilder combination = new StringBuilder();    private void initMap() &#123;        num2Alpha.put(&#x27;2&#x27;, List.of(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;));        num2Alpha.put(&#x27;3&#x27;, List.of(&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;));        num2Alpha.put(&#x27;4&#x27;, List.of(&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;));        num2Alpha.put(&#x27;5&#x27;, List.of(&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;));        num2Alpha.put(&#x27;6&#x27;, List.of(&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;));        num2Alpha.put(&#x27;7&#x27;, List.of(&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;));        num2Alpha.put(&#x27;8&#x27;, List.of(&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;));        num2Alpha.put(&#x27;9&#x27;, List.of(&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;));    &#125;    public List&lt;String&gt; letterCombinations(String digits) &#123;        List&lt;String&gt; ans = new LinkedList&lt;&gt;();        if (digits.length() == 0) &#123;            return ans;        &#125;        initMap();        backtrack(ans, digits, 0);        return ans;    &#125;    private void backtrack(List&lt;String&gt; ans, String digits, int index) &#123;        if (index == digits.length()) &#123;            ans.add(combination.toString());            return;        &#125;        var letters = num2Alpha.get(digits.charAt(index));        for (Character letter : letters) &#123;            combination.append(letter);            backtrack(ans, digits, index + 1);            combination.deleteCharAt(index);        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（∏数字对应字母的个数），需要遍历每一种字母组合\n空间复杂度：O（digits.length），Map的大小可以视为常数，所以空间复杂度主要取决于递归层数。\n","categories":["LeetCode"]},{"title":"LeetCode-173","url":"/2021/03/28/LeetCode-173/","content":"题目173. 二叉搜索树迭代器\n\n\n\n结果\n\n代码/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */type BSTIterator struct &#123;\tidx     int\tinorder []int&#125;func Constructor(root *TreeNode) BSTIterator &#123;\titr := BSTIterator&#123;inorder: []int&#123;&#125;&#125;\tdfs(root, &amp;itr)\treturn itr&#125;func (this *BSTIterator) Next() int &#123;\tthis.idx++\treturn this.inorder[this.idx-1]&#125;func (this *BSTIterator) HasNext() bool &#123;\treturn this.idx &lt; len(this.inorder)&#125;func dfs(root *TreeNode, itr *BSTIterator) &#123;\tif root == nil &#123;\t\treturn\t&#125;\tdfs(root.Left, itr)\titr.inorder = append(itr.inorder, root.Val)\tdfs(root.Right, itr)&#125;/** * Your BSTIterator object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.Next(); * param_2 := obj.HasNext(); */","categories":["LeetCode"]},{"title":"LeetCode-179","url":"/2021/04/12/LeetCode-179/","content":"题目179. 最大数\n\n\n\n结果\n\n代码func largestNumber(nums []int) string &#123;   var arr array = nums   sort.Sort(arr)   var buf bytes.Buffer   for _, v := range arr &#123;      buf.WriteString(strconv.Itoa(v))   &#125;   if zeroOnly(buf.String()) &#123;      return &quot;0&quot;   &#125; else &#123;      return buf.String()   &#125;&#125;type array []intfunc (a array) Len() int &#123;   return len(a)&#125;func (a array) Less(i, j int) bool &#123;   x := strconv.Itoa(a[i])   y := strconv.Itoa(a[j])   for i := 0; i &lt; len(x)+len(y); i++ &#123;      if x[i%len(x)] &lt; y[i%len(y)] &#123;         return false      &#125; else if x[i%len(x)] == y[i%len(y)] &#123;         continue      &#125; else &#123;         return true      &#125;   &#125;   return true&#125;func max(x, y int) int &#123;   if x &gt; y &#123;      return x   &#125;   return y&#125;func (a array) Swap(i, j int) &#123;   a[i], a[j] = a[j], a[i]&#125;func zeroOnly(s string) bool &#123;   for _, v := range s &#123;      if v != &#x27;0&#x27; &#123;         return false      &#125;   &#125;   return true&#125;","categories":["LeetCode"]},{"title":"LeetCode-18","url":"/2020/10/05/LeetCode-18/","content":"题目\n\n\n\n结果\n\n代码四重循环之再去重class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            for (int j = i + 1; j &lt; nums.length; j++) &#123;                for (int k = j + 1; k &lt; nums.length; k++) &#123;                    for (int l = k + 1; l &lt; nums.length; l++) &#123;                        if (nums[i] + nums[j] + nums[k] + nums[l] == target) &#123;                            // 不直接add（List.of(x,x,x)）是因为List.of生成的list不能修改                            ans.add(new LinkedList&lt;&gt;(List.of(nums[i], nums[j], nums[k], nums[l])));                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 排序以便去重        ans.forEach(list -&gt; list.sort(Integer::compareTo));        // 去重并返回        return ans.stream().distinct().collect(Collectors.toList());    &#125;&#125;\n\n复杂度时间复杂度：O（n^4）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-189","url":"/2021/03/18/LeetCode-189/","content":"题目189. 旋转数组\n\n结果\n\n代码func rotate(nums []int, k int) &#123;\tk = k % len(nums)\treverse(nums)\treverse(nums[:k])\treverse(nums[k:])&#125;func reverse(nums []int) &#123;\tfor i, j := 0, len(nums)-1; i &lt; j; i, j = i+1, j-1 &#123;\t\tnums[i], nums[j] = nums[j], nums[i]\t&#125;&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-19","url":"/2020/10/18/LeetCode-19/","content":"题目\n\n\n\n结果\n\n代码通过链表长度定位class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        // 计算长度        int length = length(head);        // 特殊情况        if (length == n) &#123;            return head.next;        &#125;                // 移动指针        ListNode p = head;        int index = length - n - 1;        for (int i = 0; i &lt; index; i++) &#123;            p = p.next;        &#125;                // 删除节点        p.next = n == 1 ? null : p.next.next;        return head;    &#125;    private int length(ListNode head) &#123;        int length = 0;        while (head != null) &#123;            length++;            head = head.next;        &#125;        return length;    &#125;&#125;\n\n入栈再出栈class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        // 添加一个头节点        ListNode trueHead = new ListNode(0);        trueHead.next = head;        // 入栈        Deque&lt;ListNode&gt; stack = new LinkedList&lt;&gt;();        ListNode p = trueHead;        while (p != null) &#123;            stack.push(p);            p = p.next;        &#125;        // 出栈        for (int i = 0; i &lt; n; i++) &#123;            stack.pop();        &#125;        // 删除节点        ListNode pre = stack.peek();        pre.next = pre.next.next;        return trueHead.next;    &#125;&#125;\n\n快慢指针class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode trueHead = new ListNode(0);        trueHead.next = head;        ListNode fast = trueHead, slow = trueHead;        for (int i = 0; i &lt; n; i++) &#123;            fast = fast.next;        &#125;        while (fast.next != null) &#123;            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return trueHead.next;    &#125;&#125;\n\n复杂度通过链表长度定位时间复杂度：O（n）\n空间复杂度：O（1）\n借助栈时间复杂度：O（n）\n空间复杂度：O（n）\n快慢指针时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-190","url":"/2021/03/29/LeetCode-190/","content":"题目190. 颠倒二进制位\n\n\n\n结果\n\n代码package mainimport (   &quot;fmt&quot;)func main() &#123;   fmt.Println(reverseBits(0b00000010100101000001111010011100))&#125;func reverseBits(num uint32) (ans uint32) &#123;   for i := 0; i &lt; 32 &amp;&amp; num &gt; 0; i++ &#123;      // 最低位：num &amp; 1      // 最低位左移 31 - i 位：从最高位到最低位      ans |= num &amp; 1 &lt;&lt; (31 - i)      num &gt;&gt;= 1   &#125;   return&#125;\n\n复杂度时间复杂度：O（1）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-2","url":"/2020/10/04/LeetCode-2/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode ans = new ListNode(0);        ListNode p = ans;        int carry = 0;        while (l1 != null || l2 != null) &#123;            int val = 0;            if (l1 != null) &#123;                val += l1.val;                l1 = l1.next;            &#125;            if (l2 != null) &#123;                val += l2.val;                l2 = l2.next;            &#125;            val += carry;            carry = val &gt;= 10 ? 1 : 0;            p.next = new ListNode(val % 10);            p = p.next;        &#125;        if (carry == 1) &#123;            p.next = new ListNode(1);        &#125;        return ans.next;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-191","url":"/2020/07/18/LeetCode-191/","content":"题目191. 位1的个数\n\n\n\n\n结果\n\n代码版本一class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        return Integer.toBinaryString(n).replace(&quot;0&quot;, &quot;&quot;).length();    &#125;&#125;\n\n版本二public class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        String s = Integer.toBinaryString(n);        int count = 0;        for (char ch : s.toCharArray()) &#123;            if (ch == &#x27;1&#x27;) &#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;\n\nGofunc hammingWeight(num uint32) int &#123;\tcnt := 0\tfor _, v := range strconv.FormatUint(uint64(num),2) &#123;\t\tif v == &#x27;1&#x27; &#123;\t\t\tcnt++\t\t&#125;\t&#125;\treturn cnt&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-204","url":"/2020/12/03/LeetCode-204/","content":"题目\n\n\n结果\n代码直接挨个儿判断是不是质数，就算是开了方的那种也会超时。\nclass Solution &#123;    public int countPrimes(int n) &#123;        int ans = 0;        for (int i = 2; i &lt; n; ++i) &#123;            ans += isPrime(i) ? 1 : 0;        &#125;        return ans;    &#125;    public boolean isPrime(int x) &#123;        for (int i = 2; i * i &lt;= x; ++i) &#123;            if (x % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n利用数组：\nclass Solution &#123;    public int countPrimes(int n) &#123;        if (n &lt; 2) &#123;            return 0;        &#125;        boolean[] prime = new boolean[n];        prime[0] = true;        prime[1] = true;        for (int i = 2; i &lt; Math.sqrt(n); i++) &#123;            if (!prime[i]) &#123;                for (int j = 2; i * j &lt; n; j++) &#123;                    prime[i * j] = true;                &#125;            &#125;        &#125;        int count = 0;        for (boolean flag : prime) &#123;            if (!flag) &#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;\n\n复杂度不好算\n","categories":["LeetCode"]},{"title":"LeetCode-206","url":"/2020/07/31/LeetCode-206/","content":"题目\n\n\n\n结果\n\n代码class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125; else &#123;            ListNode ans = reverseList(head.next);            head.next.next = head;            head.next = null;            return ans;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-216","url":"/2020/09/11/LeetCode-216/","content":"题目\n\n\n\n结果\n\n代码超时版本class Solution &#123;    // Save the final answer    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    // 0 ~ 9    private final int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    // Whether the num has been used    private final boolean[] flag = new boolean[9];    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        dfs(n, k, new LinkedList&lt;&gt;());        // Sort in order to deduplicate        ans.forEach(integers -&gt; integers.sort(Integer::compareTo));        // Deduplicate and return the final answer        return ans.stream().distinct().collect(Collectors.toList());    &#125;    private void dfs(int target, int k, List&lt;Integer&gt; tmp) &#123;        // Time to stop recursive call        if (k == 0 &amp;&amp; target == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));            return;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            // If the num has not been used            if (!flag[i]) &#123;                flag[i] = true;                List&lt;Integer&gt; newTmp = new LinkedList&lt;&gt;(tmp);                newTmp.add(nums[i]);                // Recursive call                dfs(target - nums[i], k - 1, newTmp);                flag[i] = false;            &#125;        &#125;    &#125;&#125;\n\n这个版本的结果，重复元素非常多，比如这个序列：\n[[1, 2, 6], [1, 3, 5], [1, 5, 3], [1, 6, 2], [2, 1, 6], [2, 3, 4], [2, 4, 3], [2, 6, 1], [3, 1, 5], [3, 2, 4], [3, 4, 2], [3, 5, 1], [4, 2, 3], [4, 3, 2], [5, 1, 3], [5, 3, 1], [6, 1, 2], [6, 2, 1]]\n可以稍加改进，方法是不再考虑使用比元素更小的数，比如现在dfs到了5，那就不再考虑1~4.\n优化版本class Solution &#123;    // Save the final answer    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    // 0 ~ 9    private final int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    // Whether the num has been used    private final boolean[] flag = new boolean[9];    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        dfs(n, k, new LinkedList&lt;&gt;(), 0);        // Sort in order to deduplicate        ans.forEach(integers -&gt; integers.sort(Integer::compareTo));        // Deduplicate and return the final answer        return ans.stream().distinct().collect(Collectors.toList());    &#125;    /**     *     * @param target sum     * @param k How many nums can be used     * @param tmp From last recursive call     * @param index Remember where to start in order to deduplicate     */    private void dfs(int target, int k, List&lt;Integer&gt; tmp, int index) &#123;        // Time to stop recursive call        if (k == 0 &amp;&amp; target == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));            return;        &#125;        // Start loop from index        for (int i = index; i &lt; nums.length; i++) &#123;            // If the num has not been used            if (!flag[i]) &#123;                flag[i] = true;                List&lt;Integer&gt; newTmp = new LinkedList&lt;&gt;(tmp);                newTmp.add(nums[i]);                // Recursive call                dfs(target - nums[i], k - 1, newTmp, index + 1);                flag[i] = false;            &#125;        &#125;    &#125;&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-222","url":"/2020/11/24/LeetCode-222/","content":"题目\n\n\n结果\n代码普世众生的解法class Solution &#123;    public int countNodes(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125;        return 1 + countNodes(root.left) + countNodes(root.right);    &#125;&#125;\n\n复杂度时间复杂度：O（n），n为节点个数\n空间复杂度：O（log n）\n","categories":["LeetCode"]},{"title":"LeetCode-224","url":"/2021/03/11/LeetCode-224/","content":"题目224. 基本计算器\n\n\n\n结果\n\n代码思路就一句话：遇到括号，先计算括号里面的值，再该干嘛干嘛\nfunc calculate(s string) int &#123;   s = strings.ReplaceAll(s, &quot; &quot;, &quot;&quot;)   stk := make([]rune, 0)   // s only contains num and &#x27;+&#x27; &#x27;-&#x27;   for _, v := range s &#123;      if v != &#x27;)&#x27; &#123;         stk = append(stk, v)         continue      &#125;      // when encounter a &#x27;)&#x27;      var bf bytes.Buffer      for &#123;         top := stk[len(stk)-1]         // stack pop         stk = stk[:len(stk)-1]         if top == &#x27;(&#x27; &#123;            break         &#125;         bf.WriteRune(top)      &#125;      val := simpleCalculate(reverse(bf.String()))      for _, vv := range val &#123;         stk = append(stk, vv)      &#125;   &#125;   ans, err := strconv.Atoi(simpleCalculate(string(stk)))   if err != nil &#123;      panic(err)   &#125;   return ans&#125;func simpleCalculate(expr string) string &#123;   // handle negative number   expr = strings.ReplaceAll(expr, &quot;--&quot;, &quot;+&quot;)   expr = strings.ReplaceAll(expr, &quot;+-&quot;, &quot;-&quot;)   stk := make([]int, 0)   num := 0   opt := &#x27;+&#x27;   for i, v := range expr &#123;      if unicode.IsDigit(v) &#123;         num = num*10 + int(v-&#x27;0&#x27;)      &#125;      if isOpt(v) || i == len(expr)-1 &#123;         switch opt &#123;         case &#x27;+&#x27;:            stk = append(stk, num)         case &#x27;-&#x27;:            stk = append(stk, -num)         &#125;         num = 0         opt = v      &#125;   &#125;   return strconv.Itoa(sum(stk))&#125;func isOpt(ch rune) bool &#123;   opts := &quot;+-*/&quot;   return strings.Contains(opts, string(ch))&#125;func sum(nums []int) int &#123;   ans := 0   for _, v := range nums &#123;      ans += v   &#125;   return ans&#125;// reverse stringfunc reverse(s string) string &#123;   runes := []rune(s)   for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 &#123;      runes[i], runes[j] = runes[j], runes[i]   &#125;   return string(runes)&#125;\n\n复杂度时间复杂度：O（n），虽然有很多循环，但都是线性的复杂度\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-226","url":"/2020/08/25/LeetCode-226/","content":"题目\n\n\n\n结果\n\n代码/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if (root == null) &#123;            return null;        &#125;        mirror(root);        return root;    &#125;    public void mirror(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        TreeNode tmp = root.left;        mirror(root.left);        mirror(root.right);        root.left = root.right;        root.right = tmp;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-228","url":"/2021/03/17/LeetCode-228/","content":"题目228. 汇总区间\n\n\n\n结果\n\n代码func summaryRanges(nums []int) (ans []string) &#123;\tfor i := 0; i &lt; len(nums); &#123;\t\tfor j := i + 1; j &lt;= len(nums); j++ &#123;\t\t\tif j == len(nums) || nums[j-1]+1 != nums[j] &#123;\t\t\t\tans = append(ans, interval(nums[i], nums[j-1]))\t\t\t\ti = j\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t&#125;\treturn&#125;func interval(a, b int) string &#123;\tif a == b &#123;\t\treturn strconv.Itoa(a)\t&#125;\treturn fmt.Sprintf(&quot;%d-&gt;%d&quot;, a, b)&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-217","url":"/2020/12/13/LeetCode-217/","content":"题目\n\n\n结果\n代码class Solution &#123;    public boolean containsDuplicate(int[] nums) &#123;        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        for (int num : nums) &#123;            if (!set.add(num)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-227","url":"/2021/03/11/LeetCode-227/","content":"题目227. 基本计算器 II\n\n这道题和另一道题目一模一样：\n面试题 16.26. 计算器\nBlog-面试题 16.26\n\n\n结果\n\n代码将数字逐个入栈，遇到乘除号就计算，遇到减号就将其变为相反数，最后求和。\nfunc calculate(s string) int &#123;   stk := make([]int, 0)   opt := &#x27;+&#x27;   num := 0   for i, v := range s &#123;      if unicode.IsDigit(v) &#123;         num = num*10 + int(v-&#x27;0&#x27;)      &#125;      if isOpt(v) || i == len(s)-1 &#123;         switch opt &#123;         case &#x27;+&#x27;:            stk = append(stk, num)         case &#x27;-&#x27;:            stk = append(stk, -num)         case &#x27;*&#x27;:            // stack pop            top := stk[len(stk)-1]            stk = stk[:len(stk)-1]            stk = append(stk, top*num)         case &#x27;/&#x27;:            // stack pop            top := stk[len(stk)-1]            stk = stk[:len(stk)-1]            stk = append(stk, top/num)         &#125;         // reset         opt = v         num = 0      &#125;   &#125;   return sum(stk)&#125;func isOpt(ch rune) bool &#123;   opts := &quot;+-*/&quot;   return strings.Contains(opts, string(ch))&#125;func sum(nums []int) int &#123;   ans := 0   for _, v := range nums &#123;      ans += v   &#125;   return ans&#125;\n\n另一种解法之前写的，不同的思路，这个显得很复杂，应该是我代码写的太垃圾的原因。\npackage mainimport (   &quot;strconv&quot;   &quot;unicode&quot;)func main() &#123;   println(calculate(&quot;3+2*2&quot;))&#125;var priority = map[rune]int&#123;   &#x27;+&#x27;: 0,   &#x27;-&#x27;: 0,   &#x27;*&#x27;: 1,   &#x27;/&#x27;: 1,&#125;type elem struct &#123;   val  int   flag bool // number or operator&#125;func calculate(s string) int &#123;   return val(expr(s))&#125;// convert in-order sequence to after-order sequencefunc expr(src string) []elem &#123;   var exprStk []elem   var opStk []rune   // ignore or not when encounter a digit   var jump bool   for i, v := range src &#123;      switch &#123;      case unicode.IsSpace(v):         continue      case unicode.IsDigit(v):         if !jump &#123;            exprStk = append(exprStk, elem&#123;val: nextNum(src, i)&#125;)            jump = true         &#125;      default: // operator: + - * /         jump = false         if len(opStk) == 0 || priority[v] &gt; priority[opStk[len(opStk)-1]] &#123;            opStk = append(opStk, v)            continue         &#125;         for len(opStk) != 0 &#123;            // pop the operators which have higher or same priority            top := opStk[len(opStk)-1]            if priority[v] &lt;= priority[top] &#123;               exprStk = append(exprStk, elem&#123;                  val:  int(top),                  flag: true,               &#125;)               opStk = opStk[:len(opStk)-1]            &#125; else &#123;               break            &#125;         &#125;         opStk = append(opStk, v)      &#125;   &#125;   // push the rest operators into the exprStk   for len(opStk) != 0 &#123;      top := opStk[len(opStk)-1]      exprStk = append(exprStk, elem&#123;         val:  int(top),         flag: true,      &#125;)      opStk = opStk[:len(opStk)-1]   &#125;   return exprStk&#125;func val(expr []elem) int &#123;   stk := make([]int, 0)   for _, v := range expr &#123;      switch v.flag &#123;      case false: // number         stk = append(stk, v.val)      case true: // operator         b := stk[len(stk)-1]         stk = stk[:len(stk)-1]         a := stk[len(stk)-1]         stk = stk[:len(stk)-1]         switch v.val &#123;         case &#x27;+&#x27;:            stk = append(stk, a+b)         case &#x27;-&#x27;:            stk = append(stk, a-b)         case &#x27;*&#x27;:            stk = append(stk, a*b)         case &#x27;/&#x27;:            stk = append(stk, a/b)         &#125;      &#125;   &#125;   return stk[0]&#125;func nextNum(expr string, index int) int &#123;   var str string   for i := index; i &lt; len(expr); i++ &#123;      if !unicode.IsDigit(rune(expr[i])) &#123;         break      &#125;      str += string(expr[i])   &#125;   ans, _ := strconv.ParseInt(str, 10, 64)   return int(ans)&#125;\n\n复杂度时间复杂度：O（n），遍历数组stk\n空间复杂度：O（n），使用数组stk\n","categories":["LeetCode"]},{"title":"LeetCode-232","url":"/2021/03/05/LeetCode-232/","content":"题目\n\n\n\n结果\n\n代码type MyQueue struct &#123;\tstack []int&#125;/** Initialize your data structure here. */func Constructor() MyQueue &#123;\treturn MyQueue&#123;make([]int, 0)&#125;&#125;/** Push element x to the back of queue. */func (this *MyQueue) Push(x int) &#123;\tthis.stack = append(this.stack, x)&#125;/** Removes the element from in front of queue and returns that element. */func (this *MyQueue) Pop() int &#123;\tv := this.Peek()\tthis.stack = this.stack[1:len(this.stack)]\treturn v&#125;/** Get the front element. */func (this *MyQueue) Peek() int &#123;\treturn this.stack[0]&#125;/** Returns whether the queue is empty. */func (this *MyQueue) Empty() bool &#123;\treturn len(this.stack) == 0&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-234","url":"/2020/07/19/LeetCode-234/","content":"LeetCode-234  回文链表题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        ListNode p = head;        int length = 0;        while (p != null) &#123;            length++;            p = p.next;        &#125;        List&lt;Integer&gt; l1 = new LinkedList&lt;&gt;();        List&lt;Integer&gt; l2 = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; length / 2; i++) &#123;            l1.add(head.val);            head = head.next;        &#125;        // 如果长度是奇数        if (length % 2 != 0) &#123;            head = head.next;        &#125;        for (int i = 0; i &lt; length / 2; i++) &#123;            l2.add(head.val);            head = head.next;        &#125;        Collections.reverse(l2);        return l1.equals(l2);    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-235","url":"/2020/09/27/LeetCode-235/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        var path1 = search(root, p.val);        var path2 = search(root, q.val);                for (int i = path1.size() - 1; i &gt;= 0; i--) &#123;            var ans = path1.get(i);            if (path2.contains(ans)) &#123;                return ans;            &#125;        &#125;        return null;    &#125;    private List&lt;TreeNode&gt; search(TreeNode root, int target) &#123;        List&lt;TreeNode&gt; path = new ArrayList&lt;&gt;();        if (root == null) &#123;            return path;        &#125;                while (root.val != target) &#123;            path.add(root);            if (root.val &gt; target) &#123;                root = root.left;            &#125; else &#123;                root = root.right;            &#125;        &#125;        path.add(root);        return path;    &#125;&#125;\n\n别忘了这是一颗二叉搜索树！\n复杂度时间复杂度：O（n），最坏情况\n空间复杂度：O（n），最坏情况\n","categories":["LeetCode"]},{"title":"LeetCode-238","url":"/2020/08/01/LeetCode-238/","content":"题目\n\n\n\n结果\n\n代码直接（暴力）法class Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int[] output = new int[nums.length];        for (int i = 0; i &lt; nums.length; i++) &#123;            output[i] = multiply(i, nums);        &#125;        return output;    &#125;    private int multiply(int index, int[] nums) &#123;        int ans = 1;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (i != index) &#123;                ans *= nums[i];            &#125;        &#125;        return ans;    &#125;&#125;\n\n除法class Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int[] output = new int[nums.length];        int mul = Arrays.stream(nums).reduce(1, (acc, n) -&gt; acc * n);        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] != 0) &#123;                output[i] = mul / nums[i];            &#125; else &#123;                output[i] = multiply(i, nums);            &#125;        &#125;        return output;    &#125;    private int multiply(int index, int[] nums) &#123;        int ans = 1;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (i != index) &#123;                ans *= nums[i];            &#125;        &#125;        return ans;    &#125;&#125;\n\n左右乘积法class Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;        int[] left = new int[nums.length];        int[] right = new int[nums.length];        int[] output = new int[nums.length];                left[0] = 1;        left[1] = nums[0];        right[nums.length - 1] = 1;        right[nums.length - 2] = nums[nums.length - 1];                for (int i = 2; i &lt; nums.length; i++) &#123;            left[i] = left[i - 1] * nums[i - 1];            right[nums.length - i - 1] = right[nums.length - i] * nums[nums.length - i];        &#125;                for (int i = 0; i &lt; nums.length; i++) &#123;            output[i] = left[i] * right[i];        &#125;        return output;    &#125;&#125;\n\n复杂度直接（暴力法）\n时间复杂度：O（n²）\n\n空间复杂度：O（1）输出数组不被视为额外空间\n\n\n除法\n时间复杂度：根据0的个数，最坏情况下是O（n²），一般情况是O（n）\n\n空间复杂度：O（1）输出数组不被视为额外空间\n\n\n左右乘积法：\n时间复杂度：O（n）\n\n空间复杂度：O（n）\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-24","url":"/2020/10/13/LeetCode-24/","content":"题目\n\n\n\n结果\n\n代码递归class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;        ListNode tmp = head.next;        head.next = swapPairs(head.next.next);        tmp.next = head;        return tmp;    &#125;&#125;\n\n迭代class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125;        Queue&lt;ListNode&gt; queue = new LinkedList&lt;&gt;();        ListNode p = head;        while (p.next != null) &#123;            queue.add(p.next);            queue.add(p);            if (p.next.next == null) &#123;                break;            &#125; else if (p.next.next.next == null) &#123;                queue.add(p.next.next);                break;            &#125; else &#123;                p = p.next.next;            &#125;        &#125;        ListNode ans = queue.poll();        p = ans;        while (!queue.isEmpty()) &#123;            p.next = queue.poll();            p = p.next;            if (queue.size() == 0) &#123;                p.next = null;            &#125;        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-242","url":"/2020/11/22/LeetCode-242/","content":"题目\n\n\n结果\n代码快排后逐一比较class Solution &#123;    public boolean isAnagram(String s, String t) &#123;        var ch1 = s.toCharArray();        var ch2 = t.toCharArray();        Arrays.sort(ch1);        Arrays.sort(ch2);        return arrayEqual(ch1, ch2);    &#125;    private boolean arrayEqual(char[] s1, char[] s2) &#123;        if (s1.length != s2.length) &#123;            return false;        &#125;        for (int i = 0; i &lt; s2.length; i++) &#123;            if(s1[i]!=s2[i])&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\nMapclass Solution &#123;    public boolean isAnagram(String s, String t) &#123;        if (s.length() != t.length()) &#123;            return false;        &#125;        Map&lt;Character, Integer&gt; sMap = new HashMap&lt;&gt;();        Map&lt;Character, Integer&gt; tMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; s.length(); i++) &#123;            if (sMap.containsKey(s.charAt(i))) &#123;                sMap.put(s.charAt(i), sMap.get(s.charAt(i)) + 1);            &#125; else &#123;                sMap.put(s.charAt(i), 1);            &#125;            if (tMap.containsKey(t.charAt(i))) &#123;                tMap.put(t.charAt(i), tMap.get(t.charAt(i)) + 1);            &#125; else &#123;                tMap.put(t.charAt(i), 1);            &#125;        &#125;        for (Character key : sMap.keySet()) &#123;            if (!sMap.get(key).equals(tMap.get(key))) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n复杂度时间复杂度：O（nlogn），第一种方法\n空间复杂度：O（n），第一种方法\n","categories":["LeetCode"]},{"title":"LeetCode-257","url":"/2020/09/04/LeetCode-257/","content":"题目\n\n\n\n结果\n\n代码class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    private final List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        if (root == null) &#123;            return new LinkedList&lt;&gt;();        &#125;        List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();        res.add(tmp);        dfs(root, tmp);        return generatePath();    &#125;    private List&lt;String&gt; generatePath() &#123;        List&lt;String&gt; ans = new LinkedList&lt;&gt;();        for (List&lt;Integer&gt; path : res) &#123;            StringBuilder s = new StringBuilder();            for (var n : path) &#123;                s.append(&quot;-&gt;&quot;).append(n);            &#125;            ans.add(s.substring(2));        &#125;        return ans;    &#125;    private void dfs(TreeNode root, List&lt;Integer&gt; tmp) &#123;        if (root == null) &#123;            return;        &#125;        tmp.add(root.val);        if (root.left != null &amp;&amp; root.right != null) &#123;            List&lt;Integer&gt; tmp2 = new LinkedList&lt;&gt;(tmp);            res.add(tmp2);            dfs(root.left, tmp);            dfs(root.right, tmp2);        &#125; else if (root.left != null) &#123;            dfs(root.left, tmp);        &#125; else if (root.right != null) &#123;            dfs(root.right, tmp);        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：取决于分支个数\n","categories":["LeetCode"]},{"title":"LeetCode-283","url":"/2020/11/18/LeetCode-283/","content":"题目\n\n\n结果\n代码借助其它数组class Solution &#123;    public void moveZeroes(int[] nums) &#123;        int[] tmp = new int[nums.length];        int index = 0;        for (int num : nums) &#123;            if (num != 0) &#123;                tmp[index++] = num;            &#125;        &#125;        System.arraycopy(tmp, 0, nums, 0, nums.length);    &#125;&#125;\n\n原地操作class Solution &#123;    public void moveZeroes(int[] nums) &#123;        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;            if (nums[i] == 0) &#123;                moveZeroToEnd(nums, i);            &#125;        &#125;    &#125;    private void moveZeroToEnd(int[] nums, int index) &#123;        for (int i = index; i &lt; nums.length - 1; i++) &#123;            if (nums[i + 1] == 0) &#123;                return;            &#125; else &#123;                swap(nums, i, i + 1);            &#125;        &#125;    &#125;    private void swap(int[] nums, int a, int b) &#123;        int tmp = nums[a];        nums[a] = nums[b];        nums[b] = tmp;    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-292","url":"/2020/08/01/LeetCode-292/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean canWinNim(int n) &#123;        return n % 4 != 0;    &#125;&#125;\n\n复杂度时间复杂度：O（1）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-303","url":"/2021/03/05/LeetCode-303/","content":"题目\n\n\n\n结果\n\n代码直接进行一个动态的规划\ntype NumArray struct &#123;\tsums []int&#125;func Constructor(nums []int) NumArray &#123;\tsums := make([]int, len(nums)+1)\tfor i, v := range nums &#123;\t\tsums[i+1] += sums[i] + v\t&#125;\treturn NumArray&#123;sums&#125;&#125;func (this *NumArray) SumRange(i int, j int) int &#123;\treturn this.sums[j+1] - this.sums[i]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(i,j); */\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-304","url":"/2021/03/05/LeetCode-304/","content":"题目\n\n\n\n结果\n\n代码直接进行一波动态规划\ntype NumMatrix struct &#123;\tsums [][]int&#125;func Constructor(matrix [][]int) NumMatrix &#123;    if len(matrix) == 0 &#123;\t\treturn NumMatrix&#123;&#125;\t&#125;\tsums := make([][]int, len(matrix)+1)\tfor i := range sums &#123;\t\tsums[i] = make([]int, len(matrix[0])+1)\t&#125;\tfor i, nums := range matrix &#123;\t\tfor j, v := range nums &#123;\t\t\tsums[i+1][j+1] += sums[i][j+1] + sums[i+1][j] - sums[i][j] + v\t\t&#125;\t&#125;\tfmt.Println(sums)\treturn NumMatrix&#123;sums&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123;\treturn this.sums[row2+1][col2+1] - this.sums[row2+1][col1] - this.sums[row1][col2+1] + this.sums[row1][col1]&#125;/** * Your NumMatrix object will be instantiated and called as such: * obj := Constructor(matrix); * param_1 := obj.SumRegion(row1,col1,row2,col2); */\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-316","url":"/2020/12/20/LeetCode-316/","content":"题目\n\n\n结果\n代码StringBuilderclass Solution &#123;    public String removeDuplicateLetters(String s) &#123;        int[] cnt = new int[26];        for (int i = 0; i &lt; s.length(); i++) &#123;            cnt[s.charAt(i) - &#x27;a&#x27;]++;        &#125;        boolean[] in = new boolean[26];        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; s.length(); i++) &#123;            char ch = s.charAt(i);            if (!in[ch - &#x27;a&#x27;]) &#123;                while (!sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - 1) &gt; ch) &#123;                    if (cnt[sb.charAt(sb.length() - 1) - &#x27;a&#x27;] &gt; 0) &#123;                        in[sb.charAt(sb.length() - 1) - &#x27;a&#x27;] = false;                        sb.deleteCharAt(sb.length() - 1);                    &#125; else &#123;                        break;                    &#125;                &#125;                in[ch - &#x27;a&#x27;] = true;                sb.append(ch);            &#125;            cnt[ch - &#x27;a&#x27;]--;        &#125;        return sb.toString();    &#125;&#125;\n\nStackclass Solution &#123;    public String removeDuplicateLetters(String s) &#123;        int[] cnt = new int[26];        for (int i = 0; i &lt; s.length(); i++) &#123;            cnt[s.charAt(i) - &#x27;a&#x27;]++;        &#125;        boolean[] in = new boolean[26];        Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; s.length(); i++) &#123;            char ch = s.charAt(i);            if (!in[ch - &#x27;a&#x27;]) &#123;                while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; ch) &#123;                    if (cnt[stack.peek() - &#x27;a&#x27;] &gt; 0) &#123;                        in[stack.peek() - &#x27;a&#x27;] = false;                        stack.pop();                    &#125; else &#123;                        break;                    &#125;                &#125;                stack.push(ch);                in[ch - &#x27;a&#x27;] = true;            &#125;            cnt[ch - &#x27;a&#x27;]--;        &#125;                StringBuilder sb = new StringBuilder();        for (char ch : stack) &#123;            sb.append(ch);        &#125;        return sb.reverse().toString();    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-322 & LeetCode-518","url":"/2021/03/25/LeetCode-322%20&%20518/","content":"题目322. 零钱兑换518. 零钱兑换 II\n\n代码零钱兑换\ndp[i]表示可以凑成总金额i所需的最少的硬币个数，\nfunc coinChange(coins []int, amount int) int &#123;\tdp := make([]int, amount+1)\tfor i := 1; i &lt; len(dp); i++ &#123;\t\t// 极端情况是只有面值为1的硬币\t\tdp[i] = amount + 1\t&#125;\tfor i := 1; i &lt;= amount; i++ &#123;\t\tfor _, v := range coins &#123;\t\t\tif i-v &gt;= 0 &#123;\t\t\t\tdp[i] = min(dp[i], dp[i-v]+1)\t\t\t&#125;\t\t&#125;\t&#125;\tif dp[len(dp)-1] == amount+1 &#123;\t\treturn -1\t&#125;\treturn dp[len(dp)-1]&#125;func min(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn b\t&#125;\treturn a&#125;\n\n零钱兑换II\ndp[i]表示可以凑成总金额i的硬币组合数，参考零钱兑换，可以写出这样的代码：\nfor i := 1; i &lt; len(dp); i++ &#123;\t\tfor _, v := range coins &#123;\t\t\tif i-v &gt;= 0 &#123;\t\t\t\tif dp[i-v] == 0 &#123;\t\t\t\t\tdp[i]++\t\t\t\t&#125; else &#123;\t\t\t\t\tdp[i] += dp[i-v]\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\n\n但这样会有重复，比如coins &#x3D; [1,2,5]，计算dp[3]的时候，dp[3-1]+1和dp[3-2]+2的结果都被考虑了进去，所以需要另辟蹊径。\n可以先考虑coin=1的情况，算出dp[1]~dp[amount]，再考虑下一枚硬币，这样就不会有重复。\nfunc change(amount int, coins []int) int &#123;\tdp := make([]int, amount+1)\tdp[0] = 1\tfor _, coin := range coins &#123;\t\tfor i := coin; i &lt;= amount; i++ &#123;\t\t\tdp[i] += dp[i-coin]\t\t&#125;\t&#125;\treturn dp[amount]&#125;\n\n复杂度时间复杂度：O（len(coins)*amount）\n空间复杂度：O（amount）\n","categories":["LeetCode"]},{"title":"LeetCode-321","url":"/2020/12/02/LeetCode-321/","content":"题目\n\n\n结果\n\n代码这题很复杂（I think），但不是数学的那种复杂，我写了好久。\n这题可以大概划分为几个步骤，每个步骤可以当做一个小题来做了。\n\n从第一个数组里挑X个，第二个数组里挑Y个，有哪几种挑选方案？\n将两个数组拼接成一个数组，使得最终结果数值最大，元素在原数组中的相对位置不变。\n从一堆数组里选出数值最大的。\n\nclass Solution &#123;    public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123;        int x = 0, y = k;        List&lt;int[]&gt; list = new LinkedList&lt;&gt;();        for (int i = 0; i &lt;= k; i++, x++, y--) &#123;            if (x &lt;= nums1.length &amp;&amp; y &lt;= nums2.length) &#123;                list.add(merge(maxSubsequence(nums1, x), maxSubsequence(nums2, y)));            &#125;        &#125;        // 返回所有结果中最大的        return list.stream().max(this::cmp).get();    &#125;    // 返回给定数组长度为length的最大子序列    private int[] maxSubsequence(int[] nums, int k) &#123;        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();        // 选择的余地        int behind = nums.length - k;        for (int num : nums) &#123;            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num &amp;&amp; behind &gt; 0) &#123;                stack.pop();                behind--;            &#125;            if (stack.size() &lt; k) &#123;                stack.push(num);            &#125; else &#123;                behind--;            &#125;        &#125;        // 需要正向（从栈底到栈顶）遍历stack        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(stack);        Collections.reverse(list);        int[] ans = new int[k];        for (int i = 0; i &lt; list.size(); i++) &#123;            ans[i] = list.get(i);        &#125;        return ans;    &#125;    // 合并两个数组，使结果数值最大    private int[] merge(int[] nums1, int[] nums2) &#123;        int[] ans = new int[nums1.length + nums2.length];        int index1 = 0, index2 = 0;        for (int i = 0; i &lt; ans.length; i++) &#123;            // 先添加哪个数组的元素呢？（哪个大添加哪个，但如果一样大还需要考虑后面元素的大小）            int flag = cmp(nums1, index1, nums2, index2);            if (flag &lt; 0) &#123;                ans[i] = nums2[index2];                index2++;            &#125; else &#123;                ans[i] = nums1[index1];                index1++;            &#125;        &#125;        return ans;    &#125;    // 重载只为方便主函数调用    private int cmp(int[] nums1, int[] nums2) &#123;        return cmp(nums1, 0, nums2, 0);    &#125;    // 从指定位置开始逐位比较两个数组的大小    private int cmp(int[] nums1, int index1, int[] nums2, int index2) &#123;        // 因为cmp的递归，存在越界的情况        if (index1 &gt;= nums1.length) &#123;            if (index2 &gt;= nums2.length) &#123;                return 0;            &#125; else &#123;                return -1;            &#125;        &#125;        if (index2 &gt;= nums2.length) &#123;            if (index1 &gt;= nums2.length) &#123;                return 0;            &#125; else &#123;                return 1;            &#125;        &#125;        if (nums1[index1] &lt; nums2[index2]) &#123;            return -1;        &#125; else if (nums1[index1] == nums2[index2]) &#123;            // 递归            return cmp(nums1, index1 + 1, nums2, index2 + 1);        &#125; else &#123;            return 1;        &#125;    &#125;&#125;\n\n复杂度Have a good time!\n","categories":["LeetCode"]},{"title":"LeetCode-328","url":"/2020/11/12/LeetCode-328/","content":"题目\n\n\n结果\n代码新的链表再拼接class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        if (head == null) &#123;            return null;        &#125;        ListNode even = new ListNode(0), odd = new ListNode(0);        ListNode p1 = even,p2 = odd;        boolean flag = false;        ListNode tail = null;        while (head != null) &#123;            if (flag) &#123;                p2.next = new ListNode(head.val);                p2 = p2.next;            &#125; else &#123;                p1.next = new ListNode(head.val);                p1 = p1.next;            &#125;            if (head.next == null) &#123;                tail = p1;            &#125;            flag = !flag;            head = head.next;        &#125;        tail.next = odd.next;        return even.next;    &#125;&#125;\n\n原地算法class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        if (head == null) &#123;            return null;        &#125;        if (head.next == null) &#123;            return head;        &#125;        ListNode oddHead = head, evenHead = head.next;        ListNode p1 = oddHead, p2 = evenHead;        ListNode tail = null;        while (true) &#123;            if (p2.next == null) &#123;                tail = p1;                break;            &#125;            if (p2.next.next == null) &#123;                p1.next = p2.next;                p2.next = null;                tail = p1.next;                break;            &#125;            ListNode tmp = p2.next.next;            p1.next = p2.next;            p2.next = tmp;            p1 = p1.next;            p2 = p2.next;        &#125;        tail.next = evenHead;        return oddHead;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：第一种O（n），第二种O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-331","url":"/2021/03/12/LeetCode-331/","content":"题目331. 验证二叉树的前序序列化\n\n\n\n结果\n\n代码一个非空的节点必须要有两个子节点，根据这个关系，可以得出一个基于“期望节点数”算法：\n\n遇到数字 父节点的期望节点数减一，当前节点的期望节点数置为二。\n遇到空节点， 只需将父节点的期望节点数减一\n\n最后判断所有节点的期望节点数是否为0，这个过程可以用栈很好的模拟。\nfunc isValidSerialization(preorder string) bool &#123;   s := strings.Split(preorder, &quot;,&quot;)   stk := []int&#123;1&#125;   for _, v := range s &#123;      if len(stk) == 0 &#123;         return false      &#125;      stk[len(stk)-1]--      if stk[len(stk)-1] == 0 &#123;         // stack pop         stk = stk[:len(stk)-1]      &#125;      if unicode.IsDigit(str2rune(v)) &#123;         stk = append(stk, 2)      &#125;   &#125;   return len(stk) == 0&#125;func str2rune(s string) rune &#123;   return rune(s[0])&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-332","url":"/2020/08/27/LeetCode-332/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final List&lt;String&gt; ans = new LinkedList&lt;&gt;();    private final Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;&gt;();    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;        initMap(tickets);        dfs(&quot;JFK&quot;);        Collections.reverse(ans);        return ans;    &#125;    private void initMap(List&lt;List&lt;String&gt;&gt; tickets) &#123;        for (var pair : tickets) &#123;            String source = pair.get(0), destination = pair.get(1);            if (!map.containsKey(source)) &#123;                PriorityQueue&lt;String&gt; destinations = new PriorityQueue&lt;&gt;();                destinations.add(destination);                map.put(source, destinations);            &#125; else &#123;                map.get(source).add(destination);            &#125;        &#125;    &#125;    private void dfs(String pos) &#123;        while (map.containsKey(pos) &amp;&amp; map.get(pos).size() != 0) &#123;            String tmp = map.get(pos).poll();            dfs(tmp);        &#125;        ans.add(pos);    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-338","url":"/2021/03/05/LeetCode-338/","content":"题目\n\n\n\n结果\n\n代码func countBits(num int) []int &#123;\tbits := make([]int, num+1)\th := 0\tfor i := 1; i &lt;= num; i++ &#123;\t\tif i&amp;(i-1) == 0 &#123;\t\t\th = i\t\t&#125;\t\tbits[i] = 1 + bits[i-h]\t&#125;\treturn bits&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1），除了结果所需\n","categories":["LeetCode"]},{"title":"LeetCode-341","url":"/2021/03/23/LeetCode-341/","content":"题目341. 扁平化嵌套列表迭代器\n\n\n\n结果\n\n代码/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * type NestedInteger struct &#123; * &#125; * * // Return true if this NestedInteger holds a single integer, rather than a nested list. * func (this NestedInteger) IsInteger() bool &#123;&#125; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * // So before calling this method, you should have a check * func (this NestedInteger) GetInteger() int &#123;&#125; * * // Set this NestedInteger to hold a single integer. * func (n *NestedInteger) SetInteger(value int) &#123;&#125; * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * func (this *NestedInteger) Add(elem NestedInteger) &#123;&#125; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The list length is zero if this NestedInteger holds a single integer * // You can access NestedInteger&#x27;s List element directly if you want to modify it * func (this NestedInteger) GetList() []*NestedInteger &#123;&#125; */ type NestedIterator struct &#123;\tnums  []int\tindex int&#125;func Constructor(nestedList []*NestedInteger) *NestedIterator &#123;\tvar itr NestedIterator\tfor _, v := range nestedList &#123;\t\titr.nums = append(itr.nums, getNums(v)...)\t&#125;\treturn &amp;itr&#125;func getNums(integer *NestedInteger) (nums []int) &#123;\tif integer.IsInteger() &#123;\t\tnums = append(nums, integer.GetInteger())\t&#125; else &#123;\t\tfor _, v := range integer.GetList() &#123;\t\t\tnums = append(nums, getNums(v)...)\t\t&#125;\t&#125;\treturn nums&#125;func (this *NestedIterator) Next() int &#123;\tthis.index++\treturn this.nums[this.index-1]&#125;func (this *NestedIterator) HasNext() bool &#123;\tif this.index == len(this.nums) &#123;\t\treturn false\t&#125;\treturn true&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-343","url":"/2020/07/22/LeetCode-343/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int cuttingRope(int n) &#123;        if (n &lt;= 3) &#123;            return n - 1;        &#125;        int x = n / 3;        int b = n % 3;        if (b == 0) &#123;            return (int) Math.pow(3, x);        &#125; else if (b == 1) &#123;            return (int) Math.pow(3, x - 1) * 4;        &#125; else &#123;            return (int) Math.pow(3, x) * 2;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（1）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-344","url":"/2020/07/29/LeetCode-344/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public void reverseString(char[] s) &#123;        int left = 0, right = s.length - 1;        while (left &lt; right) &#123;            char tmp = s[left];            s[left] = s[right];            s[right] = tmp;            left++;            right--;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-347","url":"/2020/09/07/LeetCode-347/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int[] topKFrequent(int[] nums, int k) &#123;        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int num : nums) &#123;            set.add(num);            if (map.containsKey(num)) &#123;                map.put(num, map.get(num) + 1);            &#125; else &#123;                map.put(num, 1);            &#125;        &#125;        var res = set.stream().sorted((num1, num2) -&gt; Integer.compare(map.get(num2), map.get(num1))).collect(Collectors.toList());        int[] ans = new int[k];        for (int i = 0; i &lt; ans.length; i++) &#123;            ans[i] = res.get(i);        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O（nlogn）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-350","url":"/2020/07/13/LeetCode-350/","content":"LeetCode-350  两个数组的交集II题目\n\n结果\n\n\n\n代码class Solution &#123;    public int[] intersect(int[] nums1, int[] nums2) &#123;        // 对两个数组进行排序        Arrays.sort(nums1);        Arrays.sort(nums2);        // 由于不知道交集的长度，所以用list来存储结果        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        // 双指针        int i = 0, j = 0;        int len1 = nums1.length, len2 = nums2.length;        while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;            if (nums1[i] == nums2[j]) &#123;                list.add(nums1[i]);                i++;                j++;            &#125; else if (nums1[i] &lt; nums2[j]) &#123;                i++;            &#125; else &#123;                j++;            &#125;        &#125;        // 将list中的内容拷贝到数组中        int[] ans = new int[list.size()];        for (int k = 0; k &lt; ans.length; k++) &#123;            ans[k] = list.get(k);        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O(mlogm+nlogn)\n空间复杂度：O(min(m,n))\n","categories":["LeetCode"]},{"title":"LeetCode-35","url":"/2020/07/17/LeetCode-35/","content":"LeetCode -35  搜索插入位置题目\n\n\n\n结果\n\n代码线性搜索class Solution &#123;    public static int searchInsert(int[] nums, int target) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] &gt;= target) &#123;                return i;            &#125;        &#125;        return nums.length;    &#125;&#125;\n\n二分法class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        return searchInsert(nums, target, 0, nums.length - 1);    &#125;    public int searchInsert(int[] nums, int target, int begin, int end) &#123;        // 插入元素比所有元素都小或都大        if (nums[0] &gt; target) &#123;            return 0;        &#125; else if (nums[nums.length - 1] &lt; target) &#123;            return nums.length - 1;        &#125;                int middle = (begin + end) / 2;        if (middle == begin || middle == end) &#123;            if (nums[begin] == target) &#123;                return begin;            &#125; else &#123;                return end;            &#125;        &#125;                // 二分法        if (nums[middle] == target) &#123;            return middle;        &#125; else if (target &lt; nums[middle]) &#123;            return searchInsert(nums, target, begin, middle);        &#125; else &#123;            return searchInsert(nums, target, middle, end);        &#125;    &#125;&#125;\n\n时间复杂度线性搜索\n时间复杂度：O（n）\n\n空间复杂度：O（1）\n\n\n二分法\n时间复杂度：O（logn）\n\n空间复杂度：O（1）\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-36","url":"/2020/07/07/LeetCode-36/","content":"LeetCode-36 有效的数独题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isValidSudoku(char[][] board) &#123;        List&lt;Character&gt; list = new LinkedList&lt;&gt;();        // 查看每一行是否符合要求        for (char[] row : board) &#123;            for (char item : row) &#123;                if (list.contains(item)) &#123;                    return false;                &#125; else if (item != &#x27;.&#x27;) &#123;                    list.add(item);                &#125;            &#125;            list.clear();        &#125;        // 查看每一列是否符合要求        for (int i = 0; i &lt; 9; i++) &#123;            for (int j = 0; j &lt; 9; j++) &#123;                if (list.contains(board[j][i])) &#123;                    return false;                &#125; else if (board[j][i] != &#x27;.&#x27;) &#123;                    list.add(board[j][i]);                &#125;            &#125;            list.clear();        &#125;        // 查看九宫格是否符合要求        for (int row = 0; row &lt; 3; row++) &#123;            for (int col = 0; col &lt; 3; col++) &#123;                for (int i = 0; i &lt; 3; i++) &#123;                    for (int j = 0; j &lt; 3; j++) &#123;                        char num = board[row * 3 + i][col * 3 + j];                        if (list.contains(num)) &#123;                            return false;                        &#125; else if (num != &#x27;.&#x27;) &#123;                            list.add(num);                        &#125;                    &#125;                &#125;                list.clear();            &#125;        &#125;        return true;    &#125;&#125;\n\n因为数据量非常小，所以时间复杂度这块就无所谓了。\n","categories":["LeetCode"]},{"title":"LeetCode-376","url":"/2020/12/12/LeetCode-376/","content":"题目\n\n\n结果\n代码统计极值数量（边界也要考虑）\nclass Solution &#123;    public int wiggleMaxLength(int[] nums) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        // 去重        for (int num : nums) &#123;            if (list.isEmpty() || list.get(list.size() - 1) != num) &#123;                list.add(num);            &#125;        &#125;        if (list.size() &lt;= 2) &#123;            return list.size();        &#125;        // 极值数量        int cnt = 0;        for (int i = 0; i &lt; list.size(); i++) &#123;            if (isExtremum(list, i)) &#123;                cnt++;            &#125;        &#125;        return cnt;    &#125;    private boolean isExtremum(List&lt;Integer&gt; list, int index) &#123;        // 处于边界        if (index == 0) &#123;            return !list.get(1).equals(list.get(0));        &#125; else if (index == list.size() - 1) &#123;            return !list.get(list.size() - 1).equals(list.get(list.size() - 2));        &#125;        int left = list.get(index - 1);        int mid = list.get(index);        int right = list.get(index + 1);        if (mid &lt; left &amp;&amp; mid &lt; right) &#123;            return true;        &#125; else if (mid &gt; left &amp;&amp; mid &gt; right) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（N）\n空间复杂度：O（N）\n","categories":["LeetCode"]},{"title":"LeetCode-389","url":"/2020/12/18/LeetCode-389/","content":"题目\n\n\n结果计数法\n求和法\n异或法\n代码计数func findTheDifference(s string, t string) byte &#123;   cnt := [26]int&#123;&#125;   for _, ch := range s &#123;      cnt[ch-&#x27;a&#x27;]++   &#125;   for i := 0; ; i++ &#123;      ch := t[i]      cnt[ch-&#x27;a&#x27;]--      if cnt[ch-&#x27;a&#x27;] &lt; 0 &#123;         return ch      &#125;   &#125;&#125;\n\n求和func findTheDifference(s string, t string) byte &#123;   sum := 0   for _, ch := range s &#123;      sum -= int(ch)   &#125;   for _, ch := range t &#123;      sum += int(ch)   &#125;   return byte(sum)&#125;\n\n异或func findTheDifference(s string, t string) (x byte) &#123;   for i := range s &#123;      x ^= s[i] ^ t[i]   &#125;   return x ^ t[len(t)-1]&#125;\n\nfunc findTheDifference(s string, t string) (x byte) &#123;   for i := range s &#123;      x ^= s[i]   &#125;   for i := range t &#123;      x ^= t[i]   &#125;   return&#125;\n\n复杂度计数法时间复杂度：O（n）\n空间复杂度：O（n）\n求和法时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-39","url":"/2020/07/30/LeetCode-39/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        // 递归        search(candidates, target, new LinkedList&lt;Integer&gt;());        // 排序以便去重        ans.forEach(integers -&gt; integers.sort(Integer::compareTo));        // 去重并返回        return ans.stream().distinct().collect(Collectors.toList());    &#125;    private void search(int[] candidates, int target, List&lt;Integer&gt; tmp) &#123;        // 递归终止条件        if (target &lt; 0) &#123;            return;        &#125;        if (target == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));        &#125;        for (int num : candidates) &#123;            List&lt;Integer&gt; integerList = new LinkedList&lt;&gt;(tmp);            integerList.add(num);            search(candidates, target - num, integerList);        &#125;    &#125;&#125;\n\n复杂度时间复杂度：idk\n空间复杂度：idk\n","categories":["LeetCode"]},{"title":"LeetCode-392","url":"/2020/07/27/LeetCode-392/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isSubsequence(String s, String t) &#123;        int p1 = 0, p2 = 0;        while (p1 &lt; s.length() &amp;&amp; p2 &lt; t.length()) &#123;            if (s.charAt(p1) == t.charAt(p2)) &#123;                p1++;                p2++;            &#125; else &#123;                p2++;            &#125;        &#125;        return p1 == s.length();    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-395","url":"/2021/03/05/LeetCode-395/","content":"题目\n\n\n\n结果\n\n代码func longestSubstring(s string, k int) int &#123;\tif len(s) &lt; k &#123;\t\treturn 0\t&#125;\tvar cnt = make(map[rune]int)\tfor _, v := range s &#123;\t\tcnt[v]++\t&#125;\tvar pivot rune\tfor ch, v := range cnt &#123;\t\tif v &lt; k &#123;\t\t\tpivot = ch\t\t\tbreak\t\t&#125;\t&#125;\tif pivot == 0 &#123;\t\treturn len(s)\t&#125;\tvar l int\tfor _, ss := range strings.Split(s, string(pivot)) &#123;\t\tl = max(l, longestSubstring(ss, k))\t&#125;\treturn l&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;","categories":["LeetCode"]},{"title":"LeetCode-399","url":"/2021/03/17/LeetCode-399/","content":"题目399. 除法求值\n\n\n\n结果\n\n代码func calcEquation(equations [][]string, values []float64, queries [][]string) (ans []float64) &#123;\t// create UnionFind\tu := UnionFind&#123;make(map[string]string), make(map[string]float64)&#125;\tfor i, v := range equations &#123;\t\t// new node initialization\t\tif _, ok := u.parent[v[0]]; !ok &#123;\t\t\tu.parent[v[0]] = v[0]\t\t\tu.weight[v[0]] = 1\t\t&#125;\t\tif _, ok := u.parent[v[1]]; !ok &#123;\t\t\tu.parent[v[1]] = v[1]\t\t\tu.weight[v[1]] = 1\t\t&#125;\t\tu.union(v[0], v[1], values[i])\t&#125;\tfor _, v := range queries &#123;\t\t_, ok1 := u.parent[v[0]]\t\t_, ok2 := u.parent[v[1]]\t\tif !ok1 || !ok2 &#123;\t\t\tans = append(ans, -1)\t\t&#125; else &#123;\t\t\tans = append(ans, u.ratio(v[0], v[1]))\t\t&#125;\t&#125;\treturn&#125;type UnionFind struct &#123;\tparent map[string]string // whosyourdaddy\tweight map[string]float64&#125;func (u *UnionFind) union(x, y string, val float64) &#123;\trootX, rootY := u.find(x), u.find(y)\tif rootX == rootY &#123;\t\treturn\t&#125;\tu.parent[rootX] = rootY\tu.weight[rootX] = u.weight[y] * val / u.weight[x]&#125;// find id of the root nodefunc (u *UnionFind) find(x string) string &#123;\t// checkout if the current node is the root node\tif x != u.parent[x] &#123;\t\t// find root node recursively\t\torigin := u.parent[x]\t\tu.parent[x] = u.find(u.parent[x])\t\tu.weight[x] *= u.weight[origin]\t&#125;\treturn u.parent[x]&#125;func (u *UnionFind) ratio(x, y string) float64 &#123;\t// if two nodes are in the same tree set\trootX, rootY := u.find(x), u.find(y)\tif rootX == rootY &#123;\t\t// because tree height is 2\t\treturn u.weight[x] / u.weight[y]\t&#125;\treturn -1&#125;\n\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-40","url":"/2020/08/29/LeetCode-40/","content":"题目\n\n\n\n结果\n\n代码超时的代码class Solution &#123;    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;Integer&gt; candidateList = new LinkedList&lt;&gt;();        // 初始化candidateList        for (int num : candidates) &#123;            candidateList.add(num);        &#125;        // 递归产生结果        search(candidateList, target, new LinkedList&lt;&gt;());        // 排序以便去重        ans.forEach(integers -&gt; integers.sort(Integer::compareTo));        // 去重并返回        return ans.stream().distinct().collect(Collectors.toList());    &#125;    private void search(List&lt;Integer&gt; candidates, int target, List&lt;Integer&gt; tmp) &#123;        // 递归终止条件        if (target &lt; 0) &#123;            return;        &#125;        // 找到一个合适的序列        if (target == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));        &#125;        for (int num : candidates) &#123;            List&lt;Integer&gt; newTmp = new LinkedList&lt;&gt;(tmp);            newTmp.add(num);            // 不能取重复的元素            List&lt;Integer&gt; newCandidates = new LinkedList&lt;&gt;(candidates);            newCandidates.remove((Object) num);            // 递归            search(newCandidates, target - num, newTmp);        &#125;    &#125;&#125;\n\n上面的代码会超时，主要是因为在复制list的过程中消耗了过多的时间，可以改进一下，于是有了第二种算法。\n飘过的代码class Solution &#123;    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    private boolean[] flag;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        flag = new boolean[candidates.length];        List&lt;Integer&gt; candidateList = new LinkedList&lt;&gt;();        // 初始化candidateList        for (int num : candidates) &#123;            candidateList.add(num);        &#125;        // 递归产生结果        search(candidateList, target, new LinkedList&lt;&gt;());        // 排序以便去重        ans.forEach(integers -&gt; integers.sort(Integer::compareTo));        // 去重并返回        return ans.stream().distinct().collect(Collectors.toList());    &#125;    private void search(List&lt;Integer&gt; candidates, int target, List&lt;Integer&gt; tmp) &#123;        // 递归终止条件        if (target &lt; 0) &#123;            return;        &#125;        // 找到一个合适的序列        if (target == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));        &#125;        for (int i = 0; i &lt; candidates.size(); i++) &#123;            // 跳过使用过的数字            if (flag[i]) &#123;                continue;            &#125;            List&lt;Integer&gt; newTmp = new LinkedList&lt;&gt;(tmp);            newTmp.add(candidates.get(i));            // 标记            flag[i] = true;            // 递归            search(candidates, target - candidates.get(i), newTmp);            // 恢复            flag[i] = false;        &#125;    &#125;&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-404","url":"/2020/09/19/LeetCode-404/","content":"题目\n\n\n\n结果\n\n代码class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    private int sum = 0;    public int sumOfLeftLeaves(TreeNode root) &#123;        dfs(root);        return sum;    &#125;    private void dfs(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        if (haveLeftLeave(root)) &#123;            sum += root.left.val;        &#125;        dfs(root.left);        dfs(root.right);    &#125;    private boolean haveLeftLeave(TreeNode node) &#123;        if (node == null) &#123;            return false;        &#125;        return node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null;    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-402","url":"/2020/11/15/LeetCode-402/","content":"题目\n\n\n结果\n代码递归class Solution &#123;    public String removeKdigits(String num, int k) &#123;        for (int i = 0; i &lt; k; i++) &#123;            num = removeOneDigit(num).toString();        &#125;        if (allZero(num)) &#123;            return &quot;0&quot;;        &#125; else if (num.startsWith(&quot;0&quot;)) &#123;            return num.substring(indexOfZero(num));        &#125;        return num;    &#125;    private StringBuilder removeOneDigit(String num) &#123;        if (num.length() &lt; 2) &#123;            return new StringBuilder();        &#125;        if (num.charAt(0) &gt; num.charAt(1)) &#123;            return new StringBuilder(num.substring(1));        &#125; else &#123;            StringBuilder sb = new StringBuilder();            return sb.append(num.charAt(0)).append(removeOneDigit(num.substring(1)));        &#125;    &#125;    private boolean allZero(String num) &#123;        for (char ch : num.toCharArray()) &#123;            if (ch != &#x27;0&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int indexOfZero(String num) &#123;        for (int i = 0; i &lt; num.length(); i++) &#123;            if (num.charAt(i) != &#x27;0&#x27;) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;\n\n我觉得这种递归的代码写起来很好看，可是超时了，主要原因是遍历num高达k遍，其实遍历一遍就够了。\nclass Solution &#123;    public String removeKdigits(String num, int k) &#123;        Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; num.length(); i++) &#123;            while (!stack.isEmpty() &amp;&amp; k &gt; 0 &amp;&amp; stack.peek() &gt; num.charAt(i)) &#123;                stack.pop();                k--;            &#125;            stack.push(num.charAt(i));        &#125;        // 清理门户        for (int i = 0; i &lt; k; i++) &#123;            stack.pop();        &#125;        StringBuilder sb = new StringBuilder();        while (!stack.isEmpty()) &#123;            sb.append(stack.pollLast());        &#125;        String ans = sb.toString();        if (allZero(ans)) &#123;            return &quot;0&quot;;        &#125; else if (ans.startsWith(&quot;0&quot;)) &#123;            return ans.substring(indexOfZero(ans));        &#125;        return ans;    &#125;    private boolean allZero(String num) &#123;        for (char ch : num.toCharArray()) &#123;            if (ch != &#x27;0&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int indexOfZero(String num) &#123;        for (int i = 0; i &lt; num.length(); i++) &#123;            if (num.charAt(i) != &#x27;0&#x27;) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;\n\n复杂度时间复杂度：O（N），遍历一遍\n空间复杂度：O（N），stack\n","categories":["LeetCode"]},{"title":"LeetCode-406","url":"/2020/11/16/LeetCode-406/","content":"题目\n\n\n结果\n代码class Solution &#123;    public int[][] reconstructQueue(int[][] people) &#123;        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();        for (int[] pair : people) &#123;            list.add(List.of(pair[0], pair[1]));        &#125;        list.sort((o1, o2) -&gt; &#123;            if (o1.get(0).equals(o2.get(0))) &#123;                return Integer.compare(o2.get(1), o1.get(1));            &#125; else &#123;                return Integer.compare(o1.get(0), o2.get(0));            &#125;        &#125;);        boolean[] flag = new boolean[people.length];        for (var pair : list) &#123;            int index = getIndex(flag, pair.get(1));            people[index][0] = pair.get(0);            people[index][1] = pair.get(1);            flag[index] = true;        &#125;        return people;    &#125;    private int getIndex(boolean[] flag, int offset) &#123;        for (int i = 0; i &lt; flag.length; i++) &#123;            if (!flag[i]) &#123;                offset--;            &#125;            if (offset == -1) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-416","url":"/2020/10/11/LeetCode-416/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean canPartition(int[] nums) &#123;        // 特殊情况        if (nums.length &lt; 2) &#123;            return false;        &#125;        // 如果数组和是奇数，必不可能分成相等的两份        int sum = arraySum(nums);        if (sum % 2 != 0) &#123;            return false;        &#125;        int target = sum / 2;        // 如果最大值大于目标值，必不可能分成相等的两份        int max = maxInArray(nums);        if (max &gt; target) &#123;            return false;        &#125;        // dp[i][j]表示从0~i中选任意个数，是否存在和为j的组合        boolean[][] dp = new boolean[nums.length][target + 1];        // 初始情况        for (int i = 0; i &lt; dp.length; i++) &#123;            dp[i][0] = true;        &#125;        dp[0][nums[0]] = true;        // 根据条件转移方程dp        for (int i = 1; i &lt; dp.length; i++) &#123;            for (int j = 1; j &lt; dp[0].length; j++) &#123;                if (j &lt; nums[i]) &#123;                    dp[i][j] = dp[i - 1][j];                &#125; else &#123;                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];                &#125;            &#125;        &#125;        return dp[nums.length - 1][target];    &#125;    private int arraySum(int[] nums) &#123;        int sum = 0;        for (int num : nums) &#123;            sum += num;        &#125;        return sum;    &#125;    private int maxInArray(int[] nums) &#123;        int max = Integer.MIN_VALUE;        for (int num : nums) &#123;            max = Math.max(max, num);        &#125;        return max;    &#125;&#125;\n\n\n一个更慢的解法\n\nfunc canPartition(nums []int) bool &#123;\tif len(nums) &lt; 2 &#123;\t\treturn false\t&#125;\tsum := 0\tfor _, v := range nums &#123;\t\tsum += v\t&#125;\tif sum%2 != 0 &#123;\t\treturn false\t&#125;\tdp := make([]set, len(nums))\tfor i := 0; i &lt; len(nums); i++ &#123;\t\tdp[i] = make(map[int]bool)\t&#125;\tdp[0].add(nums[0])\tfor i := 1; i &lt; len(nums); i++ &#123;\t\tfor _, v := range dp[i-1].elements() &#123;\t\t\t//dp[i] = append(dp[i], v+nums[i], abs(v-nums[i]))\t\t\tdp[i].add(v + nums[i])\t\t\tdp[i].add(abs(v - nums[i]))\t\t&#125;\t\t// fmt.Println(dp)\t&#125;\tfor _, v := range dp[len(dp)-1].elements() &#123;\t\tif v == 0 &#123;\t\t\treturn true\t\t&#125;\t&#125;\treturn false&#125;func abs(x int) int &#123;\tif x &gt; 0 &#123;\t\treturn x\t&#125;\treturn -x&#125;type set map[int]boolfunc (s set) add(num int) &#123;\tif _, ok := s[num]; !ok &#123;\t\ts[num] = true\t&#125;&#125;func (s set) elements() (ans []int) &#123;\tfor i := range s &#123;\t\tans = append(ans, i)\t&#125;\treturn&#125;\n\n\nDP\n\nfunc canPartition(nums []int) bool &#123;\ts := sum(nums)\tif s%2 != 0 &#123;\t\treturn false\t&#125;    // 转换成背包问题\ttarget := s / 2\tfor _,v:=range nums&#123;\t\tif v &gt; target &#123;\t\t\treturn false\t\t&#125;\t&#125;\t// initialize\tdp := make([][]bool, len(nums))\tfor i := range dp &#123;\t\tdp[i] = make([]bool, target+1)\t\tdp[i][0] = true\t&#125;\tdp[0][nums[0]] = true\t// dp\tfor i := 1; i &lt; len(dp); i++ &#123;\t\tfor j := 1; j &lt;= target; j++ &#123;\t\t\tdp[i][j] = dp[i-1][j] || (j-nums[i] &gt;= 0 &amp;&amp; dp[i-1][j-nums[i]])\t\t&#125;\t&#125;\treturn dp[len(dp)-1][len(dp[0])-1]&#125;func sum(nums []int) (ans int) &#123;\tfor _, v := range nums &#123;\t\tans += v\t&#125;\treturn&#125;\n\n\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n²）\n","categories":["LeetCode"],"tags":["LeetCode","dp","knapsack","背包"]},{"title":"LeetCode-452","url":"/2020/11/23/LeetCode-452/","content":"题目\n\n\n结果\n代码超时算法（不看也罢）class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        List&lt;List&lt;Integer&gt;&gt; intervals = new ArrayList&lt;&gt;();        for (var xy : points) &#123;            intervals.add(List.of(xy[0], xy[1]));        &#125;        int arrows = 0;        while (!intervals.isEmpty()) &#123;            var intersection = intersection(intervals, intervals.get(0));            if (intersection != null) &#123;                intervals.remove((int) intersection.get(2));                intervals.remove(0);                intervals.add(List.of(intersection.get(0), intersection.get(1)));            &#125; else &#123;                intervals.remove(0);                arrows++;            &#125;        &#125;        return arrows;    &#125;    private List&lt;Integer&gt; intersection(List&lt;List&lt;Integer&gt;&gt; intervals, List&lt;Integer&gt; range) &#123;        if (intervals.size() == 1) &#123;            return null;        &#125;        for (int i = 1; i &lt; intervals.size(); i++) &#123;            var interval = intervals.get(i);            if (interval.get(0).equals(range.get(0))) &#123;                return List.of(interval.get(0), Math.min(interval.get(1), range.get(1)), i);            &#125;            if (interval.get(1).equals(range.get(1))) &#123;                return List.of(Math.max(interval.get(0), range.get(0)), range.get(1), i);            &#125;            if (interval.get(1) &lt; range.get(0) || range.get(1) &lt; interval.get(0)) &#123;                continue;            &#125; else &#123;                return List.of(Math.max(interval.get(0), range.get(0)), Math.min(interval.get(1), range.get(1)), i);            &#125;        &#125;        return null;    &#125;&#125;\n\n龟速算法class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        List&lt;List&lt;Integer&gt;&gt; intervals = new ArrayList&lt;&gt;();        for (var xy : points) &#123;            intervals.add(List.of(xy[0], xy[1]));        &#125;        intervals.sort(Comparator.comparingInt(interval -&gt; interval.get(1)));        int arrows = 0;        while (!intervals.isEmpty()) &#123;            shoot(intervals, intervals.get(0).get(1));            arrows++;        &#125;        return arrows;    &#125;    private void shoot(List&lt;List&lt;Integer&gt;&gt; intervals, int num) &#123;        List&lt;Integer&gt; targets = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; intervals.size(); i++) &#123;            var interval = intervals.get(i);            if (num &gt;= interval.get(0) &amp;&amp; num &lt;= interval.get(1)) &#123;                targets.add(i);            &#125;        &#125;        for (int i = targets.size() - 1; i &gt;= 0; i--) &#123;            intervals.remove((int) targets.get(i));        &#125;    &#125;&#125;\n\n极速算法class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        if (points.length == 0) &#123;            return 0;        &#125;        Arrays.sort(points, Comparator.comparingInt(point -&gt; point[1]));        int pos = points[0][1];        int arrows = 1;        for (var xy : points) &#123;            if (xy[0] &gt; pos) &#123;                arrows++;                pos = xy[1];            &#125;        &#125;        return arrows;    &#125;&#125;\n\n算法思路：贪心算法。\n数组中有若干个区间——[a1,b1],[a2,b2]……[an,bn]，每次选择Min（b1~bn）这个点，删除包含这个点的区间，并且arrows+1，最终得到的arrows就是结果。\n为什么Min(b1~bn)是最优解？可以逆向想一下，往左移动可能会减少捅破的气球，往右则这个区间的气球不能被捅到。\n复杂度时间复杂度：O（nlogn）\n空间复杂度：O（logn），Arrays.sort的空间复杂度\n","categories":["LeetCode"]},{"title":"LeetCode-454","url":"/2020/11/27/LeetCode-454/","content":"题目\n\n\n结果\n代码暴力法（超时）class Solution &#123;    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;        int cnt = 0;        for (int a : A) &#123;            for (int b : B) &#123;                for (int c : C) &#123;                    for (int d : D) &#123;                        if (a + b + c + d == 0) &#123;                            cnt++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;\n\n暴力法改进（超时）class Solution &#123;    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;        if (A.length == 0) &#123;            return 0;        &#125;        int cnt = 0;        Arrays.sort(A);        Arrays.sort(B);        Arrays.sort(C);        Arrays.sort(D);        int aMin = A[0], bMin = B[0], cMin = C[0], dMin = D[0];        int aMax = A[A.length - 1], bMax = B[B.length - 1], cMax = C[C.length - 1], dMax = D[D.length - 1];        for (int a : A) &#123;            if (aMax + bMax + cMax + dMax &lt; 0 || aMin + bMin + cMin + dMin &gt; 0) &#123;                break;            &#125;            if (a + bMin + cMin + dMin &gt; 0) &#123;                break;            &#125;            for (int b : B) &#123;                if (a + bMax + cMax + dMax &lt; 0 || a + bMin + cMin + dMin &gt; 0) &#123;                    break;                &#125;                if (a + b + cMin + dMin &gt; 0) &#123;                    break;                &#125;                for (int c : C) &#123;                    if (a + b + cMax + dMax &lt; 0 || a + b + cMin + dMin &gt; 0) &#123;                        break;                    &#125;                    if (a + b + c + dMin &gt; 0) &#123;                        break;                    &#125;                    for (int d : D) &#123;                        if (a + b + c + dMax &lt; 0 || a + b + c + dMin &gt; 0) &#123;                            break;                        &#125;                        if (a + b + c + d == 0) &#123;                            cnt++;                        &#125;                        if (a + b + c + d &gt; 0) &#123;                            break;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;\n\n借助HashMapclass Solution &#123;    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;        int cnt = 0;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int a : A) &#123;            for (int b : B) &#123;                map.put(a + b, map.getOrDefault(a + b, 0) + 1);            &#125;        &#125;        for (int c : C) &#123;            for (int d : D) &#123;                if (map.containsKey(-c - d)) &#123;                    cnt += map.get(-c - d);                &#125;            &#125;        &#125;        return cnt;    &#125;&#125;\n\n空间换时间。\n复杂度时间复杂度：O（N²）\n空间复杂度：O（N²）\n","categories":["LeetCode"]},{"title":"LeetCode-415","url":"/2020/08/03/LeetCode-415/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public String addStrings(String num1, String num2) &#123;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(10);        char num = &#x27;0&#x27;;        for (int i = 0; i &lt; 10; i++) &#123;            map.put(num, i);            num++;        &#125;        StringBuilder ans = new StringBuilder();        int p1 = num1.length() - 1, p2 = num2.length() - 1;        int carry = 0;        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;            int tmp;            if (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;                tmp = map.get(num1.charAt(p1)) + map.get(num2.charAt(p2));            &#125; else if (p1 &lt; 0) &#123;                tmp = map.get(num2.charAt(p2));            &#125;else&#123;                tmp = map.get(num1.charAt(p1));            &#125;            if (carry != 0) &#123;                tmp += 1;                carry = 0;            &#125;            if (tmp &gt;= 10) &#123;                tmp -= 10;                carry = 1;            &#125;            ans.append(tmp);            p1--;            p2--;        &#125;        if (carry != 0) &#123;            ans.append(carry);        &#125;        return ans.reverse().toString();    &#125;&#125;\n\n复杂度时间复杂度：O（max（m，n））\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-456","url":"/2021/03/24/LeetCode-456/","content":"题目456. 132 模式\n\n\n\n结果\n\n代码func find132pattern(nums []int) bool &#123;\tif len(nums) &lt; 3 &#123;\t\treturn false\t&#125;\tfor i := 1; i &lt; len(nums); i++ &#123;\t\tm1 := min(nums[:i])\t\tm2, err := max(nums[i+1:], nums[i])\t\tif len(nums[i+1:]) == 0 &#123;\t\t\tcontinue\t\t&#125;\t\tif err != nil &#123;\t\t\tcontinue\t\t&#125;\t\tif m1 &lt; m2 &amp;&amp; m2 &lt; nums[i] &#123;\t\t\treturn true\t\t&#125;\t&#125;\treturn false&#125;func max(nums []int, threshold int) (m int, err error) &#123;\tfor i, v := range nums &#123;\t\tif i == 0 || (v &gt; m &amp;&amp; v &lt; threshold) &#123;\t\t\tm = v\t\t&#125;\t&#125;\tif m &gt;= threshold &#123;\t\treturn 0, errors.New(&quot;not found&quot;)\t&#125;\treturn m, nil&#125;func min(nums []int) (m int) &#123;\tfor i, v := range nums &#123;\t\tif i == 0 || v &lt; m &#123;\t\t\tm = v\t\t&#125;\t&#125;\treturn&#125;\n\n时间仓促，有时间再想想复杂度更低的解法。\n复杂度时间复杂度：O（n²）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-46","url":"/2020/07/08/LeetCode-46/","content":"LeetCode-46 全排列题目\n\n\n\n结果\n\n代码class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        // 最终答案        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        // 特殊情况        if (nums.length == 0) &#123;            return ans;        &#125;        // 记录遍历过的元素        List&lt;Integer&gt; path = new LinkedList&lt;&gt;();        // 记录nums中使用过的元素        boolean[] used = new boolean[nums.length];        // 深度优先遍历加回溯        dfs(nums, path, 0, used, ans);        return ans;    &#125;    private void dfs(int[] nums, List&lt;Integer&gt; path, int depth, boolean[] used, List&lt;List&lt;Integer&gt;&gt; ans) &#123;        // 递归终止条件        if (depth == nums.length) &#123;            // 需要new一个path，path本身是个引用，之后还要重复利用            ans.add(new LinkedList&lt;&gt;(path));            return;        &#125;        // 创建树的分支（心中有树）        for (int i = 0; i &lt; nums.length; i++) &#123;            if (!used[i]) &#123;                path.add(nums[i]);                used[i] = true;                dfs(nums, path, depth + 1, used, ans);                // 回溯                path.remove(path.size() - 1);                used[i] = false;            &#125;        &#125;    &#125;&#125;\n\n算法深度优先遍历深度优先遍历不是对树的算法吗？不，心中有树就可以。\n\n\n和一般的深度优先遍历不同的是，这个DFS的作用对象不是树，但我们可以想象出一颗树，这个树的结构很简单，它罗列出了所有可能的情况。\n我们递归地深度遍历这棵不存在的树，用path记录遍历过节点的元素，用used数组记录已经遍历过的节点，遍历到叶子节点时（nums.length &#x3D;&#x3D; depth）就停止递归，并回溯（清除当前状态：used，path，depth）。\n","categories":["LeetCode"]},{"title":"LeetCode-463","url":"/2020/10/30/LeetCode-463/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int islandPerimeter(int[][] grid) &#123;        int perimeter = 0;        for (int i = 0; i &lt; grid.length; i++) &#123;            for (int j = 0; j &lt; grid[0].length; j++) &#123;                if (grid[i][j] == 1) &#123;                    perimeter += perimeter(grid, i, j);                &#125;            &#125;        &#125;        return perimeter;    &#125;    private int perimeter(int[][] grid, int row, int col) &#123;        int perimeter = 4;        if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] == 1) &#123;            perimeter--;        &#125;        if (row + 1 &lt; grid.length &amp;&amp; grid[row + 1][col] == 1) &#123;            perimeter--;        &#125;        if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] == 1) &#123;            perimeter--;        &#125;        if (col + 1 &lt; grid[0].length &amp;&amp; grid[row][col + 1] == 1) &#123;            perimeter--;        &#125;        return perimeter;    &#125;&#125;\n\n复杂度时间复杂度：O（m*n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-474","url":"/2021/03/25/LeetCode-474/","content":"题目474. 一和零\n\n\n\n结果\n\n代码func findMaxForm(strs []string, m int, n int) int &#123;\tdp := make([][]int, m+1)\tfor i := range dp &#123;\t\tdp[i] = make([]int, n+1)\t&#125;\tfor _, str := range strs &#123;\t\tzero, one := cnt(str)\t\t// 为什么从后往前：旧的dp[i][j]存储着截止上一次（还没有当前资源）的最佳值，这个递推公式描述的是有当前资源和没有当前资源两种情况的关系\t\tfor i := m; i &gt;= zero; i-- &#123;\t\t\tfor j := n; j &gt;= one; j-- &#123;\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-zero][j-one]+1)\t\t\t&#125;\t\t&#125;\t&#125;\treturn dp[len(dp)-1][len(dp[0])-1]&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;func cnt(s string) (zero, one int) &#123;\tfor _, v := range s &#123;\t\tif v == &#x27;0&#x27; &#123;\t\t\tzero++\t\t&#125; else &#123;\t\t\tone++\t\t&#125;\t&#125;\treturn&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-47","url":"/2020/09/09/LeetCode-47/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    // Save the final answer    private final List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    // Check out If the num has been used before    private boolean[] flag;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        // Special case        if (nums.length == 0) &#123;            return ans;        &#125;        // Initialize the flag array        flag = new boolean[nums.length];        dfs(nums, new ArrayList&lt;&gt;());        // Remove the duplicate and return the final answer        return ans.stream().distinct().collect(Collectors.toList());    &#125;    private void dfs(int[] nums, List&lt;Integer&gt; tmp) &#123;        // Time to stop recursive call        if (tmp.size() == nums.length) &#123;            ans.add(tmp);            return;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (!flag[i]) &#123;                flag[i] = true;                List&lt;Integer&gt; newTmp = new ArrayList&lt;&gt;(tmp);                newTmp.add(nums[i]);                // Recursive call                dfs(nums, newTmp);                flag[i] = false;            &#125;        &#125;    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-48","url":"/2020/09/15/LeetCode-48/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public void rotate(int[][] matrix) &#123;        int n = matrix.length;        // Transposed matrix        for (int i = 0; i &lt; n; i++) &#123;            for (int j = i; j &lt; n; j++) &#123;                int tmp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = tmp;            &#125;        &#125;        // Reverse each line        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n / 2; j++) &#123;                int tmp = matrix[i][j];                matrix[i][j] = matrix[i][n - j - 1];                matrix[i][n - j - 1] = tmp;            &#125;        &#125;    &#125;&#125;\n\nfunc rotate(matrix [][]int) &#123;   length := len(matrix)   // 转置矩阵   for i := 0; i &lt; length; i++ &#123;      for j := i; j &lt; length; j++ &#123;         swap(matrix, i, j, j, i)      &#125;   &#125;   // 翻转每一行   for i := 0; i &lt; length; i++ &#123;      for j := 0; j &lt; length/2; j++ &#123;         swap(matrix, i, j, i, length-1-j)      &#125;   &#125;&#125;func swap(matrix [][]int, i1 int, j1 int, i2 int, j2 int) &#123;   tmp := matrix[i1][j1]   matrix[i1][j1] = matrix[i2][j2]   matrix[i2][j2] = tmp&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（1），原地排序\n","categories":["LeetCode"]},{"title":"LeetCode-486","url":"/2020/09/01/LeetCode-486/","content":"题目\n\n\n\n结果递归\n\nDP\n\n代码递归class Solution &#123;    public boolean PredictTheWinner(int[] nums) &#123;        return predictTheWinner(nums, 0, nums.length - 1, 1) &gt;= 0;    &#125;    private int predictTheWinner(int[] nums, int start, int end, int flag) &#123;        if (start == end) &#123;            return nums[start] * flag;        &#125;        int left = predictTheWinner(nums, start + 1, end, -flag) + nums[start] * flag;        int right = predictTheWinner(nums, start, end - 1, -flag) + nums[end] * flag;        if (flag == 1) &#123;            return Math.max(left, right);        &#125; else &#123;            return Math.min(left, right);        &#125;    &#125;&#125;\n\nDPclass Solution &#123;    public boolean PredictTheWinner(int[] nums) &#123;        int[][] dp = new int[nums.length][nums.length];        for (int i = 0; i &lt; nums.length; i++) &#123;            dp[i][i] = nums[i];        &#125;        for (int i = nums.length - 2; i &gt;= 0; i--) &#123;            for (int j = i + 1; j &lt; nums.length; j++) &#123;                dp[i][j] = Math.max(-dp[i + 1][j] + nums[i], -dp[i][j - 1] + nums[j]);            &#125;        &#125;        return dp[0][nums.length - 1] &gt;= 0;    &#125;&#125;\n\n复杂度递归时间复杂度：O（2^n）\n空间复杂度：O（n），取决于递归的层数。\nDP时间复杂度：O（n²）\n空间复杂度：O（n²）\n","categories":["LeetCode"]},{"title":"LeetCode-49","url":"/2020/09/17/LeetCode-49/","content":"题目\n\n\n\n结果\n代码class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        List&lt;List&lt;String&gt;&gt; ans = new LinkedList&lt;&gt;();        for (String str : strs) &#123;            insert(ans, str);        &#125;        return ans;    &#125;    // 判断两个字符串是否为 &#x27;字母异位词&#x27;    private boolean isSame(String s1, String s2) &#123;        if (s1.length() != s2.length()) &#123;            return false;        &#125;        char[] ch1 = s1.toCharArray();        char[] ch2 = s2.toCharArray();        Arrays.sort(ch1);        Arrays.sort(ch2);        for (int i = 0; i &lt; s1.length(); i++) &#123;            if (ch1[i] != ch2[i]) &#123;                return false;            &#125;        &#125;        return true;    &#125;    // 将s插入到ans合适的位置    private void insert(List&lt;List&lt;String&gt;&gt; ans, String s) &#123;        boolean flag = false;        for (List&lt;String&gt; list : ans) &#123;            if (isSame(list.get(0), s)) &#123;                list.add(s);                flag = true;                break;            &#125;        &#125;        if (!flag) &#123;            List&lt;String&gt; list = new LinkedList&lt;&gt;();            list.add(s);            ans.add(list);        &#125;    &#125;&#125;\n\n12月又写了一遍class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        List&lt;List&lt;String&gt;&gt; ans = new LinkedList&lt;&gt;();        for (String str : strs) &#123;            insert(ans, str);        &#125;        return ans;    &#125;    private void insert(List&lt;List&lt;String&gt;&gt; ans, String word) &#123;        boolean flag = false;        for (var group : ans) &#123;            if (group.isEmpty()) &#123;                continue;            &#125;            String head = group.get(0);            if (anagram(head, word)) &#123;                flag = true;                group.add(word);                break;            &#125;        &#125;        if (!flag) &#123;            ans.add(new LinkedList&lt;&gt;(List.of(word)));        &#125;    &#125;    private boolean anagram(String word1, String word2) &#123;        if (word1.length() != word2.length()) &#123;            return false;        &#125;        int[] count1 = new int[26];        int[] count2 = new int[26];        for (int i = 0; i &lt; word1.length(); i++) &#123;            count1[word1.charAt(i) - &#x27;a&#x27;]++;            count2[word2.charAt(i) - &#x27;a&#x27;]++;        &#125;        for (int i = 0; i &lt; 26; i++) &#123;            if (count1[i] != count2[i]) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-493","url":"/2020/11/28/LeetCode-493/","content":"题目\n\n\n结果\n代码递归+归并排序class Solution &#123;    public int reversePairs(int[] nums) &#123;        if (nums.length == 0) &#123;            return 0;        &#125;        return reversePairs(nums, 0, nums.length - 1);    &#125;    private int reversePairs(int[] nums, int left, int right) &#123;        if (left == right) &#123;            return 0;        &#125;        int mid = (left + right) / 2;        int ans = reversePairs(nums, left, mid) + reversePairs(nums, mid + 1, right);        int i = left, j = mid + 1;        while (i &lt;= mid) &#123;            while (j &lt;= right &amp;&amp; (long) nums[i] &gt; (long) nums[j] * 2) &#123;                j++;            &#125;            ans += j - mid - 1;            i++;        &#125;        // 归并排序        int[] sorted = new int[right - left + 1];        i = left;        j = mid + 1;        int k = 0;        while (i &lt;= mid || j &lt;= right) &#123; // 直到一方弹尽粮绝            if (i &gt; mid) &#123; // 左边率先弹尽粮绝                sorted[k++] = nums[j++];            &#125; else if (j &gt; right) &#123; // 右边率先弹尽粮绝                sorted[k++] = nums[i++];            &#125; else &#123;                if (nums[i] &lt; nums[j]) &#123;                    sorted[k++] = nums[i++];                &#125; else &#123;                    sorted[k++] = nums[j++];                &#125;            &#125;        &#125;        for (i = 0; i &lt; sorted.length; i++) &#123;            nums[left + i] = sorted[i];        &#125;        return ans;    &#125;&#125;\n\n递归+快排class Solution &#123;    public int reversePairs(int[] nums) &#123;        if (nums.length == 0) &#123;            return 0;        &#125;        return reversePairs(nums, 0, nums.length - 1);    &#125;    private int reversePairs(int[] nums, int left, int right) &#123;        if (left == right) &#123;            return 0;        &#125;        int mid = (left + right) / 2;        int ans = reversePairs(nums, left, mid) + reversePairs(nums, mid + 1, right);        int i = left, j = mid + 1;        while (i &lt;= mid) &#123;            while (j &lt;= right &amp;&amp; (long) nums[i] &gt; (long) nums[j] * 2) &#123;                j++;            &#125;            ans += j - mid - 1;            i++;        &#125;        // 快排        Arrays.sort(nums, left, right + 1);        return ans;    &#125;&#125;\n\n凭什么归并排序要比快排快上一些呢？\n这跟待排序数组的特点有关，待排序数组等分成两个数组，两个数组各自有序。\n而数组这种特点很适合归并排序，两个数组各自有序，可以直接归并。\n复杂度时间复杂度：O（N log N）\n空间复杂度：O（N），归并。O（log N），快排。\n","categories":["LeetCode"]},{"title":"LeetCode-501","url":"/2020/09/24/LeetCode-501/","content":"题目\n\n\n\n结果\n\n代码标准版class Solution &#123;    private final Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    public int[] findMode(TreeNode root) &#123;        dfs(root);        int max = Integer.MIN_VALUE;        for (int key : map.keySet()) &#123;            max = Math.max(max, map.get(key));        &#125;        List&lt;Integer&gt; keys = new ArrayList&lt;&gt;();        for (int key : map.keySet()) &#123;            if (map.get(key) == max) &#123;                keys.add(key);            &#125;        &#125;        int[] ans = new int[keys.size()];        for (int i = 0; i &lt; ans.length; i++) &#123;            ans[i] = keys.get(i);        &#125;        return ans;    &#125;    private void dfs(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        if (map.containsKey(root.val)) &#123;            map.put(root.val, map.get(root.val) + 1);        &#125; else &#123;            map.put(root.val, 1);        &#125;        dfs(root.left);        dfs(root.right);    &#125;&#125;\n\n进阶版class Solution &#123;    private int maxNum = Integer.MIN_VALUE;    private int currentNum = Integer.MIN_VALUE;    private int count = 0;    private final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    public int[] findMode(TreeNode root) &#123;        // 计算众数出现的次数        dfs1(root);        // 重置        currentNum = Integer.MIN_VALUE;        count = 0;        // 根据已经求得的众数出现的次数判断是否为众数        dfs2(root);        // 把list转为int[]        int[] ans = new int[list.size()];        for (int i = 0; i &lt; ans.length; i++) &#123;            ans[i] = list.get(i);        &#125;        return ans;    &#125;        // 计算众数出现的次数    private void dfs1(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        dfs1(root.left);        if (currentNum == Integer.MIN_VALUE) &#123;            currentNum = root.val;            count++;            maxNum = Math.max(maxNum, count);        &#125; else if (currentNum != root.val) &#123;            currentNum = root.val;            count = 1;            maxNum = Math.max(maxNum, count);        &#125; else &#123;            count++;            maxNum = Math.max(maxNum, count);        &#125;        dfs1(root.right);    &#125;    // 根据已经求得的众数出现的次数判断是否为众数    private void dfs2(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        dfs2(root.left);        if (currentNum == Integer.MIN_VALUE) &#123;            currentNum = root.val;            count++;        &#125; else if (currentNum != root.val) &#123;            currentNum = root.val;            count = 1;        &#125; else &#123;            count++;        &#125;        if (count == maxNum) &#123;            list.add(currentNum);        &#125;        dfs2(root.right);    &#125;&#125;\n\n复杂度时间复杂度：O（n），n为节点个数\n空间复杂度：O（1），递归的栈开销不考虑在内。\n","categories":["LeetCode"]},{"title":"LeetCode-509","url":"/2021/03/17/LeetCode-509/","content":"题目509. 斐波那契数\n\n\n\n结果\n\n代码func fib(n int) int &#123;\tif n == 0 || n == 1 &#123;\t\treturn n\t&#125;\treturn fib(n-1) + fib(n-2)&#125;","categories":["LeetCode"]},{"title":"LeetCode-503","url":"/2021/03/07/LeetCode-503/","content":"题目\n\n\n\n结果\n\n代码func nextGreaterElements(nums []int) []int &#123;   if len(nums) == 0 &#123;      return []int&#123;&#125;   &#125;   _max := nums[0]   for _, v := range nums &#123;      _max = max(_max, v)   &#125;   ans := make([]int, 0, len(nums))   for i, v := range nums &#123;      if v == _max &#123;         ans = append(ans, -1)         continue      &#125;      for j := i; ; &#123;         if nums[j] &gt; v &#123;            ans = append(ans, nums[j])            break         &#125;         j++         if j &gt;= len(nums) &#123;            j = 0         &#125;      &#125;   &#125;   return ans&#125;func max(x, y int) int &#123;   if x &gt; y &#123;      return x   &#125;   return y&#125;\n\n复杂度时间复杂度：O（N）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-514","url":"/2020/11/11/LeetCode-514/","content":"题目\n\n\n结果代码究极爆内存法\nclass Status &#123;    public static String ring;    public static String key;    private final int steps;    private final int position;    private final int index;    private final char target;    // 用于根节点的构造函数    public Status(String ring, String key) &#123;        Status.ring = ring;        Status.key = key;        this.steps = 0;        this.position = 0;        this.index = 0;        this.target = key.charAt(0);    &#125;    // 用于一般节点的构造函数    public Status(int steps, int position, int index) &#123;        this.steps = steps;        this.position = position;        this.index = index;        if (this.index == key.length()) &#123;            this.target = &#x27;!&#x27;;        &#125; else &#123;            this.target = key.charAt(index);        &#125;    &#125;    public Status clockWise() &#123;        // 如果走到了路的尽头        if (this.target == &#x27;!&#x27;) &#123;            return null;        &#125;        // 顺时针寻找目标        int i = position;        int step = 0;        do &#123;            if (i == ring.length()) &#123;                i -= ring.length();            &#125;            if (ring.charAt(i) == this.target) &#123;                return new Status(this.steps + step + 1, i, index + 1);            &#125;            i++;            step++;        &#125; while (i != position);        throw new RuntimeException(&quot;404 Not found&quot;);    &#125;    public Status counterClockWise() &#123;        // 如果走到了路的尽头        if (this.target == &#x27;!&#x27;) &#123;            return null;        &#125;        // 逆时针寻找目标        int i = position;        int step = 0;        do &#123;            if (i == -1) &#123;                i += ring.length();            &#125;            if (ring.charAt(i) == this.target) &#123;                return new Status(this.steps + step + 1, i, index + 1);            &#125;            i--;            step++;        &#125; while (i != position);        throw new RuntimeException(&quot;404 Not found&quot;);    &#125;    public char getTarget() &#123;        return this.target;    &#125;    public int getSteps() &#123;        return steps;    &#125;&#125;\n\n超时了，不过我感觉思路是对的，也对了很多测试样例。今天懒得再动脑了，择日再做这道题吧。\n复杂度时间复杂度：O（）\n空间复杂度：O（）\n","categories":["LeetCode"]},{"title":"LeetCode-538","url":"/2020/09/21/LeetCode-538/","content":"题目\n\n\n\n结果\n\n代码class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    private int sum = 0;    public TreeNode convertBST(TreeNode root) &#123;        rrl(root);        return root;    &#125;    private void rrl(TreeNode node) &#123;        if (node == null) &#123;            return;        &#125;        rrl(node.right);        sum += node.val;        node.val += sum - node.val;        rrl(node.left);    &#125;&#125;\n\n复杂度时间复杂度：O（n），n为节点个数\n空间复杂度：O（n），最坏情况下，数呈现链表状，有n层递归。\n","categories":["LeetCode"]},{"title":"LeetCode-54","url":"/2020/09/03/LeetCode-54/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final int RIGHT = 0, DOWN = 1, LEFT = 2, UP = 3;    private int direction = 0;    private boolean[][] flag;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        if (matrix.length == 0) &#123;            return ans;        &#125;        flag = new boolean[matrix.length][matrix[0].length];        int i = 0, j = 0;        while (true) &#123;            flag[i][j] = true;            ans.add(matrix[i][j]);            if (!reachable(matrix, i, j)) &#123;                direction = (direction + 1) % 4;                if (!reachable(matrix, i, j)) &#123;                    break;                &#125;            &#125;            if (direction == RIGHT) &#123;                j++;            &#125; else if (direction == DOWN) &#123;                i++;            &#125; else if (direction == LEFT) &#123;                j--;            &#125; else if (direction == UP) &#123;                i--;            &#125;        &#125;        return ans;    &#125;    private boolean reachable(int[][] matrix, int row, int col) &#123;        if (direction == RIGHT) &#123;            if (col + 1 &gt;= matrix[0].length) &#123;                return false;            &#125; else return !flag[row][col + 1];        &#125;        if (direction == DOWN) &#123;            if (row + 1 &gt;= matrix.length) &#123;                return false;            &#125; else return !flag[row + 1][col];        &#125;        if (direction == LEFT) &#123;            if (col - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row][col - 1];        &#125;        if (direction == UP) &#123;            if (row - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row - 1][col];        &#125;        throw new RuntimeException(&quot;Impossible&quot;);    &#125;&#125;\n\n复杂度时间复杂度：O(m*n)\n空间复杂度：O(m*n)\n","categories":["LeetCode"]},{"title":"LeetCode-547","url":"/2021/03/17/LeetCode-547/","content":"题目547. 省份数量\n\n\n\n结果\n\n代码type DisjointSet struct &#123;\tparent []int // actually, it&#x27;s a hash table&#125;func (s *DisjointSet) union(x, y int) &#123;\tif rootX, rootY := s.find(x), s.find(y); rootX == rootY &#123;\t\treturn\t&#125; else &#123;\t\ts.parent[rootX] = rootY\t&#125;&#125;// find the root(representation) node of the given element, by the way, do path compressionfunc (s *DisjointSet) find(x int) int &#123;\tif x != s.parent[x] &#123;\t\ts.parent[x] = s.find(s.parent[x])\t&#125;\treturn s.parent[x]&#125;func findCircleNum(isConnected [][]int) (ans int) &#123;\ts := DisjointSet&#123;&#125;\tsize := len(isConnected)\tfor i := 0; i &lt; size; i++ &#123;\t\ts.parent = append(s.parent, i)\t&#125;\tfor i := 0; i &lt; size; i++ &#123;\t\tfor j := i + 1; j &lt; size; j++ &#123;\t\t\tif isConnected[i][j] == 1 &#123;\t\t\t\ts.union(i, j)\t\t\t&#125;\t\t&#125;\t&#125;\t// only root node is countered\tfor k, v := range s.parent &#123;\t\tif k == v &#123;\t\t\tans++\t\t&#125;\t&#125;\treturn&#125;\n\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-557","url":"/2020/08/30/LeetCode-557/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public String reverseWords(String s) &#123;        String[] words = s.split(&quot; &quot;);        for (int i = 0; i &lt; words.length; i++) &#123;            StringBuilder sb = new StringBuilder(words[i]);            words[i] = sb.reverse().toString();        &#125;        StringBuilder ans = new StringBuilder();        for (String str : words) &#123;            ans.append(str).append(&quot; &quot;);        &#125;        ans.deleteCharAt(ans.length() - 1);        return ans.toString();    &#125;&#125;\n\n核心算法是利用StringBuilder的reverse方法。\n","categories":["LeetCode"]},{"title":"LeetCode-59","url":"/2020/09/16/LeetCode-59/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final int RIGHT = 0, DOWN = 1, LEFT = 2, UP = 3;    private int DIRECTION = 0;    public int[][] generateMatrix(int n) &#123;        // save the final answer        int[][] ans = new int[n][n];        // if the num has been visited        boolean[][] flag = new boolean[n][n];        int i = 0, j = 0;        int val = 1;        while (true) &#123;            ans[i][j] = val;            val++;            flag[i][j] = true;            if (!reachable(flag, i, j)) &#123;                // time to change the direction                DIRECTION = (DIRECTION + 1) % 4;                // it&#x27;s done                if (!reachable(flag, i, j)) &#123;                    break;                &#125;            &#125;            if (DIRECTION == RIGHT) &#123;                j++;            &#125; else if (DIRECTION == DOWN) &#123;                i++;            &#125; else if (DIRECTION == LEFT) &#123;                j--;            &#125; else if (DIRECTION == UP) &#123;                i--;            &#125;        &#125;        return ans;    &#125;    private boolean reachable(boolean[][] flag, int row, int col) &#123;        if (DIRECTION == RIGHT) &#123;            if (col + 1 &gt;= flag[0].length) &#123;                return false;            &#125; else return !flag[row][col + 1];        &#125;        if (DIRECTION == DOWN) &#123;            if (row + 1 &gt;= flag.length) &#123;                return false;            &#125; else return !flag[row + 1][col];        &#125;        if (DIRECTION == LEFT) &#123;            if (col - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row][col - 1];        &#125;        if (DIRECTION == UP) &#123;            if (row - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row - 1][col];        &#125;        throw new RuntimeException(&quot;Impossible&quot;);    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n²）\n","categories":["LeetCode"]},{"title":"LeetCode-57","url":"/2020/11/04/LeetCode-57/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int[][] insert(int[][] intervals, int[] newInterval) &#123;        // 特殊情况        if (intervals.length == 0) &#123;            return new int[][]&#123;newInterval&#125;;        &#125;        if (intervals.length == 1) &#123;            return specialCase(intervals, newInterval);        &#125;        // 新的区间是否已经插入        boolean inserted = false;        // 标记状态：是否正在查找区间的终点        boolean status = false;        // 存储结果        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        // 如果新的区间是完全独立的        if (!haveInCommon(intervals, newInterval)) &#123;            for (int[] interval : intervals) &#123;                ans.add(List.of(interval[0], interval[1]));            &#125;            ans.add(List.of(newInterval[0], newInterval[1]));            ans.sort(Comparator.comparingInt(interval -&gt; interval.get(0)));            return toArray(ans);        &#125;        // 否则        int tmp = 0;        for (int[] interval : intervals) &#123;            // 如果新的区间已经被插入            if (inserted) &#123;                ans.add(List.of(interval[0], interval[1]));            &#125; else &#123;                if (status) &#123;                    // 如果两个区间有重叠部分                    if (haveInCommon(interval, newInterval)) &#123;                        // 只有ON_LEFT这种情况需要考虑                        if (relation(interval, newInterval) == Relation.ON_LEFT) &#123;                            ans.add(List.of(tmp, interval[1]));                            inserted = true;                            status = false;                        &#125;                    &#125; else &#123;                        ans.add(List.of(tmp, newInterval[1]));                        ans.add(List.of(interval[0], interval[1]));                        inserted = true;                    &#125;                &#125; else &#123;                    // 如果两个区间有重叠部分                    if (haveInCommon(interval, newInterval)) &#123;                        Relation relation = relation(interval, newInterval);                        if (relation == Relation.EQUAL) &#123;                            ans.add(List.of(interval[0], interval[1]));                            inserted = true;                        &#125; else if (relation == Relation.CONTAINS) &#123;                            // 如果是interval包含newInterval                            if (interval[0] &lt;= newInterval[0] &amp;&amp; interval[1] &gt;= newInterval[1]) &#123;                                ans.add(List.of(interval[0], interval[1]));                                inserted = true;                            &#125; else &#123;                                tmp = newInterval[0];                                // 标记：正在查找区间终点...                                status = true;                            &#125;                        &#125; else if (relation == Relation.ON_LEFT) &#123;                            ans.add(List.of(newInterval[0], interval[1]));                            inserted = true;                        &#125; else if (relation == Relation.ON_RIGHT) &#123;                            tmp = interval[0];                            status = true;                        &#125;                    &#125; else &#123;                        ans.add(List.of(interval[0], interval[1]));                    &#125;                &#125;            &#125;        &#125;        if (!inserted) &#123;            ans.add(List.of(tmp, newInterval[1]));        &#125;        return toArray(ans);    &#125;    private int[][] toArray(List&lt;List&lt;Integer&gt;&gt; list) &#123;        int[][] ans = new int[list.size()][2];        for (int i = 0; i &lt; ans.length; i++) &#123;            ans[i][0] = list.get(i).get(0);            ans[i][1] = list.get(i).get(1);        &#125;        return ans;    &#125;    private int[][] specialCase(int[][] intervals, int[] newInterval) &#123;        int[] interval = intervals[0];        // 如果两个区间有重叠部分        if (haveInCommon(interval, newInterval)) &#123;            return new int[][]&#123;&#123;Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])&#125;&#125;;        &#125; else &#123;            return interval[0] &lt; newInterval[0] ? new int[][]&#123;interval, newInterval&#125;                    : new int[][]&#123;newInterval, interval&#125;;        &#125;    &#125;    // 两个区间是否有重叠部分    private boolean haveInCommon(int[] interval1, int[] interval2) &#123;        if (interval1[1] &gt;= interval2[0] &amp;&amp; interval1[1] &lt;= interval2[1]) &#123;            return true;        &#125;        if (interval2[1] &gt;= interval1[0] &amp;&amp; interval2[1] &lt;= interval1[1]) &#123;            return true;        &#125;        return false;    &#125;    // 整个区间和新区间是否有重叠部分    private boolean haveInCommon(int[][] intervals, int[] interval) &#123;        for (int[] pair : intervals) &#123;            if (haveInCommon(pair, interval)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    // 有交集的前提下，判断两个区间的关系    private Relation relation(int[] interval1, int[] interval2) &#123;        if (interval1[0] == interval2[0] &amp;&amp; interval1[1] == interval2[1]) &#123;            return Relation.EQUAL;        &#125;        if (interval1[0] &gt;= interval2[0] &amp;&amp; interval1[1] &lt;= interval2[1]) &#123;            return Relation.CONTAINS;        &#125;        if (interval2[0] &gt;= interval1[0] &amp;&amp; interval2[1] &lt;= interval1[1]) &#123;            return Relation.CONTAINS;        &#125;        if (interval2[1] &gt;= interval1[0] &amp;&amp; interval2[1] &lt;= interval1[1]) &#123;            return Relation.ON_LEFT;        &#125;        if (interval2[0] &gt;= interval1[0] &amp;&amp; interval2[0] &lt;= interval1[1]) &#123;            return Relation.ON_RIGHT;        &#125;        throw new RuntimeException(&quot;WTF&quot;);    &#125;&#125;enum Relation &#123;    EQUAL, CONTAINS, ON_LEFT, ON_RIGHT&#125;\n\n复杂度时间复杂度：O（n），其中有个sort，但也可以优化到O（n），懒得弄了。\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-61","url":"/2020/09/18/LeetCode-61/","content":"题目61. 旋转链表\n\n\n\n结果\n\n代码class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public ListNode rotateRight(ListNode head, int k) &#123;        // 特殊情况        if (head == null) &#123;            return null;        &#125;        if (k == 0) &#123;            return head;        &#125;        // 求出链表长度        int len = listLength(head);        // 将链表的首尾相接，形成循环链表        tailToHead(head);        // 链表右移，指针应左移，所以取 “补码”        k = len - k % len;        for (int i = 0; i &lt; k; i++) &#123;            head = head.next;        &#125;        ListNode ans = new ListNode(0);        ListNode p = ans;        for (int i = 0; i &lt; len; i++, head = head.next, p = p.next) &#123;            p.next = new ListNode(head.val);        &#125;        return ans.next;    &#125;    private int listLength(ListNode head) &#123;        int len = 0;        while (head != null) &#123;            len++;            head = head.next;        &#125;        return len;    &#125;    private void tailToHead(ListNode head) &#123;        ListNode tail = head;        while (tail.next != null) &#123;            tail = tail.next;        &#125;        tail.next = head;    &#125;&#125;\n\n\nGo\n\n/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func rotateRight(head *ListNode, k int) *ListNode &#123;\tn := length(head)    if n == 0 &#123;\t\treturn head\t&#125;\tk = k % n\tif k == 0 || k == n &#123;\t\treturn head\t&#125;\ttail := kthNode(head, n-1)\tkth := kthNode(head, n-k-1)\ttrueHead := kth.Next\tkth.Next = nil\ttail.Next = head\treturn trueHead&#125;func length(head *ListNode) (length int) &#123;\tfor p := head; p != nil; p = p.Next &#123;\t\tlength++\t&#125;\treturn&#125;// return the kth node of the linked listfunc kthNode(head *ListNode, k int) (n *ListNode) &#123;\tn = head\tfor i := 0; i &lt; k; i++ &#123;\t\tn = n.Next\t&#125;\treturn&#125;\n\n\n\n复杂度时间复杂度：O（n），只有遍历链表的操作\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-62","url":"/2020/09/22/LeetCode-62/","content":"题目\n\n\n\n结果\n\n代码经典动态规划class Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[][] path = new int[m][n];        path[0][0] = 1;        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                if (i &gt; 0) &#123;                    path[i][j] += path[i - 1][j];                &#125;                if (j &gt; 0) &#123;                    path[i][j] += path[i][j - 1];                &#125;            &#125;        &#125;        return path[m - 1][n - 1];    &#125;&#125;\n\n稍加优化class Solution &#123;    public int uniquePaths(int m, int n) &#123;        int[] path = new int[n];        path[0] = 1;        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                if (j &gt; 0) &#123;                    path[j] += path[j - 1];                &#125;            &#125;        &#125;        return path[n - 1];    &#125;&#125;\n\n复杂度时间复杂度：O（M*N）\n空间复杂度：O（N），优化后\n","categories":["LeetCode"]},{"title":"LeetCode-605","url":"/2021/03/17/LeetCode-605/","content":"题目605. 种花问题\n\n\n\n结果\n\n代码func canPlaceFlowers(flowerbed []int, n int) bool &#123;\tcnt := 0\tfor i, v := range flowerbed &#123;\t\tflag1, flag2 := true, true\t\tif v == 0 &#123;\t\t\tif i &gt; 0 &amp;&amp; flowerbed[i-1] == 1 &#123;\t\t\t\tflag1 = false\t\t\t&#125;\t\t\tif i &lt; len(flowerbed)-1 &amp;&amp; flowerbed[i+1] == 1 &#123;\t\t\t\tflag2 = false\t\t\t&#125;\t\t\tif flag1 &amp;&amp; flag2 &#123;\t\t\t\tflowerbed[i] = 1\t\t\t\tcnt++\t\t\t&#125;\t\t&#125;\t&#125;\treturn cnt &gt;= n&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-621","url":"/2020/12/05/LeetCode-621/","content":"题目\n\n\n结果代码ORIGIN版class Solution &#123;    public int leastInterval(char[] tasks, int n) &#123;        int time = 0;        int count = 0;        // 各字母出现的次数        Map&lt;Character, Integer&gt; times = new HashMap&lt;&gt;();        for (char task : tasks) &#123;            times.put(task, times.getOrDefault(task, 0) + 1);        &#125;        // 各字母的技能CD时间        Map&lt;Character, Integer&gt; cd = new HashMap&lt;&gt;();        for (char key : times.keySet()) &#123;            cd.put(key, 0);        &#125;        while (count != tasks.length) &#123;            boolean flag = false;            for (char key : mostElement(times)) &#123;                // 如果技能冷却好了                if (times.get(key) &gt; 0 &amp;&amp; cd.get(key) == 0) &#123;                    // 放技能                    time++;                    times.put(key, times.get(key) - 1);                    count++;                    cd.put(key, n);                    flag = true;                    // 其他技能冷却时间-1                    for (char k : times.keySet()) &#123;                        if (k != key &amp;&amp; cd.get(k) != 0) &#123;                            cd.put(k, cd.get(k) - 1);                        &#125;                    &#125;                    break;                &#125;            &#125;            // 无技能可放            if (!flag) &#123;                time++;                for (char key : times.keySet()) &#123;                    if (cd.get(key) &gt; 0) &#123;                        cd.put(key, cd.get(key) - 1);                    &#125;                &#125;            &#125;        &#125;        return time;    &#125;    private List&lt;Character&gt; mostElement(Map&lt;Character, Integer&gt; map) &#123;        List&lt;Character&gt; list = new ArrayList&lt;&gt;(map.keySet());        // 按出现次序从大到小排列        list.sort((x, y) -&gt; Integer.compare(map.get(y), map.get(x)));        return list;    &#125;&#125;\n\n稍加优化版复杂度时间复杂度：O（）\n空间复杂度：O（）\n","categories":["LeetCode"]},{"title":"LeetCode-64","url":"/2020/07/23/LeetCode-64/","content":"LeetCode-64  最小路径和题目\n\n\n\n结果\n\n代码主要思路是，每一个位置只能由上面或者左面的位置到达，从而有了dp的可能性。\n标准版DPclass Solution &#123;    public int minPathSum(int[][] grid) &#123;        int row = grid.length;        int col = grid[0].length;        int[][] dp = new int[row][col];        dp[0][0] = grid[0][0];        // Fill in the first row        for (int i = 1; i &lt; row; i++) &#123;            dp[i][0] = dp[i - 1][0] + grid[i][0];        &#125;        // Fill in the first column        for (int i = 1; i &lt; col; i++) &#123;            dp[0][i] = dp[0][i - 1] + grid[0][i];        &#125;        // Fill in the dp by rows        for (int i = 1; i &lt; row; i++) &#123;            for (int j = 1; j &lt; col; j++) &#123;                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];            &#125;        &#125;        return dp[row - 1][col - 1];    &#125;&#125;\n\n空间优化版DPclass Solution &#123;    public int minPathSum(int[][] grid) &#123;        int row = grid.length;        int col = grid[0].length;        int[] dp = new int[col];        dp[0] = grid[0][0];                for (int i = 0; i &lt; row; i++) &#123;            // initial the dp[0]            if (i != 0) &#123;                dp[0] = dp[0] + grid[i][0];            &#125;            for (int j = 1; j &lt; col; j++) &#123;                // If this is 1st row                if (i == 0) &#123;                    dp[j] = dp[j - 1] + grid[i][j];                &#125; else &#123;                    dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];                &#125;            &#125;        &#125;        return dp[col - 1];    &#125;&#125;\n\n复杂度\n时间复杂度：O（m×n）\n\n空间复杂度：标准版O（m×n），优化版O（n）\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-649","url":"/2020/12/11/LeetCode-649/","content":"题目\n\n\n结果\n代码BAN掉身后的敌人class Solution &#123;    public String predictPartyVictory(String senate) &#123;        int length = senate.length();        // Right to vote        boolean[] flag = new boolean[length];        int radiant = 0, dire = 0;        char[] senates = senate.toCharArray();        for (char ch : senates) &#123;            if (ch == &#x27;R&#x27;) &#123;                radiant++;            &#125; else &#123;                dire++;            &#125;        &#125;        while (true) &#123;            for (int i = 0; i &lt; length; i++) &#123;                if (flag[i]) &#123;                    continue;                &#125;                if (senates[i] == &#x27;R&#x27;) &#123;                    if (dire == 0) &#123;                        return &quot;Radiant&quot;;                    &#125;                    for (int j = i; j &lt; length; j++) &#123;                        if (!flag[j] &amp;&amp; senates[j] == &#x27;D&#x27;) &#123;                            flag[j] = true;                            dire--;                            break;                        &#125;                        if (j == length - 1) &#123;                            j = -1;                        &#125;                    &#125;                &#125; else &#123;                    if (radiant == 0) &#123;                        return &quot;Dire&quot;;                    &#125;                    for (int j = i; j &lt; length; j++) &#123;                        if (!flag[j] &amp;&amp; senates[j] == &#x27;R&#x27;) &#123;                            flag[j] = true;                            radiant--;                            break;                        &#125;                        if (j == length - 1) &#123;                            j = -1;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-657","url":"/2020/08/28/LeetCode-657/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean judgeCircle(String moves) &#123;        int x = 0, y = 0;        for (char ch : moves.toCharArray()) &#123;            if (ch == &#x27;R&#x27;) &#123;                x++;            &#125; else if (ch == &#x27;L&#x27;) &#123;                x--;            &#125; else if (ch == &#x27;U&#x27;) &#123;                y--;            &#125; else if (ch == &#x27;D&#x27;) &#123;                y++;            &#125;        &#125;        return x == 0 &amp;&amp; y == 0;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-65","url":"/2020/07/31/LeetCode-65/","content":"题目65. 有效数字\n\n代码利用Java的Parseclass Solution &#123;    public boolean isNumber(String s) &#123;        try &#123;            if (s.endsWith(&quot;f&quot;) || s.endsWith(&quot;D&quot;)) &#123;                return false;            &#125;            Double.parseDouble(s);            return true;        &#125; catch (NumberFormatException e) &#123;            return false;        &#125;    &#125;&#125;\n\n\n\nDFA (Deterministic Finite Automaton）在计算理论中，确定有限状态自动机或确定有限自动机（英语：deterministic finite automaton, DFA）是一个能实现状态转移的自动机。对于一个给定的属于该自动机的状态和一个属于该自动机字母表Σ的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态)。\nDFA可以接受的字符：\n\nNumber\nDot\n+-\nE&#x2F;e\n\nDFA存在若干种状态，从初态开始，根据DFA接收的字符跳转到不同的状态。\n题目给定的数字存在很多可以接受的状态，这些形态构成了DFA的终态。\n所有可识别的字符串都能从初态找到一条通往终态的路。\n\n\npackage mainimport (\t&quot;fmt&quot;\t&quot;unicode&quot;)func main() &#123;\tfmt.Println(isNumber(&quot;53.5e93&quot;))\tfmt.Println(isNumber(&quot;abc&quot;))\tfmt.Println(isNumber(&quot;95a54e53&quot;))\tfmt.Println(isNumber(&quot;.1&quot;))\tfmt.Println(isNumber(&quot;3.&quot;))\tfmt.Println(isNumber(&quot;2e0&quot;))\tfmt.Println(isNumber(&quot;46.e3&quot;))&#125;type CharacterType inttype State intconst (\tNumber CharacterType = iota\tDot\tPlusMinus\tE\tUnknown)const (\tstate0 State = iota\tstate1\tstate2\tstate3\tstate4\tstate5\tstate6\tstate7\tstate8)var Transform = map[State]map[CharacterType]State&#123;\tstate0: &#123;\t\tPlusMinus: state1,\t\tNumber:    state2,\t\tDot:       state3,\t&#125;,\tstate1: &#123;\t\tNumber: state2,\t\tDot:    state3,\t&#125;,\tstate2: &#123;\t\tNumber: state2,\t\tDot:    state4,\t\tE:      state6,\t&#125;,\tstate3: &#123;\t\tNumber: state5,\t&#125;,\tstate4: &#123;\t\tNumber: state5,\t\tE:      state6,\t&#125;,\tstate5: &#123;\t\tNumber: state5,\t\tE:      state6,\t&#125;,\tstate6: &#123;\t\tPlusMinus: state7,\t\tNumber:    state8,\t&#125;,\tstate7: &#123;\t\tNumber: state8,\t&#125;,\tstate8: &#123;\t\tNumber: state8,\t&#125;,&#125;func isNumber(s string) bool &#123;\tstate := state0\tfor _, v := range s &#123;\t\tct := getType(v)\t\tif ct == Unknown &#123;\t\t\treturn false\t\t&#125;\t\tif next, ok := Transform[state][ct]; !ok &#123;\t\t\treturn false\t\t&#125; else &#123;\t\t\tstate = next\t\t&#125;\t&#125;\treturn state == state2 || state == state4 || state == state5 || state == state8&#125;func getType(ch rune) CharacterType &#123;\tif unicode.IsDigit(ch) &#123;\t\treturn Number\t&#125;\tif ch == &#x27;.&#x27; &#123;\t\treturn Dot\t&#125;\tif ch == &#x27;+&#x27; || ch == &#x27;-&#x27; &#123;\t\treturn PlusMinus\t&#125;\tif ch == &#x27;e&#x27; || ch == &#x27;E&#x27; &#123;\t\treturn E\t&#125;\treturn Unknown&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-659","url":"/2020/12/04/LeetCode-659/","content":"题目\n\n\n结果\n代码虽然通过了，但我这种算法太繁琐了，有空再看看题解怎么做的吧。\nclass Solution &#123;    public boolean isPossible(int[] nums) &#123;        // 各个数字的出现次数        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int num : nums) &#123;            map.put(num, map.getOrDefault(num, 0) + 1);        &#125;        boolean[] flag = new boolean[nums.length];        int count = 0;        while (count != nums.length) &#123;            Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();            for (int i = 0; i &lt; nums.length; i++) &#123;                if (flag[i]) &#123;                    continue;                &#125;                if (stack.isEmpty()) &#123;                    stack.push(nums[i]);                    flag[i] = true;                    count++;                    continue;                &#125;                // Dejavu                if (nums[i] == stack.peek()) &#123;                    // 如果是最大的元素                    if (nums[i] == nums[nums.length - 1] || map.get(nums[i]) &gt; map.get(nextNum(nums, i))) &#123;                        break;                    &#125;                &#125; else &#123;                    if (nums[i] - 1 != stack.peek()) &#123;                        break;                    &#125;                    stack.push(nums[i]);                    flag[i] = true;                    count++;                &#125;            &#125;            for (int num : stack) &#123;                map.put(num, map.get(num) - 1);            &#125;            if (!judge(stack)) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private boolean judge(Deque&lt;Integer&gt; stack) &#123;        if (stack.size() &lt; 3) &#123;            return false;        &#125;        while (true) &#123;            int tmp = stack.pop();            if (stack.isEmpty()) &#123;                break;            &#125;            if (tmp != stack.peek() + 1) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private int nextNum(int[] nums, int index) &#123;        for (int i = index + 1; i &lt; nums.length; i++) &#123;            if (nums[i] != nums[index]) &#123;                return nums[i];            &#125;        &#125;        throw new RuntimeException(&quot;no way&quot;);    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-701","url":"/2020/09/30/LeetCode-701/","content":"题目\n\n\n\n结果\n\n代码逃课做法class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;    &#125;    TreeNode(int val) &#123;        this.val = val;    &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;class Solution &#123;    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        List&lt;Integer&gt; path = new LinkedList&lt;&gt;();        dfs(root, path);        path.add(val);        path.sort(Integer::compareTo);        return buildTree(path);    &#125;    private TreeNode buildTree(List&lt;Integer&gt; path) &#123;        TreeNode root = new TreeNode(0);        TreeNode p = root;        for (int val : path) &#123;            p.right = new TreeNode(val);            p = p.right;        &#125;        return root.right;    &#125;    private void dfs(TreeNode root, List&lt;Integer&gt; path) &#123;        if (root == null) &#123;            return;        &#125;        path.add(root.val);        dfs(root.left, path);        dfs(root.right, path);    &#125;&#125;\n\n这题目不管是用迭代还是递归都挺简单的，好像也没必要逃课。\n一般做法class Solution &#123;    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if (root == null) &#123;            return new TreeNode(val);        &#125;        TreeNode p = root;        while (true) &#123;            if (val &lt; p.val) &#123;                if (p.left == null) &#123;                    p.left = new TreeNode(val);                    break;                &#125; else &#123;                    p = p.left;                &#125;            &#125; else &#123;                if (p.right == null) &#123;                    p.right = new TreeNode(val);                    break;                &#125; else &#123;                    p = p.right;                &#125;            &#125;        &#125;        return root;    &#125;&#125;\n\n复杂度时间复杂度：O（n），最坏情况下\n空间复杂度：O（1），迭代\n","categories":["LeetCode"]},{"title":"LeetCode-705","url":"/2021/03/13/LeetCode-705/","content":"题目705. 设计哈希集合\n\n\n\n结果\n\n代码大二的数据结构课上，听了听就觉得自己很懂了，但是写起来还是有很多细节要考虑：比如数组应该在什么时候扩容，除法运算时除数应该选多少，还有扩容问题。\ntype MyHashSet struct &#123;   arr       [][]int   threshold int   cnt       int // how many elements do we have&#125;/** Initialize your data structure here. */func Constructor() MyHashSet &#123;   return MyHashSet&#123;      arr:       make([][]int, 16, 16),      threshold: 16,   &#125;&#125;// insertion sortfunc (s *MyHashSet) Add(key int) &#123;   if s.Contains(key) &#123;      return   &#125;   s.resize()   idx := key % len(s.arr)   s.arr[idx] = append(s.arr[idx], key)   s.cnt++&#125;func (s *MyHashSet) Remove(key int) &#123;   if !s.Contains(key) &#123;      return   &#125;   idx := key % len(s.arr)   for i, v := range s.arr[idx] &#123;      if v == key &#123;         s.arr[idx] = remove(s.arr[idx], i)         return      &#125;   &#125;&#125;/** Returns true if this set contains the specified element */func (s *MyHashSet) Contains(key int) bool &#123;   idx := key % len(s.arr)   for _, v := range s.arr[idx] &#123;      if key == v &#123;         return true      &#125;   &#125;   return false&#125;func (s *MyHashSet) resize() &#123;   if s.cnt &lt;= s.threshold &#123;      return   &#125;   // TODO: resize   _s := MyHashSet&#123;      arr:       make([][]int, s.threshold*4, s.threshold*4),      threshold: s.threshold * 2,      cnt:       s.cnt,   &#125;   for _, v1 := range s.arr &#123;      for _, v2 := range v1 &#123;         _s.Add(v2)      &#125;   &#125;   s.arr = _s.arr   s.threshold = _s.threshold   s.cnt = _s.cnt&#125;/*func remove(nums []int, i int) []int &#123;   return append(nums[:i], nums[i+1:]...)&#125;*/func remove(s []int, i int) []int &#123;   s[len(s)-1], s[i] = s[i], s[len(s)-1]   return s[:len(s)-1]&#125;/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */\n\n删除slice中的元素Order matters\nIf you want to keep your array ordered, you have to shift all of the elements at the right of the deleting index by one to the left. Hopefully, this can be done easily in Golang:\nfunc remove(slice []int, s int) []int &#123;    return append(slice[:s], slice[s+1:]...)&#125;\n\nHowever, this is inefficient because you may end up with moving all of the elements, which is costy.\nOrder is not important\nIf you do not care about ordering, you have the much faster possibility to swap the element to delete with the one at the end of the slice and then return the n-1 first elements:\nfunc remove(s []int, i int) []int &#123;    s[len(s)-1], s[i] = s[i], s[len(s)-1]    return s[:len(s)-1]&#125;\n\n我这种HashSet的实现，拉链中的元素顺序不重要，因此后者是最佳选择。\n复杂度时间复杂度：O（1），不论是查找还是删除\n空间复杂度：O（n），需要两倍于元素数量的空间\n","categories":["LeetCode"]},{"title":"LeetCode-71","url":"/2020/11/10/LeetCode-71/","content":"题目\n\n\n结果\n\n代码class Solution &#123;    public String simplifyPath(String path) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        path = removeDuplicateSlash(path);        String[] paths = path.split(&quot;/&quot;);        for (String str : paths) &#123;            if (str.isBlank()) &#123;                continue;            &#125;            if (str.equals(&quot;.&quot;)) &#123;                continue;            &#125;            if (str.equals(&quot;..&quot;)) &#123;                if (!list.isEmpty()) &#123;                    list.remove(list.size() - 1);                &#125;                continue;            &#125;            list.add(str);        &#125;        StringBuilder ans = new StringBuilder(&quot;/&quot;);        for (String str : list) &#123;            ans.append(str).append(&quot;/&quot;);        &#125;        return removeLastSlash(ans.toString());    &#125;    private String removeLastSlash(String path) &#123;        if (path.length() != 1 &amp;&amp; path.endsWith(&quot;/&quot;)) &#123;            return path.substring(0, path.length() - 1);        &#125;        return path;    &#125;    private String removeDuplicateSlash(String path) &#123;        return path.replaceAll(&quot;//+&quot;, &quot;/&quot;);    &#125;&#125;\n\n复杂度时间复杂度：O（？），replaceAll和substring的复杂度不太清楚\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-714","url":"/2020/12/17/LeetCode-714/","content":"题目\n\n\n结果\n代码DP之二维数组class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int[][] dp = new int[prices.length][2];        dp[0][0] = 0;        dp[0][1] = -prices[0];        for (int i = 1; i &lt; dp.length; i++) &#123;            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);        &#125;        return dp[dp.length - 1][0];    &#125;&#125;\n\nDP之一位数组×2class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int[] dp1 = new int[prices.length];        int[] dp2 = new int[prices.length];        dp2[0] = -prices[0];        for (int i = 1; i &lt; prices.length; i++) &#123;            dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] + prices[i] - fee);            dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] - prices[i]);        &#125;        return dp1[prices.length - 1];    &#125;&#125;\n\nDP之再优化class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int a = 0;        int b = -prices[0];        for (int i = 1; i &lt; prices.length; i++) &#123;            a = Math.max(a, b + prices[i] - fee);            b = Math.max(b, a - prices[i]);        &#125;        return a;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-73","url":"/2020/11/12/LeetCode-73/","content":"题目\n\n\n结果\n代码版本一class Solution &#123;    public void setZeroes(int[][] matrix) &#123;        List&lt;Coordinate&gt; zeroes = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; matrix.length; i++) &#123;            for (int j = 0; j &lt; matrix[0].length; j++) &#123;                if (matrix[i][j] == 0) &#123;                    zeroes.add(new Coordinate(i, j));                &#125;            &#125;        &#125;        for (var zero : zeroes) &#123;            setZeroes(matrix, zero);        &#125;    &#125;    private void setZeroes(int[][] matrix, Coordinate zero) &#123;        int x = zero.x;        int y = zero.y;        // row        for (int i = 0; i &lt; matrix[0].length; i++) &#123;            matrix[x][i] = 0;        &#125;        // column        for (int i = 0; i &lt; matrix.length; i++) &#123;            matrix[i][y] = 0;        &#125;    &#125;&#125;class Coordinate &#123;    public int x;    public int y;    public Coordinate(int x, int y) &#123;        this.x = x;        this.y = y;    &#125;&#125;\n\n这样会有冗余的操作，比如将同一行或一列多次置零，可以用Set改进：\n版本二class Solution &#123;    public void setZeroes(int[][] matrix) &#123;        Set&lt;Integer&gt; rows = new HashSet&lt;&gt;();        Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();        for (int i = 0; i &lt; matrix.length; i++) &#123;            for (int j = 0; j &lt; matrix[0].length; j++) &#123;                if (matrix[i][j] == 0) &#123;                    rows.add(i);                    cols.add(j);                &#125;            &#125;        &#125;        for (int row : rows) &#123;            setZeroesR(matrix, row);        &#125;        for (int col : cols) &#123;            setZeroesC(matrix, col);        &#125;    &#125;    private void setZeroesR(int[][] matrix, int row) &#123;        for (int i = 0; i &lt; matrix[0].length; i++) &#123;            matrix[row][i] = 0;        &#125;    &#125;    private void setZeroesC(int[][] matrix, int col) &#123;        for (int i = 0; i &lt; matrix.length; i++) &#123;            matrix[i][col] = 0;        &#125;    &#125;&#125;\n\nGofunc setZeroes(matrix [][]int) &#123;   flag1 := make([]bool, len(matrix))   flag2 := make([]bool, len(matrix[0]))   for i := range matrix &#123;      for j := range matrix[i] &#123;         if matrix[i][j] == 0 &#123;            flag1[i] = true            flag2[j] = true         &#125;      &#125;   &#125;   for i := range matrix &#123;      for j := range matrix[i] &#123;         if flag1[i] || flag2[j] &#123;            matrix[i][j] = 0         &#125;      &#125;   &#125;&#125;\n\n复杂度时间复杂度：O（M*N）\n空间复杂度：O（M+N）\n","categories":["LeetCode"]},{"title":"LeetCode-739","url":"/2020/12/03/LeetCode-739/","content":"题目\n\n\n结果\n代码遍历class Solution &#123;    public int[] dailyTemperatures(int[] T) &#123;        int[] ans = new int[T.length];        for (int i = 0; i &lt; T.length; i++) &#123;            // 站在巨人的肩膀上            if (i != 0 &amp;&amp; T[i] == T[i - 1] &amp;&amp; ans[i - 1] != 0) &#123;                ans[i] = ans[i - 1] - 1;                continue;            &#125;            ans[i] = goStraight(T, i);        &#125;        return ans;    &#125;    private int goStraight(int[] T, int index) &#123;        for (int i = index + 1; i &lt; T.length; i++) &#123;            if (T[i] &gt; T[index]) &#123;                return i - index;            &#125;        &#125;        return 0;    &#125;&#125;\n\n单调栈class Solution &#123;    public int[] dailyTemperatures(int[] T) &#123;        int[] ans = new int[T.length];        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; T.length; i++) &#123;            // 使栈中的元素从栈底到栈顶递减            while (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;                int index = stack.pop();                ans[index] = i - index;            &#125;            stack.push(i);        &#125;        // 此时栈中还剩最后一个元素，但最后一个元素对应的ans必然是0，不必考虑        return ans;    &#125;&#125;\n\n复杂度遍历：\n\n时间复杂度：O（n²）\n\n空间复杂度：O（n）\n\n\n单调栈：\n\n时间复杂度：O（n），所有元素遍历一遍，进栈一次，出栈一次。\n空间复杂度：O（n）\n\n","categories":["LeetCode"]},{"title":"LeetCode-743","url":"/2021/04/20/LeetCode-743/","content":"题目743. 网络延迟时间\n\n\n\n结果\n\n代码数据结构、离散数学、计算机网络、算法每次都学一遍的迪杰斯特拉算法\nconst INFINITY = math.MaxInt64func networkDelayTime(times [][]int, n int, k int) int &#123;\tD := make(map[int]int)  // shortest path from k to other nodes\tS := make(map[int]bool) // nodes whose shortest path is already calculated\t// initialize\tfor i := 1; i &lt;= n; i++ &#123;\t\tD[i] = INFINITY\t&#125;\tD[k] = 0\tDISTANCE := make(map[string]int)\tfor _, edge := range times &#123;\t\tDISTANCE[strconv.Itoa(edge[0])+&quot; &quot;+strconv.Itoa(edge[1])] = edge[2]\t&#125;\tfor &#123;\t\t// the nearest node to source node which is not in set S\t\tu := extractMin(D, S)\t\tif u == -1 &#123;\t\t\tbreak\t\t&#125;\t\tS[u] = true\t\tfor v, dist := range D &#123;\t\t\tif _, ok := S[v]; !ok &#123;\t\t\t\tuv := edge(u, v, DISTANCE)\t\t\t\tif uv != -1 &#123;\t\t\t\t\tif D[u]+uv &lt; dist &#123;\t\t\t\t\t\tD[v] = D[u] + uv\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tmax := -1\tfor _, distance := range D &#123;\t\tif distance == INFINITY &#123;\t\t\treturn -1\t\t&#125;\t\tif distance &gt; max &amp;&amp; distance != 0 &#123;\t\t\tmax = distance\t\t&#125;\t&#125;\treturn max&#125;// distance from u to v, if there is no path, return -1func edge(u, v int, distance map[string]int) int &#123;\td, ok := distance[strconv.Itoa(u)+&quot; &quot;+strconv.Itoa(v)]\tif !ok &#123;\t\treturn -1\t&#125;\treturn d&#125;// the nearest node to source node which is not in set S, if not found, return -1func extractMin(D map[int]int, S map[int]bool) int &#123;\tminDistance := INFINITY\tans := -1\tfor node, distance := range D &#123;\t\tif _, ok := S[node]; !ok &#123;\t\t\tif distance &lt; minDistance &#123;\t\t\t\tans = node\t\t\t\tminDistance = distance\t\t\t&#125;\t\t&#125;\t&#125;\treturn ans&#125;\n\n","categories":["LeetCode"]},{"title":"LeetCode-746","url":"/2020/12/21/LeetCode-746/","content":"题目\n\n\n结果\n代码DPclass Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int[] dp = new int[cost.length];        dp[0] = cost[0];        dp[1] = cost[1];        for (int i = 2; i &lt; dp.length; i++) &#123;            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];        &#125;        return Math.min(dp[dp.length - 1], dp[dp.length - 2]);    &#125;&#125;\n\n改进的DPclass Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int x = cost[0];        int y = cost[1];        for (int i = 2; i &lt; cost.length; i++) &#123;            int cur = Math.min(x, y) + cost[i];            x = y;            y = cur;        &#125;        return Math.min(x, y);    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-766","url":"/2021/03/05/LeetCode-766/","content":"题目\n\n\n\n结果\n\n代码func isToeplitzMatrix(matrix [][]int) bool &#123;\t// only one element\tif len(matrix) == 1 &amp;&amp; len(matrix[0]) == 1 &#123;\t\treturn true\t&#125;\t// it&#x27;s not a matrix but a single row or column\tif len(matrix) &lt; 2 || len(matrix[0]) &lt; 2 &#123;\t\treturn true\t&#125;\tfor i := 0; i &lt; len(matrix) || i &lt; len(matrix[0]); i++ &#123;\t\tif i &lt; len(matrix[0]) &#123;\t\t\tv1 := matrix[0][i]\t\t\tfor row, col := 1, i+1; col &lt; len(matrix[0]) &amp;&amp; row &lt; len(matrix); &#123;\t\t\t\tif matrix[row][col] != v1 &#123;\t\t\t\t\treturn false\t\t\t\t&#125;\t\t\t\trow++\t\t\t\tcol++\t\t\t&#125;\t\t&#125;\t\tif i &lt; len(matrix) &#123;\t\t\tv2 := matrix[i][0]\t\t\tfor row, col := i+1, 1; row &lt; len(matrix) &amp;&amp; col &lt; len(matrix[0]); &#123;\t\t\t\tif matrix[row][col] != v2 &#123;\t\t\t\t\treturn false\t\t\t\t&#125;\t\t\t\trow++\t\t\t\tcol++\t\t\t&#125;\t\t&#125;\t&#125;\treturn true&#125;\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-763","url":"/2020/10/22/LeetCode-763/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public List&lt;Integer&gt; partitionLabels(String S) &#123;        // map存储S中每个字符最后一次出现的位置        Map&lt;Character, Integer&gt; map = lastOne(S);                List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        int left = 0, right = 0, river = 0;        do &#123;            right = Math.max(right, map.get(S.charAt(left)));            if (left == right) &#123;                ans.add(left - river + 1);                river = left + 1;            &#125;            left++;        &#125; while (left != S.length());        return ans;    &#125;    private Map&lt;Character, Integer&gt; lastOne(String s) &#123;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = s.length() - 1; i &gt;= 0; i--) &#123;            char ch = s.charAt(i);            if (!map.containsKey(ch)) &#123;                map.put(ch, i);            &#125;        &#125;        return map;    &#125;&#125;\n\n复杂度时间复杂度：O（n），两次遍历String\n空间复杂度：O（1），最坏情况下，map中存入26个键值对\n","categories":["LeetCode"]},{"title":"LeetCode-77","url":"/2020/09/08/LeetCode-77/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    // Save the final answer    private final List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    // Save the nums from 1 to n    private final List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        // Initialize the nums list        for (int i = 0; i &lt; n; i++) &#123;            nums.add(i + 1);        &#125;        combine(new LinkedList&lt;&gt;(), k);        return ans;    &#125;    private void combine(List&lt;Integer&gt; tmp, int k) &#123;        // Stop recurse when k == 0        if (k == 0) &#123;            ans.add(new LinkedList&lt;&gt;(tmp));            return;        &#125;        int index = tmp.size() == 0 ? 0 : tmp.get(tmp.size() - 1);        for (int i = index; i &lt; nums.size(); i++) &#123;            List&lt;Integer&gt; newTmp = new ArrayList&lt;&gt;(tmp);            newTmp.add(nums.get(i));            // Recursive call            combine(newTmp, k - 1);        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n！）\n空间复杂度：O（n²）\n","categories":["LeetCode"]},{"title":"LeetCode-767","url":"/2020/11/30/LeetCode-767/","content":"题目\n\n\n结果\n代码class Solution &#123;    public String reorganizeString(String S) &#123;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; S.length(); i++) &#123;            map.put(S.charAt(i), map.getOrDefault(S.charAt(i), 0) + 1);        &#125;        if (!reorganizable(map)) &#123;            return &quot;&quot;;        &#125;        StringBuilder sb = new StringBuilder();        while (sb.length() &lt; S.length()) &#123;            var maxes = maxAndSmallMax(map);            sb.append(maxes.get(0));            map.put(maxes.get(0), map.get(maxes.get(0)) - 1);            if (map.get(maxes.get(0)) == 0) &#123;                map.remove(maxes.get(0));            &#125;            if (maxes.get(1) != (char) 0) &#123;                sb.append(maxes.get(1));                map.put(maxes.get(1), map.get(maxes.get(1)) - 1);                if (map.get(maxes.get(1)) == 0) &#123;                    map.remove(maxes.get(1));                &#125;            &#125;        &#125;        return sb.toString();    &#125;    private List&lt;Character&gt; maxAndSmallMax(Map&lt;Character, Integer&gt; map) &#123;        var set = map.keySet();        int max = Integer.MIN_VALUE;        char max1 = 0, max2 = 0;        for (char ch : set) &#123;            if (map.get(ch) &gt; 0 &amp;&amp; map.get(ch) &gt; max) &#123;                max1 = ch;                max = map.get(ch);            &#125;        &#125;        if (map.keySet().isEmpty()) &#123;            return List.of(max1, (char) 0);        &#125;        max = Integer.MIN_VALUE;        for (char ch : set) &#123;            if (ch != max1 &amp;&amp; map.get(ch) &gt; max) &#123;                max2 = ch;                max = map.get(ch);            &#125;        &#125;        return List.of(max1, max2);    &#125;    private boolean reorganizable(Map&lt;Character, Integer&gt; map) &#123;        var max = map.keySet().stream().max(Comparator.comparingInt(map::get)).orElseThrow();        var val = map.get(max);        int sum;        // 这个stream用的帅啊        sum = map.values().stream().filter(x -&gt; x &lt;= val).mapToInt(x -&gt; x).sum();        return sum - val &gt;= val - 1;    &#125;&#125;\n\nI have another idea, but I feel sick now.\n","categories":["LeetCode"]},{"title":"LeetCode-78","url":"/2020/09/20/LeetCode-78/","content":"题目\n\n\n\n结果\n\n代码一、class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; 1 &lt;&lt; nums.length; i++) &#123;            StringBuilder binary = new StringBuilder(Integer.toBinaryString(i));            while (binary.length() &lt; nums.length) &#123;                binary.insert(0, &quot;0&quot;);            &#125;            List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();            for (int j = 0; j &lt; binary.length(); j++) &#123;                if (binary.charAt(j) == &#x27;1&#x27;) &#123;                    tmp.add(nums[j]);                &#125;            &#125;            ans.add(tmp);        &#125;        return ans;    &#125;&#125;\n\n二、class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();        for (int i = 0; i &lt; 1 &lt;&lt; nums.length; i++) &#123;            List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();            for (int j = 0; j &lt; nums.length; j++) &#123;                int flag = 1 &lt;&lt; j &amp; i;                if (flag != 0) &#123;                    tmp.add(nums[j]);                &#125;            &#125;            ans.add(tmp);        &#125;        return ans;    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-785","url":"/2020/07/16/LeetCode-785/","content":"LeetCode-785  判断二分图题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isBipartite(int[][] graph) &#123;        // 是否标记过        Boolean[] flag = new Boolean[graph.length];        // 是否访问过        boolean[] visited = new boolean[graph.length];        // 从0开始遍历        int visiting = 0;        flag[0] = true;        // BFS所需        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        // BFS        for (int i = 0; i &lt; graph.length; i++) &#123;            for (int j = 0; j &lt; graph[visiting].length; j++) &#123;                // 如果没被标记                if (flag[graph[visiting][j]] == null) &#123;                    flag[graph[visiting][j]] = !flag[visiting];                &#125; else if (flag[graph[visiting][j]] == flag[visiting]) &#123;                    return false;                &#125;                                                // 如果没遍历过                if (!visited[graph[visiting][j]] &amp;&amp; !queue.contains(graph[visiting][j])) &#123;                    queue.add(graph[visiting][j]);                &#125;            &#125;            visited[visiting] = true;            if (!queue.isEmpty()) &#123;                visiting = queue.poll();            &#125; else &#123;                // 如果队列为空                for (int j = 0; j &lt; visited.length; j++) &#123;                    if (!visited[j]) &#123;                        visiting = j;                        flag[visiting] = true;                        break;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n复杂度时间复杂度：小于O（N²）\n空间复杂度：O（N）\n","categories":["LeetCode"]},{"title":"LeetCode-80","url":"/2020/10/08/LeetCode-80/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int removeDuplicates(int[] nums) &#123;        int length = nums.length;        // false表示出现过一次，true表示出现过两次        Map&lt;Integer, Boolean&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; length; i++) &#123;            if (!map.containsKey(nums[i])) &#123;    // 没出现过                map.put(nums[i], false);            &#125; else if (!map.get(nums[i])) &#123;     //出现过一次                map.put(nums[i], true);            &#125; else if (map.get(nums[i])) &#123;     // 出现过两次                removeNum(nums, i);                length--;                i--;    // 点睛之笔            &#125;        &#125;        return length;    &#125;    private void removeNum(int[] nums, int index) &#123;        if (nums.length &gt;= index + 1) &#123;            System.arraycopy(nums, index + 1, nums, index, nums.length - 1 - index);        &#125;    &#125;&#125;\n\n一边遍历数组一边修改，可能会产生意想不到的问题，尽量还是别这样做的好。\n","categories":["LeetCode"]},{"title":"LeetCode-79","url":"/2020/08/01/LeetCode-79/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private static final char VISITED = &#x27;/&#x27;;    public boolean exist(char[][] board, String word) &#123;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                if (search(board, word, i, j, 0)) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    private boolean search(char[][] board, String word, int row, int col, int index) &#123;        // 是否越界或访问过或不符合预期        if (row &lt; 0 || row &gt;= board.length || col &lt; 0 || col &gt;= board[0].length || board[row][col] == VISITED || board[row][col] != word.charAt(index)) &#123;            return false;        &#125;        // 已经找到合适的序列        if (index == word.length() - 1) &#123;            return true;        &#125;        // 标记避免重复访问        char tmp = board[row][col];        board[row][col] = VISITED;        // 上下左右递归        if (search(board, word, row - 1, col, index + 1) || search(board, word, row + 1, col, index + 1) || search(board, word, row, col + 1, index + 1) || search(board, word, row, col - 1, index + 1)) &#123;            return true;        &#125; else &#123;            // 恢复            board[row][col] = tmp;            return false;        &#125;    &#125;&#125;\n\n\n\n复杂度时间复杂度：大于O（m×n）\n空间复杂度：O（index），最大递归深度不超过index\n","categories":["LeetCode"]},{"title":"LeetCode-82","url":"/2021/03/25/LeetCode-82/","content":"题目82. 删除排序链表中的重复元素 II难度中等568收藏分享切换为英文接收动态反馈\n\n\n\n\n结果\n\n代码/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123;   cnt := make(map[int]int)   for ptr := head; ptr != nil; ptr = ptr.Next &#123;      cnt[ptr.Val]++   &#125;   ans := &amp;ListNode&#123;Val: 0&#125;   p := ans   for ptr := head; ptr != nil; ptr = ptr.Next &#123;      if cnt[ptr.Val] == 1 &#123;         p.Next = &amp;ListNode&#123;Val: ptr.Val&#125;         p = p.Next      &#125;   &#125;   return ans.Next&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-83","url":"/2021/03/27/LeetCode-83/","content":"题目83. 删除排序链表中的重复元素\n\n\n\n结果\n\n代码\nJava\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        ListNode p = head;        //1-1-2-3-3        while (p != null) &#123;            if (p.next != null) &#123;                if (p.next.val == p.val) &#123;                    p.next = p.next.next;                &#125; else &#123;                    p = p.next;                &#125;            &#125; else &#123;                 break;            &#125;        &#125;        return head;    &#125;&#125;\n\n\nGo\n\n/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123;\tset := make(map[int]bool)\tans := &amp;ListNode&#123;Val: 0&#125;\tp := ans\tfor ptr := head; ptr != nil; ptr = ptr.Next &#123;\t\tif _, ok := set[ptr.Val]; !ok &#123;\t\t\tset[ptr.Val] = true\t\t\tp.Next = &amp;ListNode&#123;Val: ptr.Val&#125;\t\t\tp = p.Next\t\t&#125;\t&#125;\treturn ans.Next&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1），Go的是O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-830","url":"/2021/03/17/LeetCode-830/","content":"题目830. 较大分组的位置\n\n\n\n结果\n\n代码func largeGroupPositions(s string) [][]int &#123;\tvar ans [][]int\tfor l := 0; l &lt; len(s); l++ &#123;\t\tvar r int\t\tfor r = l + 1; r &lt; len(s); r++ &#123;\t\t\tif s[l] != s[r] &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tif r-l &gt;= 3 &#123;\t\t\tans = append(ans, []int&#123;l, r - 1&#125;)\t\t\tl += r - l - 1\t\t&#125;\t&#125;\treturn ans&#125;","categories":["LeetCode"]},{"title":"LeetCode-832","url":"/2021/03/05/LeetCode-832/","content":"题目\n\n\n\n结果\n\n代码func flipAndInvertImage(image [][]int) [][]int &#123;\tans := make([][]int, len(image))\tfor i, _ := range ans &#123;\t\tans[i] = make([]int, len(image[0]))\t&#125;\tlength := len(image[0])\tfor i, row := range image &#123;\t\tfor j, v := range row &#123;\t\t\tans[i][length-j-1] = inverse(v)\t\t&#125;\t&#125;\treturn ans&#125;func inverse(x int) int&#123;\tif x == 1 &#123;\t\treturn 0\t&#125;\tif x == 0 &#123;\t\treturn 1\t&#125;\tpanic(&quot;Err&quot;)&#125;","categories":["LeetCode"]},{"title":"LeetCode-841","url":"/2020/08/31/LeetCode-841/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private boolean[] flag;    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;        flag = new boolean[rooms.size()];        visit(rooms, 0);        return canVisit();    &#125;    private boolean canVisit() &#123;        for (boolean b : flag) &#123;            if (!b) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private void visit(List&lt;List&lt;Integer&gt;&gt; rooms, int number) &#123;        flag[number] = true;        for (int n : rooms.get(number)) &#123;            // if the room has been visited            if (flag[n]) &#123;                continue;            &#125;            visit(rooms, n);        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（rooms的元素个数）\n空间复杂度：O（房间个数）\n","categories":["LeetCode"]},{"title":"LeetCode-842","url":"/2020/12/08/LeetCode-842/","content":"题目\n\n\n结果\n代码这题没思路，参考题解做的，不得不说，题解的代码写的非常漂亮，建议全文背诵，经典永流传。\n返回值用boolean的递归我真的得第一次见，那个remove是点睛之笔。\nclass Solution &#123;    public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        recursive(ans, S, 0, 0, 0);        return ans;    &#125;    private boolean recursive(List&lt;Integer&gt; ans, String nums, int index, int sum, int prev) &#123;        // 递归终止条件        if (index == nums.length()) &#123;            return ans.size() &gt;= 3;        &#125;        long curr = 0;        for (int i = index; i &lt; nums.length(); i++) &#123;            // 以0开始，剪枝            if (i &gt; index &amp;&amp; nums.charAt(index) == &#x27;0&#x27;) &#123;                return false;            &#125;            curr = curr * 10 + Integer.parseInt(String.valueOf(nums.charAt(i)));            // 越界，剪枝            if (curr &gt; Integer.MAX_VALUE) &#123;                return false;            &#125;            if (ans.size() &gt;= 2) &#123;                // 需要更多位                if (curr &lt; sum) &#123;                    continue;                &#125; else if (curr &gt; sum) &#123;                    // 剪枝                    return false;                &#125;            &#125;            ans.add((int) curr);            if (recursive(ans, nums, i + 1, (int) curr + prev, (int) curr)) &#123;                return true;            &#125; else &#123;                // 真*剪枝                ans.remove(ans.size() - 1);            &#125;        &#125;        return false;    &#125;&#125;\n\n复杂度时间复杂度：不会算\n空间复杂度：O（N），递归最多N层\n","categories":["LeetCode"]},{"title":"LeetCode-844","url":"/2020/10/19/LeetCode-844/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean backspaceCompare(String S, String T) &#123;        return backspace(S).equals(backspace(T));    &#125;    private String backspace(String str) &#123;        StringBuilder ans = new StringBuilder();        for (int i = 0; i &lt; str.length(); i++) &#123;            if (str.charAt(i) == &#x27;#&#x27; &amp;&amp; !ans.toString().isBlank()) &#123;                ans = new StringBuilder(ans.substring(0, ans.length() - 1));            &#125; else if (str.charAt(i) != &#x27;#&#x27;) &#123;                ans.append(str.charAt(i));            &#125;        &#125;        return ans.toString();    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode-845","url":"/2020/10/25/LeetCode-845/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int longestMountain(int[] A) &#123;        if (A.length == 0) &#123;            return 0;        &#125;        // mountain数组的值为：若以mountain[i]作为山顶，长度将会如何        int[] mountain = new int[A.length];        for (int i = 0; i &lt; mountain.length; i++) &#123;            mountain[i] = length(A, i);        &#125;        Arrays.sort(mountain);        return mountain[A.length - 1];    &#125;    private int length(int[] A, int index) &#123;        // 边界值必然不是山顶        if (index == 0 || index == A.length - 1) &#123;            return 0;        &#125;        // 不是极大值的不然不是山顶        if (A[index - 1] &gt;= A[index] || A[index + 1] &gt;= A[index]) &#123;            return 0;        &#125;        int length = 1;        for (int i = index - 1; i &gt;= 0; i--) &#123;            if (A[i] &lt; A[i + 1]) &#123;                length++;            &#125; else &#123;                break;            &#125;        &#125;        for (int i = index + 1; i &lt; A.length; i++) &#123;            if (A[i] &lt; A[i - 1]) &#123;                length++;            &#125; else &#123;                break;            &#125;        &#125;        return length;    &#125;&#125;\n\n复杂度时间复杂度：O（n²），实际一定比n²小，但又比n大一些\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-86","url":"/2021/03/17/LeetCode-86/","content":"题目86. 分隔链表\n\n\n\n结果\n\n代码/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func partition(head *ListNode, x int) *ListNode &#123;\t// small, large list with a dummy node\tvar s, l ListNode\tsPtr, lPtr := &amp;s, &amp;l\tfor p := head; p != nil; p = p.Next &#123;\t\tif p.Val &lt; x &#123;\t\t\tsPtr.Next = &amp;ListNode&#123;Val: p.Val&#125;\t\t\tsPtr = sPtr.Next\t\t&#125; else &#123;\t\t\tlPtr.Next = &amp;ListNode&#123;Val: p.Val&#125;\t\t\tlPtr = lPtr.Next\t\t&#125;\t&#125;\tsPtr.Next = l.Next\treturn s.Next&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-860","url":"/2020/12/10/LeetCode-860/","content":"题目\n\n\n结果\n代码class Solution &#123;    public boolean lemonadeChange(int[] bills) &#123;        int five = 0, ten = 0;        for (int bill : bills) &#123;            switch (bill) &#123;                case 5 -&gt; five++;                case 10 -&gt; &#123;                    if (five &gt; 0) &#123;                        five--;                        ten++;                    &#125; else &#123;                        return false;                    &#125;                &#125;                case 20 -&gt; &#123;                    if (ten &gt; 0 &amp;&amp; five &gt; 0) &#123;                        ten--;                        five--;                    &#125; else if (five &gt;= 3) &#123;                        five -= 3;                    &#125; else &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n复杂度时间复杂度：O（N）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-867","url":"/2021/03/05/LeetCode-867/","content":"题目\n\n\n\n结果\n\n代码func transpose(matrix [][]int) [][]int &#123;\tmatrix2 := make([][]int, len(matrix[0]))\tfor i := range matrix2 &#123;\t\tmatrix2[i] = make([]int, len(matrix))\t&#125;\tfor i := 0; i &lt; len(matrix); i++ &#123;\t\tfor j := 0; j &lt; len(matrix[0]); j++ &#123;\t\t\tmatrix2[j][i] = matrix[i][j]\t\t&#125;\t&#125;\treturn matrix2&#125;","categories":["LeetCode"]},{"title":"LeetCode-861","url":"/2020/12/07/LeetCode-861/","content":"题目\n\n\n结果\n代码矩阵的第一列必全为1，而只有行变换才能确保这一点。所以先进行行变换，通过翻转将第一列置1，这一定是行变换的最优解，这样行变换的任务就完成了。\n接着是列变换，判断标准是0和1的数目。\nclass Solution &#123;    public int matrixScore(int[][] A) &#123;        // 行变换，第一列必为全1        for (var row : A) &#123;            if (row[0] == 0) &#123;                reverseRow(row);            &#125;        &#125;        // 列变换        for (int i = 1; i &lt; A[0].length; i++) &#123;            int countOne = 0, countZero = 0;            for (int[] row : A) &#123;                if (row[i] == 0) &#123;                    countZero++;                &#125; else &#123;                    countOne++;                &#125;            &#125;            // 如果这一列0的数目多于1的数目            if (countZero &gt; countOne) &#123;                reverseCol(A, i);            &#125;        &#125;        return sum(A);    &#125;    private void reverseRow(int[] row) &#123;        for (int i = 0; i &lt; row.length; i++) &#123;            if (row[i] == 0) &#123;                row[i] = 1;            &#125; else &#123;                row[i] = 0;            &#125;        &#125;    &#125;    private void reverseCol(int[][] A, int col) &#123;        for (int i = 0; i &lt; A.length; i++) &#123;            if (A[i][col] == 0) &#123;                A[i][col] = 1;            &#125; else &#123;                A[i][col] = 0;            &#125;        &#125;    &#125;    private int sum(int[][] A) &#123;        int sum = 0;        for (int[] B : A) &#123;            sum += sum(B);        &#125;        return sum;    &#125;    private int sum(int[] A) &#123;        int sum = 0;        for (int num : A) &#123;            sum = sum * 2 + num;        &#125;        return sum;    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-896","url":"/2021/03/05/LeetCode-896/","content":"题目\n\n\n\n结果\n\n代码func isMonotonic(A []int) bool &#123;\tup := A[0] &lt; A[len(A)-1]\tfor i := 0; i &lt; len(A)-1; i++ &#123;\t\tif up &#123;\t\t\tif A[i] &gt; A[i+1] &#123;\t\t\t\treturn false\t\t\t&#125;\t\t&#125; else &#123;\t\t\tif A[i] &lt; A[i+1] &#123;\t\t\t\treturn false\t\t\t&#125;\t\t&#125;\t&#125;\treturn true&#125;\n\n\n\n\n","categories":["LeetCode"]},{"title":"LeetCode-92","url":"/2021/03/20/LeetCode-92/","content":"题目92. 反转链表 II\n\n\n\n结果\n\n代码/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func reverseBetween(head *ListNode, left int, right int) *ListNode &#123;\tvar pre *ListNode\tptr := head\tfor i := 0; i &lt; left-1; i++ &#123;\t\tif i == left-2 &#123;\t\t\tpre = ptr\t\t&#125;\t\tptr = ptr.Next\t&#125;\tvar stack []*ListNode\tfor i := 0; i &lt;= right-left; i++ &#123;\t\tstack = append(stack, ptr)\t\tptr = ptr.Next\t&#125;\tfor i := range stack &#123;\t\tif i != 0 &#123;\t\t\tstack[i].Next = stack[i-1]\t\t&#125;\t&#125;\tif pre != nil &#123;\t\tpre.Next = stack[len(stack)-1]\t&#125; else &#123;\t\thead = stack[len(stack)-1]\t&#125;\tstack[0].Next = ptr\treturn head&#125;\n\n\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-925","url":"/2020/10/21/LeetCode-925/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isLongPressedName(String name, String typed) &#123;        int ptr1 = 0, ptr2 = 0;        char tmp = name.charAt(0);        while (ptr1 &lt; name.length() &amp;&amp; ptr2 &lt; typed.length()) &#123;            if (name.charAt(ptr1) == typed.charAt(ptr2)) &#123;                tmp = name.charAt(ptr1);                ptr1++;                ptr2++;            &#125; else if (typed.charAt(ptr2) == tmp) &#123;                ptr2++;            &#125; else &#123;                return false;            &#125;        &#125;        while (ptr2 &lt; typed.length()) &#123;            if (typed.charAt(ptr2) != tmp) &#123;                return false;            &#125;            ptr2++;        &#125;        return ptr1 == name.length();    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-922","url":"/2020/11/12/LeetCode-922/","content":"题目\n\n\n结果\n代码原地排序class Solution &#123;    public int[] sortArrayByParityII(int[] A) &#123;        for (int i = 0; i &lt; A.length; i++) &#123;            if (i % 2 != A[i] % 2) &#123;                if (i % 2 == 0) &#123;                    swap(A, i, nextGuy(A, i, false));                &#125; else &#123;                    swap(A, i, nextGuy(A, i, true));                &#125;            &#125;        &#125;        return A;    &#125;    // when flag is true: find next even index    // when flag is false: find next odd index    private int nextGuy(int[] nums, int index, boolean flag) &#123;        if (flag) &#123;            for (int i = index + 1; i &lt; nums.length; i++) &#123;                if (i % 2 == 0 &amp;&amp; nums[i] % 2 != 0) &#123;                    return i;                &#125;            &#125;        &#125; else &#123;            for (int i = index + 1; i &lt; nums.length; i++) &#123;                if (i % 2 != 0 &amp;&amp; nums[i] % 2 == 0) &#123;                    return i;                &#125;            &#125;        &#125;        throw new RuntimeException(&quot;IMPOSSIBLE&quot;);    &#125;    private void swap(int[] nums, int i, int j) &#123;        int tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;\n\n新的数组class Solution &#123;    public int[] sortArrayByParityII(int[] A) &#123;        if (A.length == 1) &#123;            return A;        &#125;        int[] ans = new int[A.length];        int index1 = 0;        int index2 = 1;        for (int i = 0; i &lt; A.length; i++) &#123;            if (A[i] % 2 == 0) &#123;                ans[index1] = A[i];                index1 += 2;            &#125; else &#123;                ans[index2] = A[i];                index2 += 2;            &#125;        &#125;        return ans;    &#125;&#125;\n\n复杂度时间复杂度：O（n²），O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-941","url":"/2020/11/03/LeetCode-941/","content":"题目\n\n\n结果\n代码版本1class Solution &#123;    public boolean validMountainArray(int[] A) &#123;        if (A.length &lt; 3) &#123;            return false;        &#125;        for (int i = 1; i &lt; A.length - 1; i++) &#123;            if (isTop(A, i)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    private boolean isTop(int[] A, int index) &#123;        if (index == 0 || index == A.length - 1) &#123;            return false;        &#125;        for (int i = 1; i &lt;= index; i++) &#123;            if (A[i] &lt;= A[i - 1]) &#123;                return false;            &#125;        &#125;        for (int i = index; i &lt; A.length - 1; i++) &#123;            if (A[i] &lt;= A[i + 1]) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n版本2class Solution &#123;    public boolean validMountainArray(int[] A) &#123;        if (A.length &lt; 3) &#123;            return false;        &#125;        int left = 0, right = A.length - 1;        for (int i = 1; i &lt; A.length; i++) &#123;            if (A[i] &gt; A[i - 1]) &#123;                left++;            &#125; else &#123;                break;            &#125;        &#125;        for (int i = A.length - 1; i &gt; 0; i--) &#123;            if (A[i] &lt; A[i - 1]) &#123;                right--;            &#125; else &#123;                break;            &#125;        &#125;        return left == right &amp;&amp; left != 0 &amp;&amp; left != A.length - 1;    &#125;&#125;\n\n\n\n复杂度版本一时间复杂度：O（n²）\n空间复杂度：O（1）\n版本二时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"LeetCode-96","url":"/2020/07/15/LeetCode-96/","content":"LeetCode-96  不同的二叉搜索树题目\n\n\n\n结果\n\n代码class Solution &#123;    public int numTrees(int n) &#123;        int[] dp = new int[n + 1];        // 边界值        dp[0] = 1;        dp[1] = 1;        // 算出dp[2]到dp[n]的值        for (int i = 2; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= i; j++) &#123;                // 左子树可能情况数×右子树可能情况数                dp[i] += dp[j - 1] * dp[i - j];            &#125;        &#125;        return dp[n];    &#125;&#125;\n\n复杂度时间复杂度：O（n²）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"LeetCode-95","url":"/2020/07/21/LeetCode-95/","content":"LeetCode-95 不同的二叉搜索树II题目\n\n\n\n结果\n\n代码class Solution &#123;    public List&lt;TreeNode&gt; generateTrees(int n) &#123;        // 特殊情况        if (n == 0) &#123;            return new LinkedList&lt;TreeNode&gt;();        &#125;        return generateTrees(1, n);    &#125;    public List&lt;TreeNode&gt; generateTrees(int begin, int end) &#123;        // 将结果存储在ans中        List&lt;TreeNode&gt; ans = new LinkedList&lt;&gt;();        // 如果长度为0，说明构成不了任何树，返回null        if (begin &gt; end) &#123;            ans.add(null);            return ans;        &#125;        // 所有可能的根节点        for (int i = begin; i &lt;= end; i++) &#123;            var leftTrees = generateTrees(begin, i - 1);            var rightTrees = generateTrees(i + 1, end);            // 所有可能的左右子树            for (var left : leftTrees) &#123;                for (var right : rightTrees) &#123;                    TreeNode root = new TreeNode(i);                    root.left = left;                    root.right = right;                    ans.add(root);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;@AllArgsConstructor@NoArgsConstructorclass TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int val) &#123;        this.val = val;    &#125;&#125;\n\n递归递归递归。\n复杂度时间和空间复杂度都取决于究竟可以生成多少棵树。\n时间复杂度：O（树的数量）\n空间复杂度：O（树的数量）\n","categories":["LeetCode"]},{"title":"LeetCode-973","url":"/2020/11/09/LeetCode-973/","content":"题目\n\n\n结果\n代码class Solution &#123;    public int[][] kClosest(int[][] points, int K) &#123;        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();        for (int[] nums : points) &#123;            list.add(List.of(nums[0], nums[1]));        &#125;        list.sort(Comparator.comparingInt(this::distance));        var tmp = list.subList(0, K);        int[][] ans = new int[K][2];        int index = 0;        for (var pair : tmp) &#123;            ans[index][0] = pair.get(0);            ans[index][1] = pair.get(1);            index++;        &#125;        return ans;    &#125;    private int distance(int x, int y) &#123;        return x * x + y * y;    &#125;    private int distance(List&lt;Integer&gt; pair) &#123;        return distance(pair.get(0), pair.get(1));    &#125;&#125;\n\n复杂度时间复杂度：O（NlogN）\n空间复杂度：O（N）\n","categories":["LeetCode"]},{"title":"LeetCode-976","url":"/2020/11/29/LeetCode-976/","content":"题目\n\n\n结果\n代码class Solution &#123;    public int largestPerimeter(int[] A) &#123;        Arrays.sort(A);        for (int i = A.length - 1; i &gt; 1; i--) &#123;            if (isTriangle(A[i - 2], A[i - 1], A[i])) &#123;                return A[i - 2] + A[i - 1] + A[i];            &#125;        &#125;        return 0;    &#125;    private boolean isTriangle(int a, int b, int c) &#123;        return a + b &gt; c;    &#125;&#125;\n\n数学题，关键在于这三条边在排序后的数组中一定是相邻的。\n复杂度时间复杂度：O（N Log N），快排\n空间复杂度：O（Log N），快排的栈\n","categories":["LeetCode"]},{"title":"LeetCode-98","url":"/2020/10/17/LeetCode-98/","content":"题目\n\n\n\n结果中序遍历\n\n递归\n代码中序遍历class Solution &#123;    private final List&lt;Integer&gt; list = new LinkedList&lt;&gt;();    public boolean isValidBST(TreeNode root) &#123;        dfs(root);        long pre = Long.MIN_VALUE;        for (int num : list) &#123;            if (pre &gt;= num) &#123;                return false;            &#125;            pre = num;        &#125;        return true;    &#125;    private void dfs(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        dfs(root.left);        list.add(root.val);        dfs(root.right);    &#125;&#125;\n\n递归class Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    private boolean isValidBST(TreeNode root, long minValue, long maxValue) &#123;        if (root == null) &#123;            return true;        &#125;        if (root.val &lt;= minValue || root.val &gt;= maxValue) &#123;            return false;        &#125;        if (!isValidBST(root.left, minValue, root.val) || !isValidBST(root.right, root.val, maxValue)) &#123;            return false;        &#125;        return true;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["LeetCode"]},{"title":"Leetcode-31","url":"/2020/07/05/Leetcode-31/","content":"题目\n\n运行结果四个月前\n\n四个月后\n\n\n\n代码四个月前package eternal.fire.java;import java.util.*;public class LeetCode &#123;    // 测试    public static void main(String[] args) &#123;        Solution solution = new Solution();        int[] nums = new int[]&#123;1, 2, 3&#125;;        solution.nextPermutation(nums);        System.out.println(Arrays.toString(nums));    &#125;&#125;class Solution &#123;    // 核心函数    public void nextPermutation(int[] nums) &#123;        // 从数组中倒数第二个元素开始从后往前找起        for (int i = nums.length - 2; i &gt;= 0; i--) &#123;            int position = theOne(nums, i);            if (position != -1) &#123;                // 交换位置                swap(nums, i, position);                // 将后面的部分排序以保证是最小的                Arrays.sort(nums, i + 1, nums.length);                break;            &#125;            // 如果没有找到更大的排列方式            if (i == 0) &#123;                reverse(nums);            &#125;        &#125;    &#125;    /**     * 交换数组中的元素     *     * @param nums 数组     * @param i    下标1     * @param j    下标2     */    public void swap(int[] nums, int i, int j) &#123;        int tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;    /**     * 找到比nums[index]大的数，返回最小的一个符合条件的数的下标     * @param nums 数组     * @param index 下标     * @return 返回最小的一个符合条件的数的下标     */    public int theOne(int[] nums, int index) &#123;        // 初始化        int val = -1;        int position = -1;        // 给val和position一个初始值        for (int i = index + 1; i &lt; nums.length; i++) &#123;            if (nums[index] &lt; nums[i]) &#123;                val = nums[i];                position = i;                break;            &#125;        &#125;        // 没有合适的可交换对象        if (position == -1) &#123;            return -1;        &#125;        // 更新val和position的值确保其是最合适的        for (int i = position; i &lt; nums.length; i++) &#123;            if (nums[i] &gt; nums[index]) &#123;                if (nums[i] &lt; val) &#123;                    position = i;                    val = nums[i];                &#125;            &#125;        &#125;        return position;    &#125;    /**     * 翻转数组     * @param nums 数组     */    public void reverse(int[] nums) &#123;        int i = 0, j = nums.length - 1;        while (i &lt; j) &#123;            swap(nums, i, j);            i++;            j--;        &#125;    &#125;&#125;\n\nps：没看题解，不知道自己是否最优。\n四个月后class Solution &#123;    public void nextPermutation(int[] nums) &#123;        if (isDecrease(nums)) &#123;            Arrays.sort(nums);            return;        &#125;        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;            int index = biggerThanMe(nums, i);            if (index != 0) &#123;                swap(nums, i, index);                Arrays.sort(nums, i + 1, nums.length);                return;            &#125;        &#125;    &#125;    private boolean isDecrease(int[] nums) &#123;        for (int i = 1; i &lt; nums.length; i++) &#123;            if (nums[i] &gt; nums[i - 1]) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private void swap(int[] nums, int index1, int index2) &#123;        int tmp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = tmp;    &#125;    private int biggerThanMe(int[] nums, int index) &#123;        int me = nums[index];        int target = Integer.MAX_VALUE;        for (int i = index + 1; i &lt; nums.length; i++) &#123;            if (nums[i] &gt; me) &#123;                target = Math.min(target, nums[i]);            &#125;        &#125;        for (int i = index + 1; i &lt; nums.length; i++) &#123;            if (nums[i] == target) &#123;                return i;            &#125;        &#125;        return 0;    &#125;&#125;\n\n看了一下之前写的，现在的思路和之前的基本一样，稍有改动。\n复杂度时间复杂度：O（NlogN）\n空间复杂度：O（1）\n","categories":["LeetCode"]},{"title":"Leetcode-63","url":"/2020/07/06/Leetcode-63/","content":"Leetcode-63  不同路径II题目\n\n结果\n\n\n\n代码版本一class Solution &#123;    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        // 用两个变量存储行数和列数        int row = obstacleGrid.length, column = obstacleGrid[0].length;        // path[i][j]代表从起点到（i，j）的路径数        int[][] path = new int[row][column];        // 初始条件        path[0][0] = 1;        // 遍历path        for (int i = 0; i &lt; row; i++) &#123;            for (int j = 0; j &lt; column; j++) &#123;                // 障碍物                if (obstacleGrid[i][j] == 1) &#123;                    path[i][j] = 0;                &#125; else &#123;                    if (i &gt;= 1) &#123;                        path[i][j] += path[i - 1][j];                    &#125;                    if (j &gt;= 1) &#123;                        path[i][j] += path[i][j - 1];                    &#125;                &#125;            &#125;        &#125;        return path[row - 1][column - 1];    &#125;&#125;\n\n版本二（优化版）class Solution &#123;    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;        // 用两个变量存储行数和列数        int row = obstacleGrid.length, column = obstacleGrid[0].length;        // path[i]代表从起点到第i个位置的路径数        int[] path = new int[column];        // 初始条件        path[0] = 1;        // 遍历path        for (int[] rows : obstacleGrid) &#123;            for (int j = 0; j &lt; column; j++) &#123;                // 障碍物                if (rows[j] == 1) &#123;                    path[j] = 0;                &#125; else &#123;                    if (j &gt;= 1) &#123;                        path[j] += path[j - 1];                    &#125;                &#125;            &#125;        &#125;        return path[column - 1];    &#125;&#125;\n\n","categories":["LeetCode"]},{"title":"Leetcode-34","url":"/2020/07/07/Leetcode-34/","content":"题目\n\n\n\n结果\n\n二分查找 2.0\n\n代码一次遍历class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        int[] ans = new int[2];        boolean flag = false;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] == target) &#123;                ans[0] = i;                flag = true;                break;            &#125;        &#125;        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;            if (nums[i] == target) &#123;                ans[1] = i;                break;            &#125;        &#125;        if (!flag) &#123;            ans[0] = -1;            ans[1] = -1;        &#125;        return ans;    &#125;&#125;\n\n二分查找class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        // 特殊情况特殊考虑        if (nums.length == 0) &#123;            return new int[]&#123;-1, -1&#125;;        &#125;        int index = search(nums, target, 0, nums.length - 1);        if (index == -1) &#123;            return new int[]&#123;-1, -1&#125;;        &#125;        return lookAround(nums, index);    &#125;    // 找到和target相等的一个元素的下标    public int search(int[] nums, int target, int begin, int end) &#123;        // 只剩一个数的时候结束递归        if (begin == end) &#123;            return nums[begin] == target ? begin : -1;        &#125;        int middle = (begin + end) / 2;        // 找到答案时结束递归        if (nums[middle] == target) &#123;            return middle;        &#125; else if (nums[middle] &lt; target) &#123;            if (middle == end) &#123;                return search(nums, target, middle, end);            &#125; else &#123;                return search(nums, target, middle + 1, end);            &#125;        &#125; else &#123;            if (middle == begin) &#123;                return search(nums, target, begin, middle);            &#125; else &#123;                return search(nums, target, begin, middle - 1);            &#125;        &#125;    &#125;    // 找到的结果不一定是从左数起的第一个，所以要得到最终结果还要“Look around”    public int[] lookAround(int[] nums, int index) &#123;        int left = index, right = index;        for (int i = index; i &gt;= 0; i--) &#123;            if (nums[i] == nums[index]) &#123;                left--;            &#125;        &#125;        for (int i = index; i &lt; nums.length; i++) &#123;            if (nums[i] == nums[index]) &#123;                right++;            &#125;        &#125;        return new int[]&#123;left + 1, right - 1&#125;;    &#125;&#125;\n\n二分法思路很简单的，但是边界条件有点儿复杂，不过多尝试几次总会得到正确结果的。\n五个月后。。。。\n上面的二分查找和lookAround还是有些瑕疵，尤其是lookAround强行把时间拖到O（N），之前没注意这个问题，现在稍加改写。\n二分查找2.0class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        if (nums.length == 0) &#123;            return new int[]&#123;-1, -1&#125;;        &#125;        int index = binarySearch(nums, target, 0, nums.length - 1);        if (index == -1) &#123;            return new int[]&#123;-1, -1&#125;;        &#125;        return lookAround(nums, index);    &#125;    private int binarySearch(int[] nums, int target, int start, int end) &#123;        if (start &gt; end) &#123;            return -1;        &#125;        int mid = (start + end) / 2;        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            return binarySearch(nums, target, mid + 1, end);        &#125; else &#123;            return binarySearch(nums, target, 0, mid - 1);        &#125;    &#125;    private int[] lookAround(int[] nums, int index) &#123;        int left = index, right = index;        for (int i = index; i &gt;= 0; i--) &#123;            if (nums[i] == nums[index]) &#123;                left--;            &#125; else &#123;                break;            &#125;        &#125;        for (int i = index; i &lt; nums.length; i++) &#123;            if (nums[i] == nums[index]) &#123;                right++;            &#125; else &#123;                break;            &#125;        &#125;        return new int[]&#123;left + 1, right - 1&#125;;    &#125;&#125;\n\n复杂度一次遍历\n\n时间复杂度：O（N）\n空间复杂度：O（1）\n\n二分查找\n时间复杂度：O（log N）\n空间复杂度：不考虑递归的话是O（1）\n","categories":["LeetCode"]},{"title":"Linux定时任务","url":"/2021/06/20/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"一般来说，我更新一篇博客需要经过以下两步：\n\n用Typora在windows上写好markdown文章，生成html并push到github的仓库里\nssh登录我的服务器，执行git pull更新。（因为服务器被墙了，所以我还得借助舍友的梯子才能ssh TAT\n\n可以写一个脚本，在对应目录下执行git pull，并使其周期性执行，让繁琐工作自动化。\n\n\n脚本pull.sh:\n#!/usr/bin/env bash# cd 到博客目录下cd carpediemtal.github.io || exitgit pull\n\nCrontabcron是一款类Unix的操作系统下的基于时间的任务管理系统。用户们可以通过cron在固定时间、日期、间隔下，运行定期任务（可以是命令和脚本）。cron常用于运维和管理，但也可用于其他地方，如：定期下载文件和邮件。\n通常，任务时间表（crontab）文件储存的指令被crond守护进程激活，守护进程在后台运行，并每一分钟检查是否有定期的作业需要执行。这类作业一般称为cron jobs。\n命令参数：\nOptions: -u &lt;user&gt;  define user -e         edit user&#x27;s crontab -l         list user&#x27;s crontab -r         delete user&#x27;s crontab -i         prompt before deleting -n &lt;host&gt;  set host in cluster to run users&#x27; crontabs -c         get host in cluster to run users&#x27; crontabs -s         selinux context -x &lt;mask&gt;  enable debugging\n\n时间格式可以参考这个网站：Crontab.guru - The cron schedule expression editor\n\n\n执行下面的命令建立定时执行的任务\n# 编辑定时任务crontab -e# 每隔一小时执行一次* */1 * * * /home/ming/pull.sh# 查看用户的定时任务crontab -l\n\n","categories":["Linux"],"tags":["Linux","crontab","定时任务"]},{"title":"Linux常见问题","url":"/2021/01/12/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","content":"工作过程中难免会遇到问题，遇到问题就去搜索一下，然后照着网上说的步骤，理解或是不理解，解决了问题。\n把自己遇到的问题以及解决方案记录下来，也许对以后的工作有所裨益。\n&lt;! – more –&gt;\nNginx# restartservice nginx restart# confignano /etc/nginx/nginx.conf# 301 redirect# /etc/nginx/nginx.confserver &#123;\tlisten       80 default_server;        listen       [::]:80 default_server;        server_name  m1ng.xyz;        return       301 https://linjinming.gitee.io/;    &#125;\n\nNginx 403 Forbidden\n\nps发现运行用户为nginx，不合理，在配置中改成root：\n\n\nPath用ssh连接服务器后，没有语法高亮，而 ~&#x2F;.bashrc里似乎有高亮的相关设置。我在 ~&#x2F;.bashrc里设置了环境变量，但每次都需要source ~&#x2F;.bashrc一下。\n解决方法：https://blog.csdn.net/weixin_43937316/article/details/89215023\n","categories":["OS"]},{"title":"Long time no see","url":"/2019/09/26/Long-time-no-see/","content":"新硬盘  新起点咬牙换了固态硬盘并且加了个内存条，大换血，果然机械硬盘是最短的板，换了硬盘之后，性能大幅度提升，让我们重新开始吧。\n","categories":["Essay"]},{"title":"Memory Management","url":"/2020/08/13/Memory-Management/","content":"\n\n\nWhy Memory Management没有内存管理的时代（单进程）岁月静好，而多进程出现了问题\n虚拟内存\n目的\n让物理内存扩充成更大的逻辑内存，从而让程序有更多的可使用内存\n\n内存分页\n概念\n\n每个程序有自己的地址空间，这些地址空间被分为很多拥有连续地址范围的页面\n程序运行时，并非所有页面都要加载进内存。只有需要时，页面才被OS映射到物理内存\n页面可以被交换（和磁盘）\n程序里用到的是虚地址\n\n\n分页系统地址映射\n\nMMU（内存管理单元）\n\n作用\n\n持有页和页框的映射表，负责地址空间和物理内存的转换\n\n\n虚拟地址到物理地址的翻译过程\n\n\n\n页面置换算法\n\n什么情况下需要进行页面置换\n\n新的进程没有足够的内存\n\n\n分类\n\n最优置换算法（OPT）\n\n特点\n\nOptimal but unreliazable\nPage fault数最小\n替换最后使用的进程\n\n\n作用\n\n业界标杆，仅做参考\n\n\n\n\nLRU\n\n将最近最久未使用的页面替换出\n\n\nNRU\n\n状态位\n\nR\n\n页面被访问一次设置为1，定期清零\n\n\nM\n\n页面被修改一次设置为1\n\n\n\n\n缺页中断时，将RM编号最小的页面替换出去\n\n\n\nFIFO\n\n先进先出\n\n\n第二次机会算法\n\nFIFO的改进，如果页面被访问过，多一次不被替换的机会\n\n\n时钟clock\n\n第二次机会算法的改进，将链表首位相连\n\n\n\n\n\n\n\n\n\n内存分段\n特点\n\n段的长度可以不同，并且可以动态增长\n使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护\n\n\n缺点\n\n内存碎片\n内存交换效率低\n\n\n\n段页式\n先将地址空间划分为段，段内再划分页面\n\n","categories":["OS"]},{"title":"Linux进程","url":"/2021/04/26/Linux%E8%BF%9B%E7%A8%8B/","content":"","categories":["Linux"],"tags":["linux","process"]},{"title":"OS introductions","url":"/2020/05/12/OS-introductions/","content":"OS Introduction\nComputerSoftware\nUser Mode\n\nUser interface program\n\nFeatures\n\nA subset instructions are available\nThe instructions that affect control of hardware or IO is forbidden in this mode\n\n\n\n\nKernel Mode\n\nOS runs in here， provides the base for all the other software\n\nFeatures\n\nComplete Access to Hardware\nexecute any instructions the machine is capable of executing\n\n\n\n\n\nHardware\n\nWhat is An OS?A software runs in kernel modewhich can provide a clean abstract set of resources instead of the messy hardwareOS as an extended machine\nno one want to deal with disk at hardware level\nOS contains many drivers for controlling IO devices\nThe abstraction is the key to manage all these complexities\n\nOS as a Resource manager\ntime\n\ne.g. multiple print jobs\n\n\nspace\n\n\nHistorytl;drComputer Hardware ReviewProcessors\nCPU is Brain\n\nMemoryDisksIO devices","categories":["OS"]},{"title":"Object类的方法","url":"/2020/10/20/Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/","content":"equals和hashCodeequalspublic boolean equals(Object obj) &#123;    return (this == obj);&#125;\n\n默认使用==比较对象的引用，也就是说如果不去覆写，使用equals和==效果是一样的。\nhashCode@HotSpotIntrinsicCandidatepublic native int hashCode();\n\nhashCode()是一个native方法，值由对象的存储地址计算得出（字符串类型的hash值根据字符串内容计算）。\n为什么需要覆写equals和hashCode方法两个方法的作用都是比较两个对象在逻辑上是否相等。equals可靠，而hashCode性能更强。\nObject默认的equals和hashCode方法基本没什么用。\n所以如果要做大量的对比，可以先用hashCode做第一步筛选，如果hashCode相同再用equals做出最后的判断。\n\n情景一：我有一个List，元素类型是Student（List），我想对List中的元素去重，可以使用List.stream().distinct()方法，但是需要告诉java怎么样的两个Student才能称之为equal。\n情景二：HashMap中添加自定义类型的key时，需要覆写equals和hashCode方法，原因要从HashMap的原理说起。\n\n如何覆写equals和hashCode方法equals方法判断相等，hashCode值必须相等。hashCode值相等，equals方法可以不想等。\n所以hashCode相等是equals的必要不充分条件。\n覆写equals时需要考虑自反性、对称性、传递性、一致性（离散数学里关系的性质）。\ntoStringSystem.out.println()时默认的方法，默认为”类名@hashCode”。\nclone@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException;\n\n如果对象的类没有实现Cloneable接口，调用clone方法就会抛出CloneNotSupportedException。\n","categories":["Java"]},{"title":"Observer","url":"/2020/05/18/Observer/","content":"Observer\n定义定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。何时可以用到两个Object需要互通有无的时候\n\n实现引入一个Observer类，由他来完成消息通知Observer类在通知方注册，又包含被通知方的信息package eternal.fire;public class Main &#123;    public static void main(String[] args) &#123;        Admin admin = new Admin();        Customer customer = new Customer();        Store store = new Store();        store.addObserver(admin);        store.addObserver(customer);        store.addObserver(new ProductObserver() &#123;            @Override            public void onPublished(Product product) &#123;                System.out.println(&quot;Icognition class:&quot; + product);            &#125;            @Override            public void onPriceChanged(Product product) &#123;                System.out.println(&quot;Icognition class:&quot; + product);            &#125;        &#125;);        store.addNewProduct(&quot;R7-2700&quot;, 1000);        store.addNewProduct(&quot;RX-580&quot;, 1099);    &#125;&#125;\n\n\n\npackage eternal.fire;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;public class Store &#123;    private List&lt;ProductObserver&gt; observers = new LinkedList&lt;&gt;();    private Map&lt;String, Product&gt; products = new HashMap&lt;&gt;();    public void addObserver(ProductObserver productObserver) &#123;        this.observers.add(productObserver);    &#125;    public void removeObserver(ProductObserver productObserver) &#123;        this.observers.remove(productObserver);    &#125;    public void addNewProduct(String name, double price) &#123;        Product product = new Product(name, price);        products.put(name, product);        observers.forEach(productObserver -&gt; productObserver.onPublished(product));    &#125;    public void setProductPrice(String name, double price) &#123;        Product product = products.get(name);        product.setPrice(price);        observers.forEach(productObserver -&gt; productObserver.onPriceChanged(product));    &#125;&#125;\n\n\n\npackage eternal.fire;public interface ProductObserver &#123;    void onPublished(Product product);    void onPriceChanged(Product product);&#125;\n\n\n\npackage eternal.fire;public class Product &#123;    public String name;    public double price;    public Product(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Product&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &#x27;&#125;&#x27;;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;&#125;\n\n\n\npackage eternal.fire;public class Admin implements ProductObserver&#123;    @Override    public void onPublished(Product product) &#123;        System.out.println(&quot;[Admin] message received:&quot; + product);    &#125;    @Override    public void onPriceChanged(Product product) &#123;        System.out.println(&quot;[Admin] price message received:&quot; + product);    &#125;&#125;\n\n\n\npackage eternal.fire;public class Customer implements ProductObserver&#123;    @Override    public void onPublished(Product product) &#123;        System.out.println(&quot;[customer]message received:&quot; + product);    &#125;    @Override    public void onPriceChanged(Product product) &#123;        System.out.println(&quot;[customer]price message received:&quot; + product);    &#125;&#125;\n\n优势耦合性小扩充方便","categories":["Design Patterns"]},{"title":"Process","url":"/2020/08/12/Process/","content":"definitionThe running program\nProcess versus Thread内存\n进程有独立的内存空间\n线程之间共享内存空间\n\n\n\n代价\n创建进程开销大\n创建线程开销小\n\n通信\n进程之间通信需要ipc\n线程之间通信更方便\n\n定义\n进程是资源（CPU、内存等）分配的基本单位\n线程是进程的一个实体\n\nInternal StructureCode  segment为什么代码块和数据块要分开？清晰。一会数据一会代码不便于阅读。代码块和数据块对于操作偶读需求不一样，分开便于权限管理。代码去冗余，节约空间。对于程序中一段需要反复处理数据的函数，若数据与指令混合装载至内存，每次数据的不同必然导致内存的浪费。\nStack segment有没有栈是程序和进程的区别之一\nData segmentAddress Space存放地址的一片空间\n\nKernel Space\n操作系统代码本身\n\nUser Space\n\nKernel Mode&amp;User Mode\n\n\nPCB保存状态和案发现场\n\nProcess Model\n\nCreation\nSystem initialization\ncall by a running process\nuser request\ninitiation of a batch job\n\n","categories":["OS"]},{"title":"QQ聊天机器人","url":"/2020/05/30/QQ%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/","content":"QQ聊天机器人-教程向这篇文章将引导大家如何去写一个QQ聊天机器人。在此之前，先给大伙儿展示一下本fw的Robot的一些特点和功能：\n\n\nName: Arina\nAttribute: 萌妹子\n官网：http://47.98.252.1:7000/arina\n\n\n功能：发送以#为前缀的消息可以触发图灵机器人的功能，这些功能包含但不限于：\n天气查询\n数学运算\n聊天对话\n单词翻译\n\n不需要#前缀能对一些特定的语句做出反应\n\n\n\n可以在群里@其他人或者禁言（需要管理员权限）可以通过接口向指定的群手动发送消息\n\n定时天气播报每天早上8点准时向qq群播送今日天气状况，误差小于2秒。\n\n\n定时晚安每晚12点，可以从指定的文件里随机抽取一行向qq群发送晚安。\n\n\n\n\n\n\n记录清醒时长回复“zao”或“wan”可以触发功能。\n\n\n\n\n疫情数据查询回复关键字 “疫情数据 area”可以触发功能，栗子：\n复读机回复关键字“进入复读模式”、“关闭复读模式”可以触发功能。\nArina会重复你说的话。\n\n\n彩虹屁回复关键字“夸xx”即可触发。\n\n\n\n\nNMSL回复关键字“骂xx”即可触发。\n\n\n学习回复关键字“跟我学 XX YY”即可触发。\n\n\nArina的个人页面\n\n现在页面还很简陋，功能也比较少，以后会添加更多有意思的功能。\n需要的技能或工具：\n服务器一个（如果你想让robot 24小时在线）\nQQ小号一个\n精通java（的拼写）\n对Http有所了解\n会使用java向服务器指定的端口发送GET请求\n会使用java对文件进行读取操作\n会使用java创建线程（定时推送时所需）\n掌握linux常用命令若干（可以随时百度）\n会使用maven进行依赖管理和打包部署\n会JSON和JavaBean的相互转换（调天气查询api以及疫情数据api时所需）\n会使用Spring Boot编写web服务器（接受cqhttp插件的post请求以及对robot页面的get请求）\n会使用html+css+JavaScript+jquery+bootstrap（写页面时所需）\n会使用一种模板引擎（比如ThymeLeaf，前后端交互所需）\n图灵机器人（可以去官网免费领取）\n不抛弃、不放弃（坑实在太多了）\n\n本项目基于：\n酷Q\n酷Q插件：CQHTTP（酷Q本身使用易语言编写的，这就对不熟悉易语言的人造成很大障碍，这个插件通过 HTTP 对 酷Q 的事件进行上报以及接收 HTTP 请求来调用 酷Q 的 DLL 接口，从而可以使用其它语言编写 酷Q 插件。现已支持 WebSocket。不得不说，这是个绝妙的注意。\njava\nSpring Boot\n\n本fw使用的开发平台：\n全宇宙第一的Intellij IDEA 2020\n\nEdge浏览器\n\n\n还有好多作业没做，等我做完在更（逃\n酷q和cqhttp介绍酷q酷q是类似qq客户端的一个软件，提供了许多基本的功能（发送接收消息，群管理等）。酷q本身提供了一些功能（自动回复，图灵机器人插件），但这些功能仍然比较匮乏，想要增加新的功能，就需要编写酷q插件。但是编写酷q插件需要用到易语言，因此像我这种不会易语言的就变得束手无策。\ncqhttpcqhttp是酷q的一个插件，这个插件通过 HTTP 对 酷Q 的事件进行上报以及接收 HTTP 请求来调用 酷Q 的 DLL 接口，从而可以使用其它语言编写 酷Q 插件。于是，我就可以用java来实现我想要的功能了。\n购买服务器Arina需要在一个24小时不关机的电脑上运行，如果愿意自己的电脑永远不关机，也可以不需要服务器。\n服务器可以上阿里云买最便宜的，能用就行。\n可以不用域名（域名备案很麻烦），直接通过ip地址访问服务器。\n服务器开放端口比如我的NoVNC运行在服务器的9000端口下，我需要修改安全组策略，对9000端口“放行”。\n如何修改安全组策略取决于你的服务器供应商，请自行百度。\n酷q在linux环境下的运行酷q在windows下可以简单的安装运行，但在linux下需要通过wine借助docker来运行。\n基本用法：\n$ docker pull richardchien/cqhttp:latest$ mkdir coolq  # 用于存储 酷Q 的程序文件$ docker run -ti --rm --name cqhttp-test \\             -v $(pwd)/coolq:/home/user/coolq \\  # 将宿主目录挂载到容器内用于持久化 酷Q 的程序文件             -p 9000:9000 \\  # noVNC 端口，用于从浏览器控制 酷Q             -p 5700:5700 \\  # CQHTTP 插件开放的端口             -e COOLQ_ACCOUNT=123456 \\ # 要登录的 QQ 账号，可选但建议填             -e CQHTTP_POST_URL=http://example.com:8080 \\  # 事件上报地址             -e CQHTTP_SERVE_DATA_FILES=yes \\  # 允许通过 HTTP 接口访问 酷Q 数据文件             richardchien/cqhttp:latest\n\n这部分请参考\n\nhttps://github.com/CoolQ/docker-wine-coolq（原版镜像）\nhttps://cqhttp.cc/docs/4.15/#/Docker（安装了cqhttp插件的镜像）\n\n获取并配置图灵机器人api key上官网http://www.turingapi.com/注册领取。\n获取到之后手动添加到酷q的图灵机器人插件里：\n\n\n图灵机器人本身有丰富的功能，免费版的api调用次数有限制。到此为止，robot就像模像样了。根据我的体验，这个图灵机器人并不是很智能，有时候像个智障，远远不及小爱同学或者cortana，但毕竟是免费的。\n核心：cqhttp插件的使用（java）安装使用cqhttp，可以手动给酷q安装插件，也可以用作者预先配置好的镜像直接运行docker。这部分内容请参考cqhttp的官方文档：https://cqhttp.cc/docs/4.15/#/。\n注意留心cqhttp插件上报事件的端口。\nAPI\n\n\n\n\n\n\n\n发送qq消息cqhttp插件可以监听指定端口的事件，我们需要根据想要发送的内容拼接url，向服务器的指定端口发送get请求。\nimport org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;public class Utils &#123;    private static final Logger log = LoggerFactory.getLogger(Utils.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    public static void sendGroupMessage(String message) throws URISyntaxException, IOException, InterruptedException &#123;        log.info(&quot;正准备构造HttpRequest&quot;);        String url = String.format(&quot;http://47.98.252.1:5700/send_group_msg?group_id=549594617&amp;message=%s&quot;, message.replace(&quot; &quot;, &quot;%20&quot;).replace(&quot;\\n&quot;, &quot;%0a&quot;));// main:549594617 测试群：851736129        log.info(&quot;构造好的url：&#123;&#125;&quot;, url);        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正准备用Http Client向服务器发送get请求&quot;);        httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());    &#125;&#125;\n\nurl中，group_id参数是群号或者qq号，message参数是想要发送的内容。上面是用java编写的构造url并利用httpClient向服务器的5700（端口取决于自己的设置）端口发送get请求的代码。\n拼接url参数的时候，注意空格、换行符以及特殊字符的转义，比如空格在url里是%20，换行符在url里是%0a，否则会出现异常（比如发送的内容不能含有空格）。\n注意服务器的安全组策略，需要开放指定的端口才行（我这儿是5700）。\n禁言群用户import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;public class Utils &#123;    private static final Logger log = LoggerFactory.getLogger(Utils.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();        public static void setGroupBan(long userId, int duration) throws URISyntaxException, IOException, InterruptedException &#123;        log.info(&quot;正在准备构造HttpRequest&quot;);        String url = String.format(&quot;http://47.98.252.1:5700/set_group_ban?group_id=549594617&amp;user_id=%d&amp;duration=%d&quot;, userId, duration);        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正准备用Http Client向服务器发送get请求&quot;);        httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());    &#125;&#125;\n\n这其实和发送qq消息的过程一样，只是url的参数有所不同。需要设置群号，qq号和禁言的时间。\n定时发送消息起初我的实现思路是新创建一个线程，不停地判断当前的时间，等到指定的时间再执行相关的代码。\n后来我遇到一些我无法解决问题，把整个项目用spring重新组织了一遍。\n用了spring之后，事情就变得简单起来了，定时发送消息可以通过spring的注解@Scheduled(fixedRate = 1000)实现。\n栗子：\n@Scheduled(fixedRate = 1000)public void resetMapAndIndex() &#123;    LocalDateTime now = LocalDateTime.now();    if (now.getHour() == 3 &amp;&amp; now.getMinute() == 0 &amp;&amp; now.getSecond() == 0) &#123;        log.info(&quot;凌晨三点整，正在重置map和index&quot;);        map.clear();        index = 0;    &#125;&#125;\n\n这个方法每隔一秒执行一次，判断时间再执行相应的操作就可以达成目的。\n定时晚安功能如果是每天都不变的一句话，未免过于单调了。可以从以下文本中随机抽取一行作为今晚要发送的消息。\n要想身体好，睡觉不蒙脑。早睡早起，没病惹你。早睡早起，清爽欢喜;迟睡迟起，强拉眼皮。早睡早起，赛过人参补身体。早睡早起拥有健康生活。睡眠好身体才好。睡前洗脚，胜吃补药。晚餐少喝水，睡前不饮茶。晚上开窗，一夜都香。开启心灵之窗，共同关注睡眠。科学管理睡眠。瞌睡没根，越睡越深。良好睡眠、健康人生。培养良好睡眠习惯，保持健康生活方式。食不多言，寝不多语。适当吃睡，无病增岁。科学享睡，健康无病。不觅仙方觅睡方。吃罢中饭睡一觉，健健康康活到老。吃洋参，不如睡五更。坐有坐相，睡有睡相，睡觉要像弯月亮。坐有坐相，睡有睡相，睡觉要像弯月亮。科学享睡，健康无病。不觅仙方觅睡方。吃罢中饭睡一觉，健健康康活到老。吃洋参，不如睡五更。吃药十付，不如独宿一夜。充足睡眠，身心健康。关注睡眠障碍，提倡科学睡眠。合理安排生活，拥有健康睡眠。健康生活，良好睡眠。今天的沉睡成就明天的活力。开启心灵之窗，共同关注睡眠。科学管理睡眠。瞌睡没根，越睡越深。良好睡眠、健康人生。培养良好睡眠习惯，保持健康生活方式。食不多言，寝不多语。适当吃睡，无病增岁。适度少睡眠，可以保长寿。睡出健康来。睡觉不蒙头，活到九十九。睡眠，健康的选择。\n\n思路是生成一个指定范围内的随机数作为行数，读取指定行的内容并定时发送。\npackage eternal.fire.springbootrobot;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.io.*;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.nio.charset.StandardCharsets;import java.time.LocalDateTime;@Componentpublic class GoodNight &#123;    private static final Logger log = LoggerFactory.getLogger(GoodNight.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    public String getWords() throws IOException &#123;        log.info(&quot;正在尝试从文本文件里随机抽取一行作为晚安语录&quot;);        InputStream inputStream = getClass().getResourceAsStream(&quot;/goodNight.txt&quot;);        Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);        BufferedReader bufferedReader = new BufferedReader(reader);        //文件有43行        int line = ((int) (Math.random() * 100)) % 43 + 1;        String ans = &quot;&quot;;        for (int i = 0; i &lt; line; i++) &#123;            ans = bufferedReader.readLine();        &#125;        return ans + &quot;大家晚安＜(▰˘◡˘▰)&quot;;    &#125;    public void broadcastGoodNight() throws IOException, InterruptedException, URISyntaxException &#123;        String words = getWords();        Utils.sendGroupMessage(words);    &#125;    @Scheduled(fixedRate = 1000)    public void broadcast() throws IOException, InterruptedException, URISyntaxException &#123;        LocalDateTime now = LocalDateTime.now();        if (now.getHour() == 0 &amp;&amp; now.getMinute() == 0 &amp;&amp; now.getSecond() == 0) &#123;            log.info(&quot;晚上24点整，正准备播报晚安&quot;);            broadcastGoodNight();        &#125;    &#125;&#125;\n\n定时天气播报首先需要一个高德地图查询天气的api，可以去官网免费申请。向这个api发送get请求可以得到想要的天气数据。\n返回的天气数据是json模样的字符串，我们需要把字符串转为java bean，这样操作起来更方便，因此需要准备一个接受数据的java bean：Weather。我这里java bean和定时发送的代码写在了一起。\n得到java bean之后，就可以定时发送天气情况了。\n旧版本代码package eternal.fire.springbootrobot.weather;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import eternal.fire.springbootrobot.Utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;import java.time.LocalDateTime;import java.util.List;@Componentpublic class Weather &#123;    public String status;    public String count;    public String info;    public String infocode;    public List&lt;Live&gt; lives;    private static final Logger log = LoggerFactory.getLogger(Weather.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    public String generateString(HttpClient httpClient) throws IOException, InterruptedException, URISyntaxException &#123;        log.info(&quot;正在通过高德api获取西峰区天气状况，结果将以字符串形式返回给调用函数&quot;);        log.info(&quot;构造HttpRequest&quot;);        String url = &quot;https://restapi.amap.com/v3/weather/weatherInfo?key=b74ab54158c425e0ddbe4db7dce8624b&amp;city=621002&quot;;        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正在通过http client发送构造好的HttpRequest，并获得天气查询结果&quot;);        HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());        log.info(&quot;正在将查询到的天气json转化为Java Bean&quot;);        String json = httpResponse.body();        ObjectMapper mapper = new ObjectMapper();        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        Weather weather = mapper.readValue(json, Weather.class);        log.info(&quot;正在准备拼接字符串&quot;);        Live live = weather.lives.get(0);        String result = &quot;今日天气预报来啦~++++播报时间:&quot; + live.reporttime + &quot;++++省份：&quot; + live.province + &quot;++++城市：&quot; + live.city + &quot;++++天气：&quot; + live.weather                + &quot;++++温度：&quot; + live.temperature                + &quot;++++风向：&quot; + live.winddirection + &quot;++++风力：&quot; + live.windpower + &quot;++++湿度：&quot; + live.humidity;        result = result.replaceAll(&quot; &quot;, &quot;+&quot;);        log.info(&quot;拼接完毕，结果：&#123;&#125;&quot;, result);        return result;    &#125;    public void broadcastWeather() throws InterruptedException, IOException, URISyntaxException &#123;        log.info(&quot;正准备向群里播报天气&quot;);        log.info(&quot;获得天气状况（字符串）&quot;);        String result = generateString(httpClient);        Utils.sendGroupMessage(result);        log.info(&quot;播报完毕&quot;);    &#125;    @Scheduled(fixedRate = 1000)    public void broadcast() throws InterruptedException, IOException, URISyntaxException &#123;        LocalDateTime now = LocalDateTime.now();        if (now.getHour() == 8 &amp;&amp; now.getMinute() == 0 &amp;&amp; now.getSecond() == 0) &#123;            log.info(&quot;早上八点整，正准备播报天气&quot;);            broadcastWeather();        &#125;    &#125;&#125;\n\n新版本代码package eternal.fire.springbootrobot.weather;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import eternal.fire.springbootrobot.Utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;import java.time.LocalDateTime;import java.util.List;@Componentpublic class Weather &#123;    private static final Logger log = LoggerFactory.getLogger(Weather.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    private String status;    private String count;    private String info;    private String infocode;    private List&lt;Forecasts&gt; forecasts;    public String getStatus() &#123;        return status;    &#125;    public void setStatus(String status) &#123;        this.status = status;    &#125;    public String getCount() &#123;        return count;    &#125;    public void setCount(String count) &#123;        this.count = count;    &#125;    public String getInfo() &#123;        return info;    &#125;    public void setInfo(String info) &#123;        this.info = info;    &#125;    public String getInfocode() &#123;        return infocode;    &#125;    public void setInfocode(String infocode) &#123;        this.infocode = infocode;    &#125;    public List&lt;Forecasts&gt; getForecasts() &#123;        return forecasts;    &#125;    public void setForecasts(List&lt;Forecasts&gt; forecasts) &#123;        this.forecasts = forecasts;    &#125;    public String generateString(HttpClient httpClient) throws IOException, InterruptedException, URISyntaxException &#123;        log.info(&quot;正在通过高德api获取西峰区天气状况，结果将以字符串形式返回给调用函数&quot;);        log.info(&quot;构造HttpRequest&quot;);        String url = &quot;https://restapi.amap.com/v3/weather/weatherInfo?key=b74ab54158c425e0ddbe4db7dce8624b&amp;city=621002&amp;extensions=all&quot;;        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正在通过http client发送构造好的HttpRequest，并获得天气查询结果&quot;);        HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());        log.info(&quot;正在将查询到的天气json转化为Java Bean&quot;);        String json = httpResponse.body();        ObjectMapper mapper = new ObjectMapper();        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        Weather weather = mapper.readValue(json, Weather.class);        log.info(&quot;正在准备拼接字符串&quot;);        Forecasts forecasts = weather.forecasts.get(0);        Casts today = forecasts.getCasts().get(0);        Casts tomorrow = forecasts.getCasts().get(1);        String result = String.format(&quot;天气预报来啦~\\n&quot; +                        &quot;城市：%s\\n&quot; +                        &quot;播报时间：%s\\n&quot; +                        &quot;今日~\\n&quot; +                        &quot;日期：%s\\n&quot; +                        &quot;白天天气：%s\\n&quot; +                        &quot;夜间天气：%s\\n&quot; +                        &quot;白天温度：%s\\n&quot; +                        &quot;夜间温度：%s\\n&quot; +                        &quot;白天风向：%s\\n&quot; +                        &quot;夜间风向：%s\\n&quot; +                        &quot;风力：%s\\n&quot; +                        &quot;\\n&quot; +                        &quot;明日~\\n&quot; +                        &quot;日期：%s\\n&quot; +                        &quot;白天天气：%s\\n&quot; +                        &quot;夜间天气：%s\\n&quot; +                        &quot;白天温度：%s\\n&quot; +                        &quot;夜间温度：%s\\n&quot; +                        &quot;白天风向：%s\\n&quot; +                        &quot;夜间风向：%s\\n&quot; +                        &quot;风力：%s&quot;,                forecasts.getProvince() + forecasts.getCity(), forecasts.getReporttime().toString(),                today.getDate(), today.getDayweather(), today.getNightweather(), today.getDaytemp(), today.getNighttemp(), today.getDaywind(), today.getNightwind(), today.getDaypower(),                tomorrow.getDate(), tomorrow.getDayweather(), tomorrow.getNightweather(), tomorrow.getDaytemp(), tomorrow.getNighttemp(), tomorrow.getDaywind(), tomorrow.getNightwind(), tomorrow.getDaypower());        log.info(&quot;拼接完毕，结果：&#123;&#125;&quot;, result);        return result;    &#125;    public void broadcastWeather() throws InterruptedException, IOException, URISyntaxException &#123;        log.info(&quot;正准备向群里播报天气&quot;);        log.info(&quot;获得天气状况（字符串）&quot;);        String result = generateString(httpClient);        Utils.sendGroupMessage(result);        log.info(&quot;播报完毕&quot;);    &#125;    @Scheduled(fixedRate = 1000)    public void broadcast() throws InterruptedException, IOException, URISyntaxException &#123;        LocalDateTime now = LocalDateTime.now();        if (now.getHour() == 8 &amp;&amp; now.getMinute() == 0 &amp;&amp; now.getSecond() == 0) &#123;            log.info(&quot;早上八点整，正准备播报天气&quot;);            broadcastWeather();        &#125;    &#125;&#125;\n\n新旧版本对比旧版本\n\n\n新版本\n\n\n用Spring监听cqhttp上报的事件之前我用socket监听cqhttp的事件，但是bug很多，有一些是我百思不得其解的，后来觉得用Spring 是个好主意，果然用Spring之后就没什么问题了，Spring 天下无敌啊。\n\n\n具体做法是编写一个Controller，监听根路径的所有post事件（@PostMapping(&quot;/&quot;)），从Spring传入的HTTPServletRequest中读取事件信息，并利用HTTPServletResponse作出回应。\n@Controllerpublic class MyController &#123;\t@PostMapping(&quot;/&quot;)    public void handle(HttpServletRequest request, HttpServletResponse response)&#123;        ......    &#125;\n\n疫情数据查询疫情数据查询时由用户主动发起的事件，所以我们需要知道用户发送了什么。cqhttp插件会将所有的事件上报到指定的端口，我们可以通过监听端口来获得事件的内容。\n首先我们需要从用户发送的消息中判断所要查询的地区。\n然后同样我们也需要一个查询疫情数据的api（我这儿使用的是https://lab.isaaclin.cn/nCoV/zh）。\n准备一个java bean用来接受存储数据。\npackage eternal.fire.springbootrobot.covid19;import java.util.List;public class CovidData &#123;    public List&lt;Result&gt; results;&#125;\n\npackage eternal.fire.springbootrobot.covid19;public class Result &#123;    public String countryName;    public String countryEnglishName;    public int currentConfirmedCount;    public int confirmedCount;    public int curedCount;    public int deadCount;    @Override    public String toString() &#123;        return String.format(&quot;国家名称：%s，国家名称（英文）：%s，现存确诊人数：%d，累计确诊人数：%d，治愈人数：%d，死亡人数：%d&quot;,                countryName, countryEnglishName, currentConfirmedCount, confirmedCount, curedCount, deadCount);    &#125;&#125;\n\n最后将json转为java bean并回复消息（这里利用了cqhttp的快速回复功能，跟之前的发送方式有所不同）。\n\n\n\n\npublic void getCovidData(HttpServletResponse response, Post post) throws URISyntaxException, IOException, InterruptedException &#123;    log.info(&quot;正在尝试获取地区名称&quot;);    String province = post.getMessage().substring(4).strip();    log.info(&quot;正在构造HttpRequest&quot;);    String url = String.format(&quot;https://lab.isaaclin.cn/nCoV/api/area?latest=1&amp;province=%s&quot;, province);    HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))            .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)            .header(&quot;Accept&quot;, &quot;*/*&quot;)            .timeout(Duration.ofSeconds(5))            .version(HttpClient.Version.HTTP_2)            .build();    log.info(&quot;正在用http client调用疫情数据查询api&quot;);    HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());    log.info(&quot;正在将json转为Java Bean&quot;);    String json = httpResponse.body();    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);    CovidData covidData = objectMapper.readValue(json, CovidData.class);    log.info(&quot;正在发送消息&quot;);    if (covidData.results.size() == 0) &#123;        reply(response, &quot;unknown area&quot;);    &#125; else &#123;        String content = covidData.results.toString();        reply(response, content);    &#125;&#125;\n\n复读思路是判断用户发送的消息内容，根据消息内容改变类内的repeat变量的值，再根据repeat的值决定复读与否。\n@Controllerpublic class MyController &#123;    private static final Logger log = LoggerFactory.getLogger(MyController.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    private static boolean repeat = false;    @PostMapping(&quot;/&quot;)    public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, URISyntaxException, InterruptedException &#123;        log.info(&quot;正在获取侦测到的上报信息&quot;);        Post post = getPost(request);        if (repeat) &#123;            log.info(&quot;进入复读模式&quot;);            log.info(&quot;开始复读&quot;);            Utils.sendGroupMessage(post.getMessage());            if (post.getMessage().equals(&quot;退出复读模式&quot;)) &#123;                log.info(&quot;退出复读模式&quot;);                repeat = false;            &#125;        &#125; else &#123;            log.info(&quot;进入一般模式&quot;);            if (post.getMessage().equals(&quot;进入复读模式&quot;)) &#123;                repeat = true;            &#125;        &#125;    &#125;&#125;\n\n彩虹屁package eternal.fire.springbootrobot;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;public class RainbowFart &#123;    private static final Logger log = LoggerFactory.getLogger(RainbowFart.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    public static String getRainbowFart() throws URISyntaxException, IOException, InterruptedException &#123;        log.info(&quot;正在构造HttpRequest&quot;);        String url = &quot;https://chp.shadiao.app/api.php&quot;;        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正在用http client调用彩虹屁api&quot;);        HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());        return httpResponse.body();    &#125;&#125;\n\nif (post.getMessage().startsWith(&quot;夸&quot;)) &#123;    log.info(&quot;开始彩虹屁&quot;);    if (post.getMessage().equals(&quot;夸我&quot;)) &#123;        replyCqHttp(response, RainbowFart.getRainbowFart());    &#125; else &#123;        String name = post.getMessage().substring(1);        log.info(&quot;要夸的人是&#123;&#125;&quot;, name);        replyCqHttp(response, RainbowFart.getRainbowFart().replace(&quot;你&quot;, name).replace(&quot;您&quot;, name));    &#125;&#125; \n\n实现思路：调用APIhttps://chp.shadiao.app/api.php获取彩虹屁内容并替换关键字，利用cqhttp的快速回复功能做出回复。\nNMSLpackage eternal.fire.springbootrobot;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.time.Duration;public class Nmsl &#123;    private static final Logger log = LoggerFactory.getLogger(RainbowFart.class);    private static final HttpClient httpClient = HttpClient.newBuilder().build();    public static String getContent() throws URISyntaxException, IOException, InterruptedException &#123;        log.info(&quot;正在构造HttpRequest&quot;);        String url = &quot;https://nmsl.shadiao.app/api.php?level=min&quot;;        HttpRequest httpRequest = HttpRequest.newBuilder(new URI(url))                .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .timeout(Duration.ofSeconds(5))                .version(HttpClient.Version.HTTP_2)                .build();        log.info(&quot;正在用http client调用NMSL api&quot;);        HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());        return httpResponse.body().replace(&quot; &quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;);    &#125;&#125;\n\nif (post.getMessage().startsWith(&quot;骂&quot;)) &#123;    log.info(&quot;开始nmsl&quot;);    if (post.getMessage().equals(&quot;骂我&quot;)) &#123;        replyCqHttp(response, Nmsl.getContent());    &#125; else &#123;        String name = post.getMessage().substring(1);        replyCqHttp(response, Nmsl.getContent().replace(&quot;您&quot;, name).replace(&quot;你&quot;, name));    &#125;&#125;\n\n实现思路和彩虹屁完全一致。\n学习package eternal.fire.springbootrobot;import eternal.fire.springbootrobot.controller.MainController;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class Learn &#123;    public static final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    private static final Logger log = LoggerFactory.getLogger(Learn.class);    public static int learn(String message) &#123;        String[] args = message.split(&quot; &quot;);        log.info(&quot;获取到的内容是&#123;&#125;&quot;, Arrays.toString(args));        if (args.length &lt; 3) &#123;            return -1;        &#125;        map.put(args[1], args[2]);        return 0;    &#125;&#125;\n\nif (post.getMessage().startsWith(&quot;跟我学&quot;)) &#123;    log.info(&quot;开始学习&quot;);    int ans = Learn.learn(post.getMessage());    if (ans == -1) &#123;        replyCqHttp(response, &quot;???&quot;);    &#125; else if (ans == 0) &#123;        replyCqHttp(response, &quot;呐，我学会了哟，你呢w&quot;);    &#125;&#125; else &#123;    if (Learn.map.containsKey(post.getMessage())) &#123;        replyCqHttp(response,Learn.map.get(post.getMessage()));    &#125;&#125;\n\n实现思路：Learn类内维护一个Map，用来存储键值对。每次接收到消息都去map里找是否存在相应的键值对。\n要想数据长生不老，可以把数据写到文件里，或者使用数据库，否则每次应用重启之后，数据都会消失。\n参考资料Arina：http://47.98.252.1:7000/arina\nArina的github（可以看我的源代码）：https://github.com/carpediemtal/Robot\ncqhttp官方文档：https://cqhttp.cc/docs/4.15/#/\n通过wine在docker中运行酷q：https://github.com/CoolQ/docker-wine-coolq\n图灵机器人：http://www.turingapi.com/\n有意思的API：https://shadiao.app/\n———————未完待续———————","categories":["Fun"]},{"title":"REST","url":"/2020/05/11/REST/","content":"REST特点输入输出都是JSON的API接口作用便于第三方调用便于使用js进行交互\n\n编写RestControllerpackage eternal.fire;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/api&quot;)public class ApiController &#123;    @Autowired    UserService userService;    @GetMapping(&quot;/users&quot;)    public List&lt;User&gt; users() &#123;        return userService.getUsers();    &#125;        @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public User user(@PathVariable(&quot;id&quot;) long id) &#123;        return userService.getUserById(id);    &#125;        @PostMapping(&quot;/signin&quot;)    public Map&lt;String, Object&gt; signin(@RequestBody SignInRequest signInRequest) &#123;        try &#123;            User user = userService.signin(signInRequest.email, signInRequest.password);            return Map.of(&quot;user&quot;, user);        &#125; catch (Exception e) &#123;            return Map.of(&quot;error&quot;, &quot;SIGNIN_FAILED&quot;, &quot;message&quot;, e.getMessage());        &#125;    &#125;        public static class SignInRequest&#123;        public String email;        public String password;    &#125;&#125;\n\n\n\n精细化控制防止密码明文输出\n@JsonProperty(access = Access.WRITE_ONLY)public String getPassword() &#123;    return password;&#125;\n\n","categories":["Spring"]},{"title":"RMI DEMO","url":"/2021/04/06/RMI-DEMO/","content":"RMI一个简单的RMI demo。\n\n\n服务端package rmiserver;import java.io.Serial;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;import rmiinterface.RMIInterface;public class ServerOperation extends UnicastRemoteObject implements RMIInterface &#123;    @Serial    private static final long serialVersionUID = 1L;    private static final String CALL_HISTORY = &quot;&quot;&quot;                        通话记录详单：                                                电话号码：18662377270                        起止时间：2021年4月6日21:56:16 到 2021年4月6日21:56:25                                                电话号码：17262894289                        起止时间：2021年4月6日21:56:44 到 2021年4月6日21:56:46                                                电话号码：12345678909                        起止时间：2021年4月6日21:56:59 到 2021年4月6日21:57:01                                    &quot;&quot;&quot;;    protected ServerOperation() throws RemoteException &#123;        super();    &#125;    @Override    public String getCallHistory() throws RemoteException &#123;        return CALL_HISTORY;    &#125;    public static void main(String[] args) &#123;        try &#123; //special exception handler for registry creation            // 这里也可以手动在终端输入：start rmiregistry            LocateRegistry.createRegistry(1099);            System.out.println(&quot;java RMI registry created.&quot;);        &#125; catch (RemoteException e) &#123;            //do nothing, error means registry already exists            System.out.println(&quot;java RMI registry already exists.&quot;);        &#125;        try &#123;            Naming.rebind(&quot;//localhost/MyServer&quot;, new ServerOperation());            System.err.println(&quot;Server ready&quot;);        &#125; catch (Exception e) &#123;            System.err.println(&quot;Server exception: &quot; + e.toString());            e.printStackTrace();        &#125;    &#125;&#125;\n\n对象接口package rmiinterface;import java.rmi.Remote;import java.rmi.RemoteException;public interface RMIInterface extends Remote &#123;    String getCallHistory() throws RemoteException;&#125;\n\n客户端package rmiclient;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import javax.swing.JOptionPane;import rmiinterface.RMIInterface;public class ClientOperation &#123;    public static void main(String[] args) throws MalformedURLException, RemoteException, NotBoundException &#123;        RMIInterface look_up = (RMIInterface) Naming.lookup(&quot;//localhost/MyServer&quot;);        String response = look_up.getCallHistory();        JOptionPane.showMessageDialog(null, response);    &#125;&#125;\n\n运行方法先运行服务端的main函数，再运行客户端的main函数。\n运行结果","categories":["软件构件与中间件"]},{"title":"SPM Review I","url":"/2021/06/23/SPM-Review-I/","content":"SPM Review I\n\n\n\n","categories":["项目管理"],"tags":["SPM","项目管理"]},{"title":"Scheduling","url":"/2020/08/12/Scheduling/","content":"问题有多个就绪的进程或线程，哪一个应该先执行?\nWhen to schedule\nProcess creates\nProcess exits\nProcess blocks on IO\nIO interrupts\n\n\n\nHow to scheduleScheduling Algorithm\n相关概念\n\nThroughput（吞吐量）\n\n单位时间内执行的任务数\n\n\nTurnaround（周转时间）\n\n提交到结束所需时间\n\n\nAverage Turnaround time\n\n平均数\n\n\nWaiting time\n\n在ready queue里等待的时间\n\n\nResponse time\n\n提交到第一次获得响应的时间，不同于周转时间\n\n\nCPU utilization\n\n\n\nCategories\n\nPreemptive &amp; Non-preemptive\n\n抢占式调度算法涉及到优先级\n\n\nBatch\n\nFCFS\nFist come First serve\n\nSJF\nShortest job first\n\n非抢占式\n抢占式\n\n\n\n\nInteractive System\n\nRound-Robin Scheduling\n轮转调度\n\n相关概念\n\nquantum\n\n\n特点\n\n平均周转时间大，response time小\n\n\n一体两面\n\nquantum太大，response time太大\nquantum太小，进程切换频繁\n\n\n\n\nPriority Scheduling\n\n先用轮转调度执行优先级最高的，再执行优先级低的\n\n\nMultiple Queues\n多级队列\n\n类似Priority Scheduling，每层调度算法可以不一样\n计算起来最复杂，最爱考\n\n\nGuaranteed Scheduling\n\nLottery Scheduling\n\nFair Share Scheduling\n\n更公平的Guaranteed Scheduling\n\n\n\n\nReal time\n\nReal time Scheduling\n\n概念\n\n有一个进程集合，里面的进程对时间都有要求，对这组进程的调度就叫实时调度\n\n\nhard real time\n\n不可错过的deadline\n\n\nsoft real time\n\n有deadline，但是错过就错过了吧\n\n\n\n\n\n\n\n\nPriority inversion\n\n概念\n\n低优先级的进程阻塞了高优先级的进程\n\n\n栗子\n\n低优先级的进程进入了关键区，突然切到了高优先级进程，高优先级也要访问关键区，结果被阻塞\n\n\n\n\n\n","categories":["OS"]},{"title":"Shortest Path","url":"/2021/06/19/Shortest-Path/","content":"最短路径问题最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：\n\n确定起点的最短路径问题 - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用Dijkstra算法，若边权为负时则适合使用Bellman-ford算法或者SPFA算法。\n确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。\n确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。\n全局最短路径问题 - 也叫多源最短路问题，求图中所有的最短路径。适合使用Floyd-Warshall算法。\n\n\n\n用于解决最短路径问题的算法被称做“最短路径算法”，有时被简称作“路径算法”。最常用的路径算法有：\n\n迪杰斯特拉 | Ming (m1ng.xyz)\nA*算法\nBellman-Ford算法\nSPFA算法（Bellman-Ford算法的改进版本）\nFloyd-Warshall算法\n\n迪杰斯特拉迪杰斯特拉 | Ming (m1ng.xyz)\nBellman Ford求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特（英语：Lester Ford） 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行|V|-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高。\n为什么要松弛|V|-1次？简单来说，含有V个节点的图中，两个节点间最多有v-1条边。松弛|V|-1次能确保最短路径被发现。\n\n\n栗子\npackage mainimport (\t&quot;fmt&quot;\t&quot;math&quot;)func main() &#123;\tvar edges []Edge\tedges = append(edges, Edge&#123;&#x27;A&#x27;, &#x27;B&#x27;, -1&#125;, Edge&#123;&#x27;A&#x27;, &#x27;C&#x27;, 3&#125;, Edge&#123;&#x27;B&#x27;, &#x27;C&#x27;, 3&#125;, Edge&#123;&#x27;B&#x27;, &#x27;D&#x27;, 2&#125;, Edge&#123;&#x27;B&#x27;, &#x27;E&#x27;, 2&#125;, Edge&#123;&#x27;D&#x27;, &#x27;B&#x27;, 1&#125;, Edge&#123;&#x27;D&#x27;, &#x27;C&#x27;, 5&#125;, Edge&#123;&#x27;E&#x27;, &#x27;D&#x27;, -3&#125;)\tBellmanFord(edges, 5, &#x27;A&#x27;)&#125;const INFINITY = math.MaxInt32type Edge struct &#123;\tsrc   rune\tdest  rune\twight int&#125;func BellmanFord(graph []Edge, n int, src rune) &#123;\t// nodes set\tnodes := make(map[rune]bool)\tfor _, edge := range graph &#123;\t\tif _, ok := nodes[edge.src]; !ok &#123;\t\t\tnodes[edge.src] = true\t\t&#125;\t\tif _, ok := nodes[edge.dest]; !ok &#123;\t\t\tnodes[edge.dest] = true\t\t&#125;\t&#125;\t// distance from src to another node\td := make(map[rune]int)\tfor node := range nodes &#123;\t\td[node] = INFINITY\t&#125;\td[src] = 0\t// relaxation |v| - 1 times\tfor i := 0; i &lt; n-1; i++ &#123;\t\tfor _, edge := range graph &#123;\t\t\tif d[edge.dest] &gt; edge.wight+d[edge.src] &#123;\t\t\t\td[edge.dest] = edge.wight + d[edge.src]\t\t\t&#125;\t\t&#125;\t&#125;\tfor node, dist := range d &#123;\t\tfmt.Printf(&quot;%c--&gt;%c:%d\\n&quot;, src, node, dist)\t&#125;&#125;\n\nFloyd WarshallFloyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法或佛洛依德算法，是解决任意两点间的最短路径的一种算法[2]，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。\nFloyd-Warshall算法的时间复杂度为O(N^3)[4]，空间复杂度为O(N^2)。\n\n\n松弛操作让我想起矩阵链乘：矩阵链乘积 | Ming (m1ng.xyz)\n栗子\npackage mainimport (\t&quot;fmt&quot;\t&quot;math&quot;)func main() &#123;\tvar edges []Edge\tedges = append(edges, Edge&#123;&#x27;A&#x27;, &#x27;B&#x27;, -1&#125;, Edge&#123;&#x27;A&#x27;, &#x27;C&#x27;, 3&#125;, Edge&#123;&#x27;B&#x27;, &#x27;C&#x27;, 3&#125;, Edge&#123;&#x27;B&#x27;, &#x27;D&#x27;, 2&#125;, Edge&#123;&#x27;B&#x27;, &#x27;E&#x27;, 2&#125;, Edge&#123;&#x27;D&#x27;, &#x27;B&#x27;, 1&#125;, Edge&#123;&#x27;D&#x27;, &#x27;C&#x27;, 5&#125;, Edge&#123;&#x27;E&#x27;, &#x27;D&#x27;, -3&#125;)\tFloydWarshall(edges, 5, &#x27;A&#x27;)&#125;const INFINITY = math.MaxInt32type Edge struct &#123;\tsrc   rune\tdest  rune\twight int&#125;func FloydWarshall(graph []Edge, n int, src rune) &#123;\t// C(k)[i][j] means weight of a shortest path from i to j with intermediate vertices belonging to the set &#123;0,1,2,…,k&#125;\tC := make([][]int, n)\tfor i := range C &#123;\t\tC[i] = make([]int, n)\t&#125;\t// initialization\tfor i := 0; i &lt; n; i++ &#123;\t\tfor j := 0; j &lt; n; j++ &#123;\t\t\tif i != j &#123;\t\t\t\tC[i][j] = INFINITY\t\t\t&#125;\t\t&#125;\t&#125;\t// conversion between letter and number\tfor _, edge := range graph &#123;\t\tC[edge.src-&#x27;A&#x27;][edge.dest-&#x27;A&#x27;] = edge.wight\t&#125;\tfor k := 0; k &lt; n; k++ &#123;\t\tfor i := 0; i &lt; n; i++ &#123;\t\t\tfor j := 0; j &lt; n; j++ &#123;\t\t\t\t// relaxation\t\t\t\tif C[i][j] &gt; C[i][k]+C[k][j] &#123;\t\t\t\t\tC[i][j] = C[i][k] + C[k][j]\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\t// output\tfor i := 0; i &lt; n; i++ &#123;\t\tfor j := 0; j &lt; n; j++ &#123;\t\t\tif i != j &#123;\t\t\t\tif C[i][j] &gt; INFINITY/2 &#123;\t\t\t\t\tfmt.Printf(&quot;%c--&gt;%c:∞\\n&quot;, i+&#x27;A&#x27;, j+&#x27;A&#x27;)\t\t\t\t&#125; else &#123;\t\t\t\t\tfmt.Printf(&quot;%c--&gt;%c:%d\\n&quot;, i+&#x27;A&#x27;, j+&#x27;A&#x27;, C[i][j])\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n","categories":["数据结构与算法"],"tags":["数据结构与算法","图","最短路径"]},{"title":"Socket","url":"/2020/12/14/Socket/","content":"","categories":["计网"]},{"title":"Spring Boot:表单输入验证","url":"/2020/05/28/Spring-Boot-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81/","content":"本fw决定写一篇教程向的文章，这篇文章会指导大家如何利用Spring Boot实现网页表单输入验证这样的一个简单的功能。\n\n\n如图，这个简单的应用可以呈现出这样一个允许用户输入数据的页面：只有输入满足长度要求才会跳转到新的页面，否则会提示错误信息。\n本fw用IDE是IntelliJ Idea，所以以Idea为例，向大家展示这个简易项目的全过程（from scratch）。\n\n\n利用Spring Initializr创建一个Spring Boot项目\n\n\n\n名字啥的随便起了，这个无关痛痒。java版本应该至少是java8，本fw电脑上只有jdk14，所以选择的版本是14.\n\n\n这里需要添加两个依赖项，Spring Web和Thymeleaf（Thymeleaf是Spring推荐的一种页面模板语言）。\n项目结构\n\npom.xml的具体配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;xyz.eternal.fire&lt;/groupId&gt;    &lt;artifactId&gt;validate-form-input&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;validate-form-input&lt;/name&gt;    &lt;description&gt;validate form input&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;14&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;6.1.5.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n创建 一个PersonForm类package xyz.eternal.fire;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class PersonForm &#123;    @NotNull    @Size(min = 2, max = 30)    private String name;    @NotNull    @Min(18)    private Integer age;    @Override    public String toString() &#123;        return &quot;Person(name:&quot; + this.name + &quot;, age:&quot; + this.age + &quot;)&quot;;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;&#125;\n\n值得一提的是，这个类有两个属性，一个是name，另一个是age，通过注解限定了name和age的合理取值范围，这个注解之后要搭配BindingResult使用。\n创建一个WebController类package xyz.eternal.fire;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.validation.Valid;@Controllerpublic class WebController implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/results&quot;).setViewName(&quot;results&quot;);    &#125;    @GetMapping(&quot;/&quot;)    public String showForm(PersonForm personForm) &#123;        return &quot;form&quot;;    &#125;    @PostMapping(&quot;/&quot;)    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) &#123;        if (bindingResult.hasErrors()) &#123;            return &quot;form&quot;;        &#125;        return &quot;redirect:/results&quot;;    &#125;&#125;\n\n这个Controller有一个Get方法和Post方法，它们都被map到”&#x2F;“下。\nshowForm方法返回form模板，它包含了一个PersonForm参数的目的是让模板可以把表格的属性和PersonForm这个类关联起来。\ncheckPersonFormInfo方法接受两个参数，PersonForm提供输入的数据，BindingResult和@Valid搭配，用以判断是否满足之前设置的长度限制。如果符合条件，就redirect到&#x2F;results路径，否则返回form模板。\n写HTMLform.html&lt;html&gt;&lt;body&gt;&lt;form action=&quot;#&quot; th:action=&quot;@&#123;/&#125;&quot; th:object=&quot;$&#123;personForm&#125;&quot; method=&quot;post&quot;&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;Name:&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; th:field=&quot;*&#123;name&#125;&quot; /&gt;&lt;/td&gt;            &lt;td th:if=&quot;$&#123;#fields.hasErrors(&#x27;name&#x27;)&#125;&quot; th:errors=&quot;*&#123;name&#125;&quot;&gt;Name Error&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;Age:&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; th:field=&quot;*&#123;age&#125;&quot; /&gt;&lt;/td&gt;            &lt;td th:if=&quot;$&#123;#fields.hasErrors(&#x27;age&#x27;)&#125;&quot; th:errors=&quot;*&#123;age&#125;&quot;&gt;Age Error&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nresults.html&lt;html&gt;&lt;body&gt;Congratulations! You have opened the door to the new world!&lt;/body&gt;&lt;/html&gt;\n\n这两个html文件放在resources的templates目录下。\n运行Idea直接运行\n\n打成jar包用命令行运行先打包\n\n\n\n\n用java -jar命令执行jar包即可，值得一提的是，生成的jar包放在项目的targe里。\n结果如果输入符合条件：\n\n\n否则会提示响应的错误：\n","categories":["Spring"]},{"title":"Spring Boot：上传和下载文件的web应用","url":"/2020/07/21/Spring-Boot%EF%BC%9A%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84web%E5%BA%94%E7%94%A8/","content":"Spring Boot 之 编写一个可以上传和下载文件的web应用最终效果实现了一个可以上传和下载文件的单页面web应用\n\n\n\n\n选择文件并上传：\n\n\n上传成功之后顶部会有绿色的提示消息。\n\n\n上传之后就可以通过自动生成的链接来访问下载，如果所示，也可以通过&lt;img&gt;直接访问。\n可能的用途\n如果有服务器的话，可以把这个应用部署在服务器上，于是就有了一个私人订制的图床\n如果有服务器的话，可以把这个应用部署在服务器上，于是就有了一个私人订制的云盘\n如果有服务器的话，可以把这个应用部署在服务器上，于是就有了一个私人订制的XFTP\n\n技术栈\nSpring Boot\nMaven\nJava IO\nJava Stream\nHtml\nBootstrap（美化页面所需，也可以不用）\n\n步骤创建项目通过Spring Initializr创建一个Spring Boot项目：\n\n\n需要的依赖项：Spring Web，ThymeLeaf。\n最终的Pom文件：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;eternal.fire&lt;/groupId&gt;    &lt;artifactId&gt;uploading-files&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;uploading-files&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;14&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n创建Application类为了启动Spring Boot应用，需要一个Application类。spring-boot-starter-thymeleaf和spring-boot-starter-web已经由Spring Boot自动配置完成，除此之外，我们还需要注册一个MultipartConfigElement类，但是多亏了有Spring Boot，一切都已经自动配置好了。\npackage eternal.fire.uploadingfiles;import eternal.fire.uploadingfiles.storage.StorageProperties;import eternal.fire.uploadingfiles.storage.StorageService;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableConfigurationProperties(StorageProperties.class)public class UploadingFilesApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(UploadingFilesApplication.class, args);    &#125;    @Bean    CommandLineRunner init(StorageService storageService) &#123;        return args -&gt; &#123;            storageService.deleteAll();            storageService.init();        &#125;;    &#125;&#125;\n\n@SpringBootApplication注解等价于：@Configuration+@ComponentScan+@EnableAutoConfiguration。\n@Configuration：告诉Spring被标注的类里有需要注册的定制的@Bean。\n@ComponentScan：告诉Spring去寻找用@Component、@Configuration和@Service标记的类并注册到Spring容器。\n@EnableAutoConfiguration：启动自动配置。\n@BeanCommandLineRunner init(StorageService storageService) &#123;    return args -&gt; &#123;        storageService.deleteAll();        storageService.init();    &#125;;&#125;\n\n在CommandLineRunner类里覆写run方法，就可以在Spring Boot项目启动之后执行run方法内部的代码。上面使用了Lambda函数，其等价于：\n@BeanCommandLineRunner init(StorageService storageService) &#123;    return new CommandLineRunner() &#123;        @Override        public void run(String... args) throws Exception &#123;            storageService.deleteAll();            storageService.init();        &#125;    &#125;;&#125;\n\n这一步的目的是在Spring Boot项目启动的时候删除旧的文件夹，创建新的文件夹。\n作为Spring Boot自动配置的一部分，MultipartConfigElement bean会被自动创建并处于就绪状态。\n创建上传文件的Controllerpackage eternal.fire.uploadingfiles;import eternal.fire.uploadingfiles.storage.StorageFileNotFoundException;import eternal.fire.uploadingfiles.storage.StorageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.Resource;import org.springframework.http.HttpHeaders;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import java.util.stream.Collectors;@Controllerpublic class FileUploadController &#123;    private final StorageService storageService;    @Autowired    public FileUploadController(StorageService storageService) &#123;        this.storageService = storageService;    &#125;    // 从StorageService里找到所有的文件并将其用Thymeleaf渲染到页面    // 用MvcUriComponentsBuilder计算资源的路径，这里的Stream用的很秀，让人眼花缭乱。    @GetMapping(&quot;/&quot;)    public String listUploadFiles(Model model) &#123;        model.addAttribute(&quot;files&quot;, storageService.loadAll().map(path -&gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, &quot;serveFile&quot;, path.getFileName().toString()).build().toUri().toString()).collect(Collectors.toList()));        return &quot;uploadForm&quot;;    &#125;    // 如果有资源，就加载资源并通过Content-Disposition response header向浏览器发送过去。    @GetMapping(&quot;/files/&#123;filename&#125;&quot;)    @ResponseBody    public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) &#123;        Resource file = storageService.loadAsResource(filename);        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\\&quot;&quot; + file.getFilename() + &quot;\\&quot;&quot;).body(file);    &#125;    // 处理浏览器上传的文件并将其保存，渲染上传成功的提示信息。    @PostMapping(&quot;/&quot;)    public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) &#123;        storageService.store(file);        redirectAttributes.addFlashAttribute(&quot;message&quot;, String.format(&quot;You successfully uploaded %s!&quot;, file.getOriginalFilename()));        return &quot;redirect:/&quot;;    &#125;    @ExceptionHandler    public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException exc) &#123;        return ResponseEntity.notFound().build();    &#125;&#125;\n\n页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;uploadForm&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css&quot;          integrity=&quot;sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk&quot; crossorigin=&quot;anonymous&quot;&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot;            integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js&quot;            integrity=&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js&quot;            integrity=&quot;sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;h1 class=&quot;text-primary display-2 text-center&quot; style=&quot;font-family: Lobster,serif&quot;&gt;Upload Files&lt;/h1&gt;    &lt;div th:if=&quot;$&#123;message&#125;&quot;&gt;        &lt;h2 th:text=&quot;$&#123;message&#125;&quot; class=&quot;text-success&quot;&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/&quot;&gt;            &lt;table class=&quot;table table-bordered table-striped&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;File up to load:&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;Upload&quot;/&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;ul class=&quot;list-group&quot;&gt;            &lt;li th:each=&quot;file:$&#123;files&#125;&quot; class=&quot;list-group-item&quot;&gt;                &lt;a th:href=&quot;$&#123;file&#125;&quot; th:text=&quot;$&#123;file&#125;&quot;&gt;&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n这个页面包含三个部分：\n\n可选的上传成功的提示信息\n用来上传文件的表单\n一个list用来显示已经上传的文件\n\nStorageService类需要一个StorageService类以便于Controller层和Storage层交互。\npackage eternal.fire.uploadingfiles.storage;import org.springframework.core.io.Resource;import org.springframework.web.multipart.MultipartFile;import java.nio.file.Path;import java.util.stream.Stream;public interface StorageService &#123;    void init();    void store(MultipartFile file);    Stream&lt;Path&gt; loadAll();    Path load(String fileName);    Resource loadAsResource(String fileName);    void deleteAll();&#125;\n\nStorageService的实现类package eternal.fire.uploadingfiles.storage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.Resource;import org.springframework.core.io.UrlResource;import org.springframework.stereotype.Service;import org.springframework.util.FileSystemUtils;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.net.MalformedURLException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Objects;import java.util.stream.Stream;@Service // 和@Component还有@Bean的作用一样，不过@Service用于标注业务层组件，@Repository用于标注数据访问组件，即DAO组件.public class FileSystemStorageService implements StorageService &#123;    private final Path rootLocation;    @Autowired    public FileSystemStorageService(StorageProperties properties) &#123;        this.rootLocation = Paths.get(properties.getLocation());    &#125;    @Override    public void store(MultipartFile file) &#123;        try &#123;            if (file.isEmpty()) &#123;                throw new StorageException(&quot;Failed to store empty file &quot; + file.getOriginalFilename());            &#125;            Files.copy(file.getInputStream(), this.rootLocation.resolve(Objects.requireNonNull(file.getOriginalFilename())));        &#125; catch (IOException e) &#123;            throw new StorageException(&quot;Failed to store file &quot; + file.getOriginalFilename(), e);        &#125;    &#125;    @Override    public Stream&lt;Path&gt; loadAll() &#123;        try &#123;            return Files.walk(this.rootLocation, 1).filter(path -&gt; !path.equals(this.rootLocation)).map(this.rootLocation::relativize);        &#125; catch (IOException e) &#123;            throw new StorageException(&quot;Failed to read stored files&quot;, e);        &#125;    &#125;    @Override    public Path load(String filename) &#123;        return rootLocation.resolve(filename);    &#125;    @Override    public Resource loadAsResource(String filename) &#123;        try &#123;            Path file = load(filename);            Resource resource = new UrlResource(file.toUri());            if (resource.exists() || resource.isReadable()) &#123;                return resource;            &#125; else &#123;                throw new StorageFileNotFoundException(&quot;Could not read file: &quot; + filename);            &#125;        &#125; catch (MalformedURLException e) &#123;            throw new StorageFileNotFoundException(&quot;Could not read file: &quot; + filename, e);        &#125;    &#125;    @Override    public void deleteAll() &#123;        FileSystemUtils.deleteRecursively(rootLocation.toFile());    &#125;    @Override    public void init() &#123;        try &#123;            Files.createDirectory(rootLocation);        &#125; catch (IOException e) &#123;            throw new StorageException(&quot;Could not initialize storage&quot;, e);        &#125;    &#125;&#125;\n\n配置类package eternal.fire.uploadingfiles.storage;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(&quot;storage&quot;)public class StorageProperties &#123;    /**     * Folder location for storing files     */    private String location = &quot;upload-dir&quot;;    public String getLocation() &#123;        return location;    &#125;    public void setLocation(String location) &#123;        this.location = location;    &#125;&#125;\n\n异常类package eternal.fire.uploadingfiles.storage;public class StorageException extends RuntimeException &#123;    public StorageException(String message) &#123;        super(message);    &#125;    public StorageException(String message, Throwable cause) &#123;        super(message, cause);    &#125;&#125;\n\npackage eternal.fire.uploadingfiles.storage;import eternal.fire.uploadingfiles.storage.StorageException;public class StorageFileNotFoundException extends StorageException &#123;    public StorageFileNotFoundException(String message) &#123;        super(message);    &#125;    public StorageFileNotFoundException(String message, Throwable cause) &#123;        super(message, cause);    &#125;&#125;\n\n设置上传和下载的文件大小限制修改application.yml文件为\nspring:  servlet:    multipart:      max-file-size: 1024KB      max-request-size: 1024KB\n\n如果上传或者下载的文件超出了设置的大小，会出错（这个错误我并没有去处理）。\n运行本地测试可以选择在IDEA里直接运行，也可以用maven打包之后再运行。\n服务器部署可以选择用maven打包之后用xftp上传到服务器运行。\n总结恭喜你！又写了一堆没有用的垃圾。\n","categories":["Spring"]},{"title":"SpringBoot+ThymeLeaf之图标","url":"/2020/10/12/SpringBoot-ThymeLeaf%E4%B9%8B%E5%9B%BE%E6%A0%87/","content":"网页图标\n\n之前也弄过网页图标，把favicon.ico文件移到resources&#x2F;static目录下就完了，原理是什么和spring怎么做的我一概不知，但发现有时候不好使，也不知道为啥。网上方法试了很多，终于找到了有用的方法。\n\n\nICO文件可以通过icon这个网站生成，最好是32*32的。\n位置可以放在resources目录下，也可以放在resources&#x2F;static目录下。\n命名必须是favicon.ico。\n其它配置（关键）每个页面的&lt;head&gt;里都要加上这么两句：\n&lt;link rel=&quot;shortcut icon&quot; th:href=&quot;@&#123;/favicon.ico&#125;&quot;/&gt;&lt;link rel=&quot;bookmark&quot; th:href=&quot;@&#123;/favicon.ico&#125;&quot;/&gt;\n\n我的模板引擎是ThymeLeaf，别的没用过不知道。\n（完）\n","categories":["Java"]},{"title":"SpringBoot发送Mail","url":"/2020/07/26/SpringBoot%E5%8F%91%E9%80%81Mail/","content":"以QQ邮箱为例：使用Spring Boot发送Mail准备工作在QQ邮箱设置里开启SMTP服务，并获得授权码，记住授权码备用。\n创建Spring Boot项目通过Spring Initializr创建Spring Boot项目，依赖项包括spring-boot-starter-artemis和spring-boot-starter-mail。\n\n\npom文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;eternal.fire&lt;/groupId&gt;    &lt;artifactId&gt;spring-mail&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;spring-mail&lt;/name&gt;    &lt;description&gt;send email by using spring&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;14&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-artemis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n配置文件：application.ymlspring:  mail:    host: smtp.qq.com    username: qq号@qq.com    password: 授权码不是qq密码    default-encoding: UTF-8    port: 587    properties:      mail:        smtp:          auth: true          starttls:            enable: true            required: true\n\n说明：我用排除变量法发现465端口不能用\n@SpringBootApplication类package eternal.fire;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class SpringMailApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringMailApplication.class, args);    &#125;    @Bean    CommandLineRunner run(MailService mailService) &#123;        return args -&gt; mailService.sendEmail(&quot;674602921@qq.com&quot;, &quot;test&quot;);    &#125;&#125;\n\nMailService类package eternal.fire;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;@Componentpublic class MailService &#123;    JavaMailSender javaMailSender;    @Autowired    public MailService(JavaMailSender javaMailSender) &#123;        this.javaMailSender = javaMailSender;    &#125;    public void sendEmail(String email, String message) throws MessagingException &#123;        MimeMessage mimeMessage = javaMailSender.createMimeMessage();        MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage);        mimeMessageHelper.setFrom(&quot;发送人的qq@qq.com&quot;);        mimeMessageHelper.setTo(email);        mimeMessageHelper.setSubject(&quot;What&#x27;s going on?&quot;);        mimeMessageHelper.setText(message);        javaMailSender.send(mimeMessage);    &#125;&#125;\n\n运行上面的代码里已经在ComandLineRunner里调用了sendEmail方法，可以直接在ide里运行，也可以打包运行。\n关于配置使用Spring Boot而不是Spring MVC的目的不就是因为Spring Boot配置方便吗，Spring Boot帮助我们做了很多事儿，但是我在网上看到好多没有必要的配置。比如，明明已经在application.yml里设置好了一切，但是在MailService类却手动去读取这些配置。再比如spring.mail.protocol的默认值就是smtp，再去设置一遍就有些画蛇添足了。\n","categories":["Spring"]},{"title":"TOP","url":"/2021/05/06/TOP/","content":"\n\n\n\nload averageSo what’s CPU load average?\n Let’s explain CPU load first. CPU load is the number of processes which are being executed by CPU or waiting to be executed by CPU. So CPU load average is the average number of processes being or waiting executed over past 1, 5 and 15 minutes. (会有一个进程队列，等待CPU去调度执行，该队列中进程的数量即为CPU Load)\nBelow is an example to understand the relationship between load average and CPU cores:\n23:16:49 up  10:49,  5 user,  load average: 1.00, 0.40, 3.35\n\n\nOn single core system this would mean:\n\nThe CPU was fully (100%) utilized on average; 1 process was running on the CPU (1.00) over the last 1 minute.\nThe CPU was idle by 60% on average; no processes were waiting for CPU time (0.40) over the last 5 minutes.(过去五分钟的load avg为0.4，必定会有一些时刻进程队列为空，没有进程需要CPU时间，所以平均来说，CPU有60%是空闲的)\nThe CPU was overloaded by 235% on average; 2.35 processes were waiting for CPU time (3.35) over the last 15 minutes.\n\nOn a dual-core system this would mean:\n\nThe one CPU was 100% idle on average, one CPU was being used; no processes were waiting for CPU time(1.00) over the last 1 minute.\nThe CPUs were idle by 160% on average; no processes were waiting for CPU time. (0.40) over the last 5 minutes.\nThe CPUs were overloaded by 135% on average; 1.35 processes were waiting for CPU time. (3.35) over the last 15 minutes.\n\nPS: uptime也可以用来查看CPU load，而top查询的结果包含了uptime的结果。\n\n\n可以用lscpu查看cpu的信息：\n\n\nTASK and CPU Statesshows total tasks or threads\nus, user    : time running un-niced user processessy, system  : time running kernel processesni, nice    : time running niced user processesid, idle    : time spent in the kernel idle handlerwa, IO-wait : time waiting for I&#x2F;O completionhi : time spent servicing hardware interruptssi : time spent servicing software interruptsst : time stolen from this vm by the hypervisor\nhihi is the time spent processing hardware interrupts. Hardware interrupts are generated by hardware devices (network cards, keyboard controller, external timer, hardware sensors, …) when they need to signal something to the CPU (data has arrived, for example).\nSince these can happen very frequently, and since they essentially block the current CPU while they are running, kernel hardware interrupt handlers are written to be as fast and simple as possible.\nsi根据我在计组课上学过的知识，CPU的速度与键盘、打印机这种低速设备的速度相差甚远，要处理硬件设备的请求，如果让CPU去轮询硬件设备，大部分时间都会花在等IO上，很耗费CPU时间，所以采用类似事件订阅的一种机制：当硬件准备好时，向CPU发送中断请求。\nCPU设置了一组中断向量，比如从0到64，不同的中断向量对应着不同的处理代码（想想当初在8086上写汇编的日子，INT 60），当硬件设备有要处理的任务时，会向CPU发起一个中断请求。CPU接受到请求后，根据中断号，会跳转到对应的中断处理程序上，执行相应代码。\n中断程序有个特点，它在执行的过程中不能再被中断（CPU在此期间会屏蔽中断请求）。在交互性很强的桌面系统里，响应时间甚至要比吞吐量来的更重要一些，假如某个中断程序的执行时间过长，就会影响到响应时间，所以中断处理的时间要尽量的短。\n解决这个问题，linux将处理中断的routine一分为二：\na ‘top half’ which receives the hardware interrupt and a ‘bottom half’ which does the lengthy processing.\n因为中断程序执行的时间很短，所以多核CPU同步的时候，可以用自旋锁（spinlock）。自旋锁采用忙等待的方式（时刻准备着），耗费CPU时间，但比一般的互斥锁效率更高。\nMEMORY UsageThis portion consists of two lines which may express values in kibibytes (KiB) through exbibytes (EiB) depending on the scaling factor enforced with the &#96;E’ interactive command.\n As a default, Line 1 reflects physical memory, classified as:  total, free, used and buff&#x2F;cache\n Line 2 reflects mostly virtual memory, classified as: total, free, used and avail (which is physical memory)\nThe avail number on line 2 is an estimation of physical memory available for starting new applications, without swapping.\n%CPUWhat is CPU usage？\n类似那种时分复用的思想，将CPU时间划分成多个时间片（时分复用帧），不同的线程占用不同的时间片。时间片是在可运行的任务之间轮转，阻塞在IO或者在等事件、等锁的任务是不可运行的，不参与轮转。\nThe task’s share of the elapsed CPU time since the last update, expressed as a percentage of total CPU time.\nIn a true SMP environment, if a process is multi-threaded and top is not operating in Threads mode, amounts greater than 100% may be reported. \nreference[What is CPU Load Average (tenable.com)](https://community.tenable.com/s/article/What-is-CPU-Load-Average#:~:text=CPU load is the number,1%2C 5 and 15 minutes.)\ntop(1) - Linux manual page (man7.org)\npaper-1130.pdf (unca.edu)\n","categories":["Linux"]},{"title":"Template Method","url":"/2020/05/21/Template-Method/","content":"Template Method\n定义定义一个操作中的算法的骨架将一些步骤延迟到子类中子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤核心思想父类定义骨架\n骨架一般声明为final\n\n子类实现（某些）细节\n需要子类实现的一般声明为protected\n\n\n\n栗子找到数组中最大的元素package eternal.fire;public abstract class TemplateMethod &#123;    //找出数组中最大的元素    public final int findMax(int[] nums) &#123;        //排序        sort(nums);        //返回最后的元素        return nums[nums.length - 1];    &#125;    //这个sort怎么写，暂时还没想好，所以留给子类去实现    protected abstract void sort(int[] nums);&#125;\n\n\n\npackage eternal.fire;import java.util.Arrays;public class Max extends TemplateMethod &#123;    @Override    protected void sort(int[] nums) &#123;        Arrays.sort(nums);    &#125;&#125;\n\n\n\npackage eternal.fire;public class Main &#123;    public static void main(String[] args) &#123;        int[] nums = new int[]&#123;1, 8, 1, 3, 0, 5, 0, 0, 2, 1, 8&#125;;        Max max = new Max();        int m = max.findMax(nums);        System.out.println(m);    &#125;&#125;\n\n","categories":["Design Patterns"]},{"title":"Stategy","url":"/2020/05/20/Stategy/","content":"Strategy\n定义定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n\n栗子java标准库\nArrays.sort()\npublic static void main(String[] args) &#123;    String[] array = &#123; &quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot; &#125;;    Arrays.sort(array,String::compareToIgnoreCase);    for (var s : array) &#123;        System.out.print(s);    &#125;&#125;\n\n自己写一个demopackage eternal.fire;import java.util.Arrays;import java.util.Comparator;public class LeetCode &#123;    public static void main(String[] args) &#123;        String[] array = &#123;&quot;apple&quot;, &quot;Pear&quot;, &quot;Banana&quot;, &quot;orange&quot;&#125;;        sort(array, String::compareToIgnoreCase);        System.out.println(Arrays.toString(array));    &#125;    public static void sort(String[] array, Comparator&lt;String&gt; comparator) &#123;        for (int i = 0; i &lt; array.length; i++) &#123;            for (int j = 0; j &lt; array.length - 1; j++) &#123;                if (comparator.compare(array[j], array[j + 1]) &gt; 0) &#123;                    String tmp = array[j + 1];                    array[j + 1] = array[j];                    array[j] = tmp;                &#125;            &#125;        &#125;    &#125;&#125;\n\n核心思想在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，使得新增策略不必修改原有逻辑。","categories":["Design Patterns"]},{"title":"Virtual Memory","url":"/2020/08/13/Virtual-Memory/","content":"概念\n每个程序有自己的地址空间，这些地址空间被分为很多拥有连续地址范围的页面\n程序运行时，并非所有页面都要加载进内存。只有需要时，页面才被OS映射到物理内存\n页面可以被交换（和磁盘）\n程序里用到的是虚地址\n\n\n\nPaging问题\n如何把虚地址映射到物理地址\n\n相关概念\n页面\n\n虚拟地址空间单元\n\n图\n\n\n\n页表\n\n页面和页框的映射关系\nPresent&#x2F;Absent\nPage Frame Number\n\n\n页框\n\n物理内存空间单元\n\n\n\nMMUMemory Management Unit\n翻译过程\n虚拟地址\n\n虚拟页面号\n\n高4位\n\n\n偏移量\n\n低12位\n\n\n\n\n步骤\n\n由虚拟地址找到虚拟页面号和偏移量\n由页表得到物理页面号(顺便判断是否会缺页中断，如果缺页中断就不用找了)\n加偏移量得到物理地址\n\n\n图\n\n\n优化Speeding Up paging\nTLBs\n\n情报\n\n大多数程序总是对少量的页面进行频繁的访问\n\n\n功能\n\n引入一个小型的硬件设备TLB将虚拟地址直接映射到物理地址，不再需要去查找页表\n\n\n\n\n\nReduce Page Table Size\nMultilevel Page level\n\n缺点\n\n影响查找速度\n\n\n\n\nInverted Page Table\n\n哈希\n全局只有一张表\n\n\n\nPage Replacement Alg为什么需要PRA\n新的进程已经没内存了，所以要替换一些进程\n\n分类\n最优置换算法\n\n特点\n\nOptimal but unreliazable\nPage fault数最小\n替换最后使用的进程\n\n\n计算缺页中断次数\n\n\n\nLeast Recently used\n\n概念\n\n参考之前的序列，找到最不常用的\n\n\n分类\n\nStrict LRU\n\n缺陷\n\n要维护一个链表，每次都要更新链表\n\n\n\n\nApproximately LRU\n\n\n\n硬件实现\n\n\n\nSimulating LRU\n\nNot Frequently used\n\n\nThe Working Set PRA\n\nThe WS Clock\n\nFIFO\n\n\n","categories":["OS"]},{"title":"WebSocket","url":"/2020/05/24/WebSocket/","content":"WebSocket\n传统的Http协议无请求，不响应\n浏览器向服务器发送请求，服务器回应\n服务器想要定期推送数据，需要用JavaScript定时轮询\n\nWebSocket：Http升级版请求GET &#x2F;chat HTTP&#x2F;1.1Host: www.example.comUpgrade: websocketConnection: Upgrade\n响应HTTP&#x2F;1.1 101 Switching ProtocolsUpgrade: websocketConnection: Upgrade\n特点\nTCP连接will go on\n\n\n\nWebSocket in SpringMVC准备工作\n依赖项\nWebSocketConfigurer\n\n处理WebSocket连接\n继承Handler\n\nTextWebSocketHandler\nBinaryWebSocketHandler\n\n\n覆写父类方法\n\nafterConnectionEstablished()\nafterConnectionClosed()\n\n\n\n","categories":["Spring"]},{"title":"VMware的两种网络连接方式","url":"/2021/12/31/VMware%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/","content":"\n\n\n\n主机使用SSH连接VMware虚拟机桥接模式# 编辑设置vim /etc/sysconfig/network-scripts/ifcfg-ens33\n\n\n\n修改BOOTPROTO为”static”并添加IPADDR和NETMASK\nNAT模式外部网路无法直接访问虚拟机，需要设置端口转发规则，将外部网络发送到主机指定端口的数据转发到指定的虚拟机上。\n\n\n注意SSH连接指定的IP是主机的ip，端口是主机设定的端口\n虚拟机通过主机上的V2RAY使用代理V2RAY配置：允许来自局域网的连接\n\n\n配置HTTP_PROXY和HTTPS_PROXY，比如GIT的配置：\n# 设置代理git config --global http.proxy socks5://$(主机IP):$(v2ray本地监听端口号)git config --global https.proxy socks5://$(主机IP):$(v2ray本地监听端口号)# 取消代理git config --global --unset http.proxy git config --global --unset https.proxy\n","categories":["计网"],"tags":["计网,VMware,NAT"]},{"title":"Vue:自定义组件的v-model","url":"/2020/07/18/Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84v-model/","content":"关于v-model的使用这件事v-bindv-bind可以把标签的某个属性和vue组件的某个变量**单向绑定**起来，举个栗子：\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;label&gt;input        &lt;input type=&quot;text&quot; v-bind:value=&quot;text&quot;&gt;    &lt;/label&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            text: &#x27;nothing to show&#x27;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n效果：\n\n\n如果我们在控制台去改变text的值，新的值会立即渲染到页面上：\n\n\n但是反过来，如果在输入框改变input的value，text并不会发生改变:\n\n\n这就是所谓的单向绑定。那么如何实现双向绑定呢？\nv-modelv-model可以用来实现双向绑定。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;label&gt;input        &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt;    &lt;/label&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            text: &#x27;nothing to show&#x27;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n初始效果：\n\n\n改变输入框的值：\n\n\n可以到变量text和input的value已经牢牢地绑定在一起，不求同年同月同日生，但求同年同月同日死。\nv-model到底做了些什么呢？v-model本质是语法糖（没有v-model的时候可以通过更复杂一些的方法实现v-model的功能），他帮助我们做了两件事。\n第一件事&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;label&gt;input        &lt;input type=&quot;text&quot; v-bind:value=&quot;text&quot;&gt;    &lt;/label&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            text: &#x27;nothing to show&#x27;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n用v-bind将标签的value和指定变量单向绑定。\n第二件事&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;label&gt;input        &lt;input type=&quot;text&quot; v-bind:value=&quot;text&quot; v-on:input=&quot;text = $event.target.value&quot;&gt;    &lt;/label&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            text: &#x27;nothing to show&#x27;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n在第一步的基础上，用v-on监听input事件，进而通过JavaScript代码修改变量text的值，从而实现双向绑定。\n在自定义组件上使用v-model可见，使用v-model进行双向绑定很方便，但是，并非在任何情况下都可以直接使用v-model。\n一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。比如type=checkbox类型的input，应该去利用它的checked属性和change事件，这时就需要我们去使用model选项。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;base-checkbox v-model=&quot;choice&quot;&gt;&lt;/base-checkbox&gt;    &lt;p&gt;&#123;&#123; choice &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    Vue.component(&#x27;base-checkbox&#x27;, &#123;        model: &#123;            prop: &#x27;checked&#x27;,            event: &#x27;change&#x27;        &#125;,        props: &#123;            checked: Boolean        &#125;,        template: `&lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;,$event.target.checked)&quot;&gt;`    &#125;);        const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            choice: false        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n这样做即可实现双向绑定。\n效果：\n$emit(event,args)可以去触发一个事件并传入参数，如果有所迷惑，可以看下面的栗子：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Vue-form&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;base-checkbox v-bind:checked=&quot;choice&quot; v-on:change=&quot;sync&quot;&gt;&lt;/base-checkbox&gt;    &lt;p&gt;&#123;&#123; choice &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    Vue.component(&#x27;base-checkbox&#x27;, &#123;        model: &#123;            prop: &#x27;checked&#x27;,            event: &#x27;change&#x27;        &#125;,        props: &#123;            checked: Boolean        &#125;,        template: `&lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;&gt;`    &#125;);    const vm1 = new Vue(&#123;        el: &#x27;#container&#x27;,        data: &#123;            choice: false        &#125;,        methods: &#123;            sync: function (checked) &#123;                console.log(checked);                // this指向当前Vue实例                this.choice = checked;            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;\n\n两种版本的效果完全一样，但通过对比，我们可以体会到v-model帮我们做了些什么。\n","categories":["JavaScript"]},{"title":"adapter","url":"/2020/05/12/adapter/","content":"Adapter\n栗子life\n中美插座标准不同，需要适配器去转接\n我的小米8没有耳机插孔，需要转接线\n\n多线程\n问题\n\n我有一个Task继承自Callable\n我的Thread的构造方法需要一个Runnable\n\n\n解决方法\nimport java.util.concurrent.Callable;public class LeetCode &#123;    public static void main(String[] args) &#123;        Callable&lt;Long&gt; callable = new Task(123450000L);        Thread thread = new Thread(new RunnableAdapter(callable));        thread.start();    &#125;&#125;class RunnableAdapter implements Runnable &#123;    private Callable&lt;?&gt; callable;    RunnableAdapter(Callable&lt;?&gt; callable) &#123;        this.callable = callable;    &#125;        @Override    public void run() &#123;        try &#123;            callable.call();        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;class Task implements Callable&lt;Long&gt; &#123;    private long num;    public Task(long num) &#123;        this.num = num;    &#125;        @Override    public Long call() throws Exception &#123;        long sum = 0;        for (long i = 0; i &lt; num; i++) &#123;            sum += i;        &#125;        System.out.println(&quot;result:&quot; + sum);        return sum;    &#125;&#125;\n\n\n\n\n整一个RunnableAdapter\n它的构造方法接受一个Callable\n它的run方法内部运行Callable的call方法\n\n\n\n\n\n编写步骤implement目标接口（上面的栗子中是Runnable）内部持有一个待转换接口（上面的栗子中是Callable）在Adapter类的方法里调用待转换接口的方法应用栗子一\n我有一个String数组\n我想把这个数组当list使\nList list &#x3D; new LinkedList&lt;&gt;(Arrays.asList(strings));\nArrays.asList()就是一个Adapter\n\n栗子二\nInputStreamReader可以把InputStream转换成Reader\n\n","categories":["Design Patterns"]},{"title":"condition","url":"/2020/05/12/condition/","content":"condition\n地位reentrantlock的partner类似于synchronized和（wait、notify）的关系一个lock对应一个conditionnew必须使用对应lock的newCondition方法\n\n方法await()\n可以设置等待时间、超过后自己醒来\n\nsignal()signalAll()","categories":["Java"]},{"title":"decorator","url":"/2020/05/12/decorator/","content":"装饰器\nFilter模式就是Decorator模式思想把需要新添加的内容用Decorator的方式层层加之于上，把新功能组合于原有基础之上优势可以将核心功能和附加功能分开\n增加核心功能就增加子类\n增加附加功能就增加Decorator的子类\n可以在运行期间动态的给核心功能添加附加功能\n\n\n\n设计Decorator模式","categories":["Design Patterns"]},{"title":"facade","url":"/2020/05/10/facade/","content":"外观(Facade)定义为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。栗子栗子\n假如我是个java写的对象，我想完成“起床“这件事\n\n上厕所\n更衣\n洗漱\n\n\n我需要调用3个接口来完成这件事\n\n我整一个Facade类，在内部定义一个“getUp()”方法，方法内部依次调用这三个接口\n\n有了Facade，我只需要调用Favade提供的getup接口即可\n\n\n\n\n栗子\nGateway\n\n\n\n","categories":["Design Patterns"]},{"title":"flyweight","url":"/2020/05/11/flyweight/","content":"享元定义运用共享技术有效地支持大量细粒度的对象。\n谁和谁共享\n什么叫细粒度\n\n\n\n核心思想如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行栗子package eternal.fire;public class Main &#123;    public static void main(String[] args) &#123;        String s1 = &quot;Running constant pool&quot;;        String s2 = &quot;Running constant pool&quot;;        System.out.println(s1 == s2);        Integer num1 = Integer.valueOf(101);        Integer num2 = Integer.valueOf(101);        System.out.println(num1 == num2);    &#125;&#125;\n\n\n\nString用字面量初始化的时候，会先看运行常量池里有没有已经存在的，如果有就返回一个引用，否则new一个放进运行常量池并返回引用Integer.valueOf()方法和上面的类似，预先缓存了-128到127Byte只有256个状态，如果用Byte.valueOf()返回的全是缓存享用享元因为这个模式是通过静态工厂方法实现的，所以创建变量的时候不要new而用静态工厂方法就可能享受到享元设计享元模式package eternal.fire;import java.util.HashMap;import java.util.Map;public class Student &#123;    //cache    private static final Map&lt;String, Student&gt; cache = new HashMap&lt;&gt;();    private final int id;    private final String name;    public Student(int id, String name) &#123;        this.id = id;        this.name = name;    &#125;        //static factory method    public static Student createStudent(int id, String name) &#123;        String key = id + name;        Student student = cache.get(key);        if (student == null) &#123;            cache.put(id + name, new Student(id, name));            return cache.get(key);        &#125; else &#123;            return cache.get(key);        &#125;    &#125;&#125;\n\n\n\n可以使用成熟的Cache库，如Guava的Cache","categories":["Design Patterns"]},{"title":"go get","url":"/2021/03/13/go-get/","content":"代理有时候，设置了git的代理还不够，golang.org也许有一部分不走git的代理，需要手动再设置一下proxy。\n要么设置当前terminal的全局变量：\nexport GOPROXY=https://goproxy.cn,direct\n\n要么改go的配置：\ngo env -w GOPROXY=https://goproxy.cn,direct\n\n另外还要打开另一个开关：\ngo env -w GO111MODULE=on\n\n参考https://goproxy.cn/\n","categories":["Go"]},{"title":"hexo同时deploy部署到github和gitee上","url":"/2020/07/17/hexo%E5%90%8C%E6%97%B6deploy%E5%88%B0github%E5%92%8Cgitee%E4%B8%8A/","content":"打开博客目录下的_config.yml文件，修改deploy的repo并保存\n要这样配置才行：\ndeploy:  type: git  repo:     github: git@github.com:carpediemtal/carpediemtal.github.io.git    gitee: git@gitee.com:linjinming/linjinming.git  branch: master\n\n配置完成之后执行\nhexo ghexo d\n\n或\nhexo d -g\n\n即可同步部署。\n请参考官方文档：\n\nhttps://hexo.io/zh-cn/docs/github-pages\n\n","categories":["Experience"]},{"title":"http","url":"/2020/05/09/http/","content":"\n\n\n\nHTTP\n协议传输之前总要先约定好的吧\nHTTP协议从web服务器传输html到浏览器的协议\n版本1.0\n一次连接一次传输\n\n1.1\n一次连接多次传输\n\n2.0\n实验阶段\n\n原理TCP&#x2F;IP协议\nBS架构\n浏览器作为HTTP客户端通过URL向服务器发送请求\nDNS服务器保存所有主机的域名和IP地址\n可以把域名翻译成IP地址\n流程DNS服务器把域名解析成IP地址\n客户端和服务器三次握手建立TCP连接\n客户端向服务器发送HTTP请求\n服务器向客户端发送HTTP响应\n客户端把得到的html和资源渲染到前端呈现给用户\n特点BS架构\n请求-响应模式\n\n请求简单\n请求命令\n\nGET\nPOST\nDelete\n\n\n资源路径\n\n\n啥都能传\n传输的类型用Content-Type标记\n\nURI和URLUniform Resource Identifier\n标识\n\nUniform Resource Location\n定位\n互联网的资源都有唯一的URL\n\nRequest请求行\n请求方法\n\n分类\n\nGET\n\n请求获得某个资源\n\n\nPOST\n\n提交表单\n上传文件\n\n\nHEAD\n\n只能获得header的Get\n\n\nPUT\n\n请求创建或修改文件\n\n\nDELETE\n\n请求删除文件\n\n\n\n\nPOST和GET的区别\n\nGET请求的内容在URL就可以看到\nGET没BODY\nPOST有BODY\n\n\n\n\nURL\n\n协议类型\n\n协议版本\n\n\nHeaderBodyResponse状态行\n响应状态码\n\n分类\n\n1XX\n\n服务器收到请求，给客户端一个message，明示你继续操作\n\n\n2XX\n\n一切OK，清楚明白\n\n\n3XX\n\n重定向\n\n比如之前的资源换位置了\n\n\n\n\n4XX\n\n客户端的错误\n\n语法\n服务器无法完成请求\n\n\n\n\n5XX\n\n服务器的错误\n\n服务器处理请求的时候出了差错\n\n\n\n\n\n\n常见&#x2F;常用\n\n200\n\n301\n\nURL变了\n\n这人搬家了，去别处找吧\n\n\n\n\n302\n\n这人暂时不在这里，去别处找吧\n\n\n400\n\n客户端的请求有语法错误\n\n服务器：？\n\n\n\n\n401\n\n服务器：你没有资格和我提这样的请求\n\n\n404\n\nNOT FOUND\n\n\n500\n\n服务器：dbq\n\n\n503\n\n服务器：我很忙，过会儿再来试试吧\n\n\n\n\n\n\n\nHeaderBodyHTTPSHTTP存在的问题\n请求的信息明文传输，能被轻易窃取\n数据的完整性未经校验，可能被篡改\n对方身份未经检验，可能被冒充\n\n问题的解决\nHTTP+SSL&#x2F;TLS\nHypertext transfer protocol over secure socket layer\n\nSSL\n提供安全支持的一种协议\n\nTLS\n由SSL演化而来\n\n传输数据的流程\n建立HTTPS连接\n用非对称加密传输对称加密的密钥\n通过密钥进行密文通信\n（详情见网络通信加密）\n\n缺点（相对于http）\n慢\n\nSSL证书要钱，越好的越贵\n\nSSL证书是CA证书的一种\n\n\n消耗资源多\n\n\n值得一提的是HTTP和HTTPS用的端口不一样\n网络通信加密盘古时代\n路不拾遗，夜不闭户\n\n明文直接传\n\n\n\n上古时代\n问题\n\n出现了刁民监听数据、伪造数据\n\n\n应对策略\n\n对称加密\n\n约定公用一把钥匙\n关键是钥匙不能给别人知道\n56bit的DES\n\n\n\n\n\n近代\n问题\n\n道高一尺魔高一丈\n找个好的计算机可以暴力破解56位的钥匙\n\n\n应对策略\n\n对称加密（pro\n\n长度加倍，不够再加倍\n256位的AES\n168位的DES\n\n\n\n\n\n现代\n问题\n\n对称加密需要一把唯一的key，这个key得找个好的时机告诉对方，决不能泄露，否则所做的一切毫无意义\n访问的人数太多了，言多必失\n\n\n应对策略\n\n非对称加密\n\n奥义\n\n加密解密所用的不是一把钥匙\n\n\n钥匙\n\nprivate key\npublic key\n\n\n流程\n\nA和B双方各有一个private key和对方的public key\n\n关于数据的安全性\n\nA用B的public key对数据加密 发送给B\nB用自己的private key对数据解密\n\n\n关于数据的完整性\n\nA用自己的private key给hash值加密 发送给A\nB用A的public key解密收到的hash\nB用解密的数据算一下hash\nB对比一下两个hash\n\n\n\n\n\n\n\n\n\n非对称加密的安全隐患\n天下没有不透风的墙，如果有，那肯定是暂时的\n\n非对称加密最初需要告知对方自己的public key\n\nC拦截了传输的public key，并把自己的public key传输给了A和B\n\n在之后的A和B的传输中，C可以获取A发给B的内容并篡改\n\nhash值呢？\n\nC自己整一个就行了呗，反正C已经无所不知了\n\n\n\n\n应对策略\n\n保证public key不被拦截\n\n\n\nCA\n一个嵌入在浏览器或者操作系统的第三方\nA和B通过CA生成数字证书交换public key\nC可以获取public key但不能伪造数字证书 因为CA在本地从未经过传输\n\n实际使用\n非对称加密太复杂了\n非对称加密太慢了\n所以我还用对称加密，但用非对称加密传输对称加密的密钥\n\n","categories":["计网"]},{"title":"interceptor","url":"/2020/05/14/interceptor/","content":"Interceptor\nWhy not FilterFilter是Servlet提供的组件Spring创建的Filter是普通的Bean，Servlet并不知道Filter的存在，也无法去调用Servlet创建的Filter不是Spring的Bean，无法注入使用Filter需要配置web.xml创建代理类，使用DelegatingFilterProxy\n\n特点package eternal.fire;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.Base64;@Order(2)@Componentpublic class AuthInterceptor implements HandlerInterceptor &#123;    final Logger logger = LoggerFactory.getLogger(getClass());finalUserService userService;public AuthInterceptor(UserService userService) &#123;    this.userService = userService;&#125;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    logger.info(&quot;preAuthenticate &#123;&#125;...&quot;, request.getRequestURI());    authenticateByHeader(request);    return true;&#125;private void authenticateByHeader(HttpServletRequest request) &#123;    String authHeader = request.getHeader(&quot;Authorization&quot;);    if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Basic &quot;)) &#123;        logger.info(&quot;try to authenticate by Authorization Header&quot;);        String up = new String(Base64.getDecoder().decode(authHeader.substring(6)), StandardCharsets.UTF_8);        int pos = up.indexOf(&#x27;:&#x27;);        if (pos &gt; 0) &#123;            String email = URLDecoder.decode(up.substring(0, pos), StandardCharsets.UTF_8);            String password = URLDecoder.decode(up.substring(pos + 1), StandardCharsets.UTF_8);            User user = userService.signin(email, password);            request.getSession().setAttribute(UserController.KEY_USER, user);            logger.info(&quot;user &#123;&#125; have logged in by Authentication Header&quot;, email);        &#125; else &#123;            logger.info(&quot;try to authenticate by Authorization Header FAILED!&quot;);        &#125;    &#125; else &#123;        logger.info(&quot;try to authenticate by Authorization Header FAILED!&quot;);    &#125;&#125;&#125;\n\n\n\nInterceptor是由SpringMVC提供的，注入很方便Interceptor拦截的是Controller，而Filter拦截的是DispatcherServlet         │   ▲         ▼   │       ┌───────┐       │Filter1│       └───────┘         │   ▲         ▼   │       ┌───────┐┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐       └───────┘│        │   ▲                  │         ▼   ││ ┌─────────────────┐           │  │DispatcherServlet│&lt;───┐│ └─────────────────┘    │      │   │              ┌────────────┐│  │              │ModelAndView││   │              └────────────┘│  │                     ▲      │   │    ┌───────────┐    ││  ├───&gt;│Controller1│────┤      │   │    └───────────┘    ││  │                     │      │   │    ┌───────────┐    ││  └───&gt;│Controller2│────┘      │        └───────────┘└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n\n       │   ▲       ▼   │     ┌───────┐     │Filter1│     └───────┘       │   ▲       ▼   │     ┌───────┐     │Filter2│     └───────┘       │   ▲       ▼   │┌─────────────────┐│DispatcherServlet│&lt;───┐└─────────────────┘    │ │              ┌────────────┐ │              │ModelAndView│ │              └────────────┘ │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ▲ │    ┌───────────┐    │ ├─┼─&gt;│Controller1│──┼─┤ │    └───────────┘    │ │ │                 │ │ │    ┌───────────┐    │ └─┼─&gt;│Controller2│──┼─┘      └───────────┘   └ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n\n可以通过Order指定顺序特殊的Interceptor：ExceptionHandler@ExceptionHandler(RuntimeException.class)public ModelAndView handleUnknownException(Exception e) &#123;    return new ModelAndView(&quot;500.html&quot;, Map.of(&quot;error&quot;, e.getClass().getSimpleName(), &quot;message&quot;, e.getMessage()));&#125;\n\n\n\n作用于所有的Controller发生异常时，会执行有@ExceptionHandler注解的方法","categories":["Spring"]},{"title":"java中的@override写与不写的区别","url":"/2020/02/21/java%E4%B8%AD%E7%9A%84@override/","content":"相关概念方法签名方法签名包括 参数列表 和 方法名 ，不包括返回类型，修饰符和异常类型。\n覆写java中如果在子类中定义了一个和父类方法签名相同的方法，新的方法会覆盖掉继承的方法，这种过程称之为 覆写。\n@Override据我所知，正常情况下 @Override 写或不写对编译运行没有影响，jvm会自动识别覆写的方法。唯一的作用是：如果programmer在覆写方法时写错了方法名并且写了 @Override，编译器可以起到提醒作用。\n\n\n栗子：\n情况1\n情况2\n","categories":["Java"]},{"title":"java批处理之微博图床链接加标签","url":"/2020/07/25/java%E6%89%B9%E5%A4%84%E7%90%86%E4%B9%8B%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/","content":"前因后果微博图床加了防盗链，有一个缓兵之计是给所有&lt;img&gt;标签加上一个属性：referrerpolicy=&quot;no-referrer&quot;。\n博客里插入了非常多图片，手动添加是不可能的，我们来用java批处理：\npackage sample;import java.io.*;import java.util.Objects;import java.util.regex.Matcher;import java.util.regex.Pattern;public class MarkDownModify &#123;    private final static Pattern PATTERN = Pattern.compile(&quot;(.*?)(&lt;img.+&gt;)(.*?)&quot;);    public static void addReferrerPolicy(File directory) throws IOException &#123;        for (File file : Objects.requireNonNull(directory.listFiles())) &#123;            modify(file);        &#125;    &#125;    private static void modify(File file) throws IOException &#123;        BufferedReader reader = new BufferedReader(new FileReader(file));        StringBuilder content = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) &#123;            line = regex(line);            content.append(line).append(&quot;\\n&quot;);        &#125;        BufferedWriter writer = new BufferedWriter(new FileWriter(file));        writer.write(content.toString());        writer.flush();    &#125;    private static String regex(String line) &#123;        Matcher matcher = PATTERN.matcher(line);        if (matcher.matches()) &#123;            String s1 = matcher.group(1);            String s2 = matcher.group(2);            String s3 = matcher.group(3);            s2 = &quot;&lt;img &quot; + &quot;referrerpolicy=\\&quot;no-referrer\\&quot; &quot; + s2.substring(5);            return s1 + s2 + s3;        &#125; else &#123;            return line;        &#125;    &#125;&#125;\n\n图形界面我用javaFX给这段批处理程序写了一个图形界面：\n\n\n\n\n先选择md文件所在的目录，之后点击Execute按钮执行批处理，点击help查看帮助。\n源码已经上传到了github：\nhttps://github.com/carpediemtal/weibo-image-bed/tree/master\n参考资料如何在IDEA里运行javafx：\nhttps://openjfx.io/openjfx-docs/\n","categories":["Java"]},{"title":"knapsack problem","url":"/2021/06/17/knapsack-problem/","content":"背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。\n\n\n0-1 knapsackA thief robs a store and finds n items, with item i being worth $Vi and having weight Wi pounds. The thief can carry at most W∈ N in his knapsack but he wants to take as valuable a load as possible. Which item should he take?  \nFractional knapsackThe setup is same as 0-1 knapsack, but the thief can take fractions of items  \nOptimal SubstructureBoth knapsack problems exhibit the optimal substructure property:\n\nFor 0-1 knapsack problem, if we remove item j from this load, the remaining load must be at most valuable items weighing at most W-wj from n-1 items.\nFor fractional one, if we remove a weight w of one item j from the optimal load, then the remaining load must be the most valuable load weighing at most W-w that the thief can take from the n-1 original items plus wj-w pounds of item j\n\nExampleThere are 5 items that have a value and weight list below, the knapsack can contain at most 100 Lbs. Solve the problem both as fractional knapsack and 0&#x2F;1 knapsack. \n\n\n0-1 knapsackdp[i][j]表示在前i个物品，背包容量为j情况下的最优解。\n转换关系为：\nif j &lt; weights[i-1] &#123;\tdp[i][j] = dp[i-1][j]&#125; else &#123;\tdp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1])&#125;\n\n完整过程：\npackage mainimport (\t&quot;fmt&quot;)func main() &#123;\tfmt.Println(knapsack([]int&#123;20, 30, 65, 40, 60&#125;, []int&#123;10, 20, 30, 40, 50&#125;, 100)) // 0-1 knapsack&#125;// 0-1 knapsackfunc knapsack(values, weights []int, cap int) int &#123;\tn := len(values)\tdp := make([][]int, n+1)\tfor i := range dp &#123;\t\tdp[i] = make([]int, cap+1)\t&#125;\tfor i := 1; i &lt;= n; i++ &#123;\t\tfor j := 1; j &lt;= cap; j++ &#123;\t\t\tif j &lt; weights[i-1] &#123;\t\t\t\tdp[i][j] = dp[i-1][j]\t\t\t&#125; else &#123;\t\t\t\tdp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1])\t\t\t&#125;\t\t&#125;\t&#125;\treturn dp[n][cap]&#125;func max(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn a\t&#125;\treturn b&#125;\n\n\n\nFractional knapsack先将所有物品按单价排序（降序），优先选取单价最高的，如果背包容量足够，就全拿走，否则尽量多拿，结束循环。\npackage mainimport (\t&quot;fmt&quot;\t&quot;sort&quot;)func main() &#123;\tfmt.Println(_knapsack([]int&#123;20, 30, 65, 40, 60&#125;, []int&#123;10, 20, 30, 40, 50&#125;, 100)) // fractional knapsack&#125;// fractional knapsackfunc _knapsack(values, weights []int, cap float64) float64 &#123;\tn := len(values)\tvar items Items\tfor i := 0; i &lt; n; i++ &#123;\t\titems = append(items, Item&#123;float64(values[i]), float64(weights[i])&#125;)\t&#125;\tsort.Sort(items)\tvar ans float64\tfor _, item := range items &#123;\t\tif cap &gt;= item.weight &#123;\t\t\tans += item.value\t\t\tcap -= item.weight\t\t&#125; else &#123;\t\t\tans += (item.value / item.weight) * cap\t\t\tbreak\t\t&#125;\t&#125;\treturn ans&#125;type Item struct &#123;\tvalue  float64\tweight float64&#125;type Items []Itemfunc (items Items) Len() int &#123;\treturn len(items)&#125;func (items Items) Less(i, j int) bool &#123;\treturn !(items[i].value/items[i].weight &lt; items[j].value/items[j].weight)&#125;func (items Items) Swap(i, j int) &#123;\titems[i], items[j] = items[j], items[i]&#125;\n\nLeetCodeLeetCode-416 | Ming (m1ng.xyz)\nLeetCode-322 &amp; LeetCode-518 | Ming (m1ng.xyz)\n1049. 最后一块石头的重量 II\n","categories":["数据结构与算法"],"tags":["dp","knapsack","背包","动态规划"]},{"title":"leetcode-105","url":"/2020/05/22/leetcode-105/","content":"Leetcode-105本来不想发的，但实在没什么可发了。\n题目\n\n\n\n代码package eternal.fire;import java.io.IOException;public class LeetCode &#123;    public static void main(String[] args) throws IOException &#123;        Solution solution = new Solution();        int[] preorder = new int[]&#123;3, 9, 20, 15, 7&#125;;        int[] inorder = new int[]&#123;9, 3, 15, 20, 7&#125;;        TreeNode root = solution.buildTree(preorder, inorder);    &#125;&#125;class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if (preorder.length == 0) &#123;            return null;        &#125;        //根节点        TreeNode root = new TreeNode(preorder[0]);        int[] left1, left2, right1, right2;        //左子树为空        if (preorder[0] == inorder[0]) &#123;            left1 = new int[0];            left2 = new int[0];        &#125; else &#123;            //左子树的中序遍历结果            int index1 = 0;            for (int i = 0; i &lt; inorder.length; i++) &#123;                if (inorder[i] == preorder[0]) &#123;                    index1 = i;                    break;                &#125;            &#125;            left2 = new int[index1];            System.arraycopy(inorder, 0, left2, 0, index1);            //左子树的前序遍历结果            left1 = new int[index1];            System.arraycopy(preorder, 1, left1, 0, index1);        &#125;        //右子树为空        if (left1.length + 1 == preorder.length) &#123;            right1 = new int[0];            right2 = new int[0];        &#125; else &#123;            //右子树的中序遍历结果            int index2 = 1 + left1.length;            right2 = new int[preorder.length - 1 - left1.length];            System.arraycopy(inorder, index2, right2, 0, preorder.length - 1 - left1.length);            //右子树的先序遍历结果            right1 = new int[right2.length];            System.arraycopy(preorder, index2, right1, 0, preorder.length - 1 - left1.length);        &#125;        //递归构造左子树        root.left = buildTree(left1, left2);        //递归构造右子树        root.right = buildTree(right1, right2);        return root;    &#125;&#125;\n\n结果","categories":["LeetCode"]},{"title":"leetcode-394","url":"/2020/05/28/leetcode-394/","content":"题目\n\n\n\n\n\n\n题解\njava版本：\nclass Solution &#123;    public String decodeString(String s) &#123;        Pattern pattern = Pattern.compile(&quot;(\\\\d+)(\\\\[[a-zA-Z]+])&quot;);        while (true) &#123;            Matcher matcher = pattern.matcher(s);            if (!matcher.find()) &#123;                break;            &#125;            int num = Integer.parseInt(matcher.group(1));            String tmp = matcher.group(2);            String ans = tmp.repeat(num);            ans = ans.replaceAll(&quot;\\\\[&quot;, &quot;&quot;);            ans = ans.replaceAll(&quot;]&quot;, &quot;&quot;);            s = matcher.replaceFirst(ans);        &#125;        return s;    &#125;&#125;\n\nKotlin版本：\nclass Solution &#123;    fun decodeString(s: String): String &#123;        var str = s        val pattern = Pattern.compile(&quot;(\\\\d+)(\\\\[[a-zA-Z]+])&quot;)        while (true) &#123;            val matcher = pattern.matcher(str)            if (!matcher.find()) &#123;                break            &#125;            val num = matcher.group(1).toInt()            val tmp = matcher.group(2)            var ans = tmp.repeat(num)            ans = ans.replace(&quot;\\\\[&quot;.toRegex(), &quot;&quot;)            ans = ans.replace(&quot;]&quot;.toRegex(), &quot;&quot;)            str = matcher.replaceFirst(ans)        &#125;        return str    &#125;&#125;","categories":["LeetCode"]},{"title":"long time no see","url":"/2020/02/03/long-time-no-see-0/","content":"what’s going on上一篇post的时间是2019-10-07，距今已有一段时间了，这篇post的目的是帮我回顾一下写博客的步骤，顺便多说几句。现在觉得写博客也没什么复杂的，第一次搭建博客的时候，照着教程折腾了好久，但搭建好之后，写博客也就是几个命令而已。\n大学就是有很多时间去想自己做的事情到底有什么意义。我在知乎上关注了许多我觉得很有趣的用户，他们的言论令我耳目一新。许多名词之前闻所未闻，比如“内卷”、“入关”、“租鸡青一”，与之相随的还有很多消极到极点的观点，这对我这个曾经一听到“努力”、“奋斗”就热血沸腾的人影响很大，使我变得很“矛盾”。一方面，我希望通过自己的努力，获得一些好的感受；另一方面，我深受“躺平”和“劝退”思想的影响，曾经读研的决心也渐渐动摇，不知道做什么才好，矛盾的我停滞不前。\n\n\nMy 1st PC去年我大概花费了一个月左右的时间，用来准备和购买我的第一台个人电脑。因为特殊的背景，我很早就接触了电脑，但是对电脑的了解仅限于windows的特性了吧。小时候的电脑性能相当的弱，但是我也玩的不亦乐乎（昨天闲来无事，下载了红警，战役开始时还有以前从未看过的cg，红警为什么让人怀恋呢）。一直希望能有更好的配置，让我能够玩的更爽。准备之前对于配置可以说一窍不通，随着我看了许多文章和逛了许久贴吧，我最终也写出了自己购买能力范围之内的配置清单。在此之中，我也获得了很多乐趣，和无奈。从我的第一根内存条到货，到所有的零件到货相隔20余日，第一次的装机也很坎坷，因为内存条的问题，拆了装，装了又拆，直到我新买的内存条到货，点亮之后，我跑到阳台，大喊yes。没有无缘无故的快乐。\n贴上我的配置清单和对应的价格：\n\n\n少时的梦对于学习来说，笔记本电脑足矣，但是对于游戏来说，不足。一想到我的steam里还有许多游戏无人问津，大师之梦未圆，我就郁郁不得志。新的电脑于我就像久旱之后的甘霖，终于可以爽玩了。\noverwatch之前\n笔记本烫手掉帧屏幕小的问题不再成为我的瓶颈，我的枪法和身法都有了肉眼可见的提升。白天学习，睡前和小伙伴打守望一度成为了我最开心的时间，感觉就是“I feel alive”。说好的上大师，但输出位置一度掉到黄金，但分数早已不是目的。先打竞技，结束之时还有保留的娱乐活动“南极监测站”，回忆中找不到没有比这更爽的游戏时光。\n\n\n之后\n回家之后，附近的网吧有144hz的显示器，感受到了前所未有的流畅，再回到60hz时，感觉像ppt。正所谓由俭入奢易，由奢入俭难。\nThe witcher 3只玩overwatch难免过于单调，我选择了巫师3。有了硬件基础，我可以在一个很好的画质下畅玩，也不用担心之前糟糕的环境，结果是我获得了前所未有的游戏体验。巫师3故事讲得真好，主线任务结束时，我不禁失落道，再精彩的故事也有结束的时候。回家前一天晚上，我打昆特牌到凌晨3点。因为主机太大带不回家，巫师3暂时告一段落。\n期末考试十一门的考试，十多天的跨度，加上平日未曾花很多时间在听课和作业上，仅靠最后的突击，成绩一般，但也说得过去。考完后松了一口气。没啥好说的。\n女神的笑颜先占个位。\n","categories":["Essay"]},{"title":"maven","url":"/2020/05/12/maven/","content":"Maven\njava项目所需classpath\n概念\n\n一组路径的集合\n\n\n用途\n\n告知jvm哪里可以找到指定的class文件\n\n\n默认值\n\n当前目录\n\n\n\n项目的目录结构\n\n配置环境\nJDK的版本\n编译打包的流程\n当前代码的版本号\n\n使用命令行工具功能提供标准化的项目结构\n目录结构\n\npom.xml\n项目描述文件\n\nsrc\n\nmain\n\njava\nresources\n\n\ntest\n\njava\nresources\n\n\ntarget\n\n\n\n\n\n\n提供标准化的构建流程\n编译\n测试\n打包\n发布\n\n提供依赖管理机制在maven中声明一个依赖项可以自动下载并导入 Claspath构建流程lifecyclephasegoal插件clean\nclean\n\ncompiler\ncompile\n\nsurefire\ntest\n\njar\npackage\n\n","categories":["Java"]},{"title":"mediator","url":"/2020/05/16/mediator/","content":"Mediator\n定义用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。引入一个中介对象，把多边关系变成多个双边关系\n\n栗子房产中介\nwithout 中介\n\n买方和卖方直接打交道\n\n\nwith中介\n\n买方和卖方都只和中介打交道\n\n\n\nMVC的Controller优势降低了类的复杂度耦合性低缺点中介是要收费的中介可能会非常庞大复杂","categories":["Design Patterns"]},{"title":"plan","url":"/2020/05/09/plan/","content":"这学期已经第十二周了，这怎么玩啊。感觉学校的课听不听也就那样吧，再过几周再开始看吧，如果这学期不复学，那又可以顺延了哈哈哈。从我决心毕业找工作之后，这几个月每天都在学java，有一段时间觉得自己上升很快，也有一段时间觉得自己来到了瓶颈期，大概就这样吧，每天也没什么特定的目标，就想到什么看看什么，想怎么学就怎么学这样子。\n\n\n\n前几天看到阿米尔汗的视频，视频里讲到他在拍摄“摔跤吧，爸爸”中的减肥增肌经历，在几个月时间内从大胖子变身猛男，他讲到，其中最重要的一点是，关注今天的任务。imho，长远的计划是必须的，但是因为计划过于远大，往往觉得遥不可及。所以我心想，或许可以这样，一个阶段一个任务，我只专注于这个阶段，也许能获得更多正反馈，也更能够坚持下来。这个阶段有多久？我觉得可以把Arina姐姐两次发片的间隔时间当做一个period。我看了下，Arina姐姐的新片日期的2020年5月21日，所以做一些截止5月21日的规划。\njava学习规划：\n\n1. 每天一道LeetCode。如果每日一题是困难题就算了，感觉困难题太数学了，我觉得应该多做做简单中等题，By the way 其实我觉得已经没必要继续做了，但是面试要考的呀，所以继续做吧，东亚做题家，fighting。\n\n\n\n\n\n和廖老师的更新进度保持同步，以前有疏漏的可以回顾一下。如果是很复杂又很有关联性的知识，就画思维导图，尽量每个都画。\n\n每天学习一个设计模式，敲代码，画思维导图。\n\n最近了解到一本书，个人感觉很不错，《深入理解java虚拟机》。java虚拟机还是很有必要去学习的，学过java再看C++就感觉C++很丑陋，java之所以光鲜亮丽，是因为jvm帮我们做了很多事儿，但如果想要拥有C++的那种可操作性，就得对帮我们做事的jvm有深入理解，不然怎么搞啊。再说，jvm面试也比较看重，面向招聘学习和我的目标符合的很好。计划是每天看一章吧，反正我又不听课，时间多的是。\n\n个人项目。所有的这些我正在学习的知识，都是为了解决实际问题而提出来的，解决实际问题也是最终目的。我有两个觉得值得一试的项目，这个阶段这样子：用Spring给我的网页版Library做一个登录页面，实现登录、注册功能，最好用spring。用javaFX给我的客户端版Library做一个登录页面，实现登录注册功能。\n\n每天跟那个Youtube老哥学JavaFX，一集就好，我很喜欢那个老哥的风格，我觉得编程课就应该是那个样子，一边敲一边给你解释。假如我以后要做什么教程，最好也是这个样子，虽然我的C++老师很认真负责，但那种教学方式，idk，可能不太适合。\n\n\n我希望自己是丢了芝麻捡了西瓜（指不关注学校开设的课程），但如果没捡到西瓜，那不管丢的是不是芝麻，都是血亏的。少打点守望先锋。\n","categories":["Essay"]},{"title":"overwatch_Anniversary","url":"/2020/05/21/overwatch/","content":"四周年不知不觉已经打了四年守望了，游戏时间将近1000个小时，是我这辈子玩的时间最长的游戏。我从第一个赛季就开始玩儿，现在已经900级了，如果考虑到当初防沉迷的限制（游戏时间3小时以上就不再有经验），我现在应该已经1000级了。再考虑到，我帮好几个同学从黄金上到钻石，游戏时间还要再往上涨。不过就算玩了这么久，昨天周年庆有活动，还是去网吧又玩了8个小时，这游戏的魅力自然不必多说了。\n\n\n\n\n在2016年之前，我玩的最多的大概是4399之类的，小学的时候很喜欢玩穿越火线，QQ飞车。第一次玩守望先锋的时候，就被游戏的精良程度震撼了，开始先是借同学的号玩儿，越玩越有意思。虽然我是穷B，但还是咬咬牙，买了。之后有优惠活动的时候，我还升级了典藏版。之前去网吧和同学可以组六轮车，虽然基本没赢过。现在还在坚守守望先锋的几乎只剩下我了。\n起初感觉10块钱的鼠标和键盘用起来不亦乐乎，随着对游戏更深一步的理解，鼠标成为我的瓶颈。因为10块钱的鼠标，如果我转速太快，鼠标就会“失灵”。经常因为这个原因，白给。又咬咬牙，上淘宝买了个稍微上档次一点的鼠标（二手的），不得不说，质量真的好，现在还没坏，除了鼠标底面的防滑贴已经被磨烂了（上次我上淘宝花了几块钱买了更厚的），除了大拇指这边的硅胶已经被磨烂了（这个好像无法挽回）。\n之前去网吧不太了解垂直同步的事情，导致我在网吧水平下滑的厉害。关掉垂直同步的那一刻，我感觉我水平上升了1000分。\n之前不太懂显卡，家里的GTX950就能畅玩守望先锋了，不得不说，这游戏优化很好。\n之前觉得60Hz已经无敌了，直到我用过了144Hz，现在看60Hz就很卡，感觉帧数很低。曾经沧海难为水。\n之前看到金框很惊讶，现在看到钻石框已经见怪不怪了。\n之前玩家水平都很低，对这个游戏还在理解状态。现在老玩家都挺厉害的，这游戏少了很多神秘的魅力。\n我有时候在想，要是把打守望的时间用来学java，这时候我应该真的有“四年开发经验”了，或许去一家公司已经能干活儿了。\n我有时候在想，要是学java的时候，能像打守望一样专心致志，一玩儿就是8个小时，我java就不用这么菜了。\n昨天的箱子：两金一紫。可能是我最欧的一次了。\n\n\n第一把金武器。\n\n\n几乎全收集了：\n\n\n\n\nThe music, is playing again…it can’t be stopped…","categories":["Essay"]},{"title":"proxy","url":"/2020/05/12/proxy/","content":"Proxy\n定义为其他对象提供代理以控制对这个对象的访问栗子我的梯子（V2Ray）\n当我请求网络时，我的梯子接受我的请求\n\n看看这是不是外国的域名（假如我开启了PAC）\n\n是\n\n拦截请求，我来帮你做一些事\n\n\n否\n\n放行\n\n\n\n\n\n\n\nProxy VS AdapterAdapter把A接口转为B接口Proxy不改变接口应用权限检查\n可以在调用目标接口前后添加一些功能\n\n栗子\n\n比如我的梯子（权限检查）\n\n\n为啥不直接在目标接口里实现呢？\n\n每个类应该各司其职\n我要开发一款梯子，有现成的接口可以调用，何必重复造轮子\n\n\n\n\n\nRemote Proxy\n栗子\n\nTeamViewer\n\n\n我的接口是个代理，这个代理负责把对方法的访问转化成远程调用\n\n\nVirtual Proxy\n不到万不得已，代理对象是不会创建的\n\n栗子\n\nJDBC\n\n执行SQL语句才创建代理对象\n\n\n\n\n\nProtection Proxy\n用代理对象控制对原始对象的访问\n\nSmart Reference\n可以smart的释放资源\n\n","categories":["Design Patterns"]},{"title":"sort.Search","url":"/2021/05/09/sort-Search/","content":"二分查找Go的sort包提供了一个二分查找的方法：sort.Search：\nfunc Search(n int, f func(int) bool) int\n\n最初第一次看到这个函数的参数和返回值，有点疑惑，在我的印象中，二分查找是在一个有序数组中查找某一个特定的元素，返回其在数组中的位置。但接受一个整型的n和一个返回布尔值的闭包函数是为哪般？\n看了文档，用了几次之后，越来越发觉这个函数设计的很妙。\n\n\n有序不一定非得是 [1, 2, 3, 4] ，可以再放宽条件：存在一个分界点（数组中的某个元素，假设下标为i），分界点的左边有同一种特质，分界点及其右边有另一种特质，对应到这个函数，则是：f(0 ~ i-1) == false，f(i ~ n) == true，其中n是数组的大小。\n接着就可以用折半（二分）查找的方式，找到该分界点。\n可以用该函数查找有序数组中的某个元素位置：\nnums := []int&#123;1, 2, 3, 4, 5&#125;x := sort.Search(4, func(i int) bool &#123;\treturn nums[i] &gt;= 4&#125;)fmt.Println(x) // x = 3\n\n更为重要的是，可以查找“那个”分界点。比如这道算法题：\n1482. 制作 m 束花所需的最少天数拥有更强的泛化能力，但sort.Search的实现，却和二分查找如出一辙：\nfunc Search(n int, f func(int) bool) int &#123;\t// Define f(-1) == false and f(n) == true.\t// Invariant: f(i-1) == false, f(j) == true.\ti, j := 0, n\tfor i &lt; j &#123;\t\th := int(uint(i+j) &gt;&gt; 1) // avoid overflow when computing h\t\t// i ≤ h &lt; j\t\tif !f(h) &#123;\t\t\ti = h + 1 // preserves f(i-1) == false\t\t&#125; else &#123;\t\t\tj = h // preserves f(j) == true\t\t&#125;\t&#125;\t// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.\treturn i&#125;\n\n值得注意的是，假如没找到那个分界点，会返回0，而不是-1 。\n\nSearch uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) &#x3D;&#x3D; true implies f(i+1) &#x3D;&#x3D; true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the “not found” return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered.For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &gt;&#x3D; 23 }) returns the smallest index i such that data[i] &gt;&#x3D; 23. If the caller wants to find whether 23 is in the slice, it must test data[i] &#x3D;&#x3D; 23 separately.Searching data sorted in descending order would use the &lt;&#x3D; operator instead of the &gt;&#x3D; operator.To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:\n\nx := 23i := sort.Search(len(data), func(i int) bool &#123; return data[i] &gt;= x &#125;)if i &lt; len(data) &amp;&amp; data[i] == x &#123; // x is present at data[i]&#125; else &#123; // x is not present in data, // but i is the index where it would be inserted.&#125;\n\n\nAs a more whimsical example, this program guesses your number:\n\nfunc GuessingGame() &#123; var s string fmt.Printf(&quot;Pick an integer from 0 to 100.\\n&quot;) answer := sort.Search(100, func(i int) bool &#123;  fmt.Printf(&quot;Is your number &lt;= %d? &quot;, i)  fmt.Scanf(&quot;%s&quot;, &amp;s)  return s != &quot;&quot; &amp;&amp; s[0] == &#x27;y&#x27; &#125;) fmt.Printf(&quot;Your number is %d.\\n&quot;, answer)&#125;\n\n","categories":["数据结构与算法"]},{"title":"spring-demo项目说明","url":"/2020/07/23/spring-demo%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/","content":"最终效果体验http://47.98.252.1:8082/\n体验账号\n\ntracer@battlenet.com  \ntracer\n\n\n\nindex页面如果未登录，index页面会有Sign In按钮，不会有提示消息。\n如果已登录，index页面会有Log Out按钮，有welcome+用户名的提示消息。\n\n\n\n\n登录页面登录失败会有红色提示\n\n\n注册页面注册失败会有红色提示\n\n\n个人界面目前不能上传自定义头像\n\n\n技术栈\nSpring Boot\nThymeleaf\nMySQL\nHTML + CSS + Bootstrap\n\n运行本地需要有一个MySQL数据库才能运行\ntable的创建命令：\nCREATE DATABASE spring;CREATE TABLE `users` (  `id` bigint NOT NULL AUTO_INCREMENT,  `email` varchar(100) NOT NULL,  `password` varchar(100) NOT NULL,  `name` varchar(100) NOT NULL,  `createdAt` bigint NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `users_email_uindex` (`email`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8","categories":["Spring"]},{"title":"protoactor：聊天室的栗子","url":"/2021/04/18/protoactor%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%9A%84%E6%A0%97%E5%AD%90/","content":"展示\n\n\n\n\n\n消息定义The main ingredient of gRPC are Protocol Buffers aka Protobuf. Protobuf is an interface definition language that enables us to define contracts between services (messages and endpoints) in a language natural fashion.We can then take these contracts and use gRPC in order to generate clients and servers in different languages and take care of all of the underlying transport mechanism and serialization&#x2F;deserialization of those messages.\nsyntax = &quot;proto3&quot;;package messages;import &quot;github.com/AsynkronIT/protoactor-go/actor/protos.proto&quot;;message Connect &#123;    actor.PID Sender = 1;&#125;message Connected &#123;    string Message = 1;&#125;message SayRequest &#123;    string UserName = 1;    string Message = 2;&#125;message SayResponse &#123;    string UserName = 1;    string Message = 2;&#125;message NickRequest &#123;    string OldUserName = 1;    string NewUserName = 2;&#125;message NickResponse &#123;    string OldUserName = 1;    string NewUserName = 2;&#125;\n\n为了让GO语言识别，需要将proto文件编译成GO文件，如果proto文件有依赖项（import），还需要在编译命令中指明依赖项所在位置（-I）。但在开启了GO MODULE的环境下，所有的依赖包被放在$GOPATH/pkg/mod下，路径里用!代表大写字母，还有依赖的版本号，这都是protoc编译器无法识别的，我也没有查到好的方法。\n\n可以编写一个bash脚本，利用go list，进行转换。\n\n#!/usr/bin/env shset -emou pipefail# Set parent directory to hold all the symlinksPROTOBUF_IMPORT_DIR=&#x27;protobuf-import&#x27;mkdir -p &quot;$&#123;PROTOBUF_IMPORT_DIR&#125;&quot;# Remove any existing symlinks &amp; empty directories find &quot;$&#123;PROTOBUF_IMPORT_DIR&#125;&quot; -type l -deletefind &quot;$&#123;PROTOBUF_IMPORT_DIR&#125;&quot; -type d -empty -delete# Download all the required dependenciesgo mod download# Get all the modules we use and create required directory structurego list -f &quot;$&#123;PROTOBUF_IMPORT_DIR&#125;/&#123;&#123; .Path &#125;&#125;&quot; -m all \\  | xargs -L1 dirname | sort | uniq | xargs mkdir -p# Create symlinksgo list -f &quot;&#123;&#123; .Dir &#125;&#125; $&#123;PROTOBUF_IMPORT_DIR&#125;/&#123;&#123; .Path &#125;&#125;&quot; -m all \\  | xargs -L1 -- ln -s\n\n\n使用go vender把所有依赖挪到项目目录下，但如果proto文件依赖了go.mod中不存在的proto文件，这又是一个问题_(¦3」∠)_\n\n编译后的结果：\n// Code generated by protoc-gen-gogo. DO NOT EDIT.// source: protos.protopackage messagesimport (\tfmt &quot;fmt&quot;\tactor &quot;github.com/AsynkronIT/protoactor-go/actor&quot;\tproto &quot;github.com/gogo/protobuf/proto&quot;\tio &quot;io&quot;\tmath &quot;math&quot;\treflect &quot;reflect&quot;\tstrings &quot;strings&quot;)// Reference imports to suppress errors if they are not otherwise used.var _ = proto.Marshalvar _ = fmt.Errorfvar _ = math.Inf// This is a compile-time assertion to ensure that this generated file// is compatible with the proto package it is being compiled against.// A compilation error at this line likely means your copy of the// proto package needs to be updated.const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto packagetype Connect struct &#123;\tSender *actor.PID `protobuf:&quot;bytes,1,opt,name=Sender,proto3&quot; json:&quot;Sender,omitempty&quot;`&#125;func (m *Connect) Reset()      &#123; *m = Connect&#123;&#125; &#125;func (*Connect) ProtoMessage() &#123;&#125;func (*Connect) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;0&#125;&#125;func (m *Connect) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *Connect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_Connect.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *Connect) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_Connect.Merge(m, src)&#125;func (m *Connect) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *Connect) XXX_DiscardUnknown() &#123;\txxx_messageInfo_Connect.DiscardUnknown(m)&#125;var xxx_messageInfo_Connect proto.InternalMessageInfofunc (m *Connect) GetSender() *actor.PID &#123;\tif m != nil &#123;\t\treturn m.Sender\t&#125;\treturn nil&#125;type Connected struct &#123;\tMessage string `protobuf:&quot;bytes,1,opt,name=Message,proto3&quot; json:&quot;Message,omitempty&quot;`&#125;func (m *Connected) Reset()      &#123; *m = Connected&#123;&#125; &#125;func (*Connected) ProtoMessage() &#123;&#125;func (*Connected) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;1&#125;&#125;func (m *Connected) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *Connected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_Connected.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *Connected) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_Connected.Merge(m, src)&#125;func (m *Connected) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *Connected) XXX_DiscardUnknown() &#123;\txxx_messageInfo_Connected.DiscardUnknown(m)&#125;var xxx_messageInfo_Connected proto.InternalMessageInfofunc (m *Connected) GetMessage() string &#123;\tif m != nil &#123;\t\treturn m.Message\t&#125;\treturn &quot;&quot;&#125;type SayRequest struct &#123;\tUserName string `protobuf:&quot;bytes,1,opt,name=UserName,proto3&quot; json:&quot;UserName,omitempty&quot;`\tMessage  string `protobuf:&quot;bytes,2,opt,name=Message,proto3&quot; json:&quot;Message,omitempty&quot;`&#125;func (m *SayRequest) Reset()      &#123; *m = SayRequest&#123;&#125; &#125;func (*SayRequest) ProtoMessage() &#123;&#125;func (*SayRequest) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;2&#125;&#125;func (m *SayRequest) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *SayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_SayRequest.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *SayRequest) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_SayRequest.Merge(m, src)&#125;func (m *SayRequest) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *SayRequest) XXX_DiscardUnknown() &#123;\txxx_messageInfo_SayRequest.DiscardUnknown(m)&#125;var xxx_messageInfo_SayRequest proto.InternalMessageInfofunc (m *SayRequest) GetUserName() string &#123;\tif m != nil &#123;\t\treturn m.UserName\t&#125;\treturn &quot;&quot;&#125;func (m *SayRequest) GetMessage() string &#123;\tif m != nil &#123;\t\treturn m.Message\t&#125;\treturn &quot;&quot;&#125;type SayResponse struct &#123;\tUserName string `protobuf:&quot;bytes,1,opt,name=UserName,proto3&quot; json:&quot;UserName,omitempty&quot;`\tMessage  string `protobuf:&quot;bytes,2,opt,name=Message,proto3&quot; json:&quot;Message,omitempty&quot;`&#125;func (m *SayResponse) Reset()      &#123; *m = SayResponse&#123;&#125; &#125;func (*SayResponse) ProtoMessage() &#123;&#125;func (*SayResponse) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;3&#125;&#125;func (m *SayResponse) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *SayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_SayResponse.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *SayResponse) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_SayResponse.Merge(m, src)&#125;func (m *SayResponse) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *SayResponse) XXX_DiscardUnknown() &#123;\txxx_messageInfo_SayResponse.DiscardUnknown(m)&#125;var xxx_messageInfo_SayResponse proto.InternalMessageInfofunc (m *SayResponse) GetUserName() string &#123;\tif m != nil &#123;\t\treturn m.UserName\t&#125;\treturn &quot;&quot;&#125;func (m *SayResponse) GetMessage() string &#123;\tif m != nil &#123;\t\treturn m.Message\t&#125;\treturn &quot;&quot;&#125;type NickRequest struct &#123;\tOldUserName string `protobuf:&quot;bytes,1,opt,name=OldUserName,proto3&quot; json:&quot;OldUserName,omitempty&quot;`\tNewUserName string `protobuf:&quot;bytes,2,opt,name=NewUserName,proto3&quot; json:&quot;NewUserName,omitempty&quot;`&#125;func (m *NickRequest) Reset()      &#123; *m = NickRequest&#123;&#125; &#125;func (*NickRequest) ProtoMessage() &#123;&#125;func (*NickRequest) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;4&#125;&#125;func (m *NickRequest) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *NickRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_NickRequest.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *NickRequest) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_NickRequest.Merge(m, src)&#125;func (m *NickRequest) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *NickRequest) XXX_DiscardUnknown() &#123;\txxx_messageInfo_NickRequest.DiscardUnknown(m)&#125;var xxx_messageInfo_NickRequest proto.InternalMessageInfofunc (m *NickRequest) GetOldUserName() string &#123;\tif m != nil &#123;\t\treturn m.OldUserName\t&#125;\treturn &quot;&quot;&#125;func (m *NickRequest) GetNewUserName() string &#123;\tif m != nil &#123;\t\treturn m.NewUserName\t&#125;\treturn &quot;&quot;&#125;type NickResponse struct &#123;\tOldUserName string `protobuf:&quot;bytes,1,opt,name=OldUserName,proto3&quot; json:&quot;OldUserName,omitempty&quot;`\tNewUserName string `protobuf:&quot;bytes,2,opt,name=NewUserName,proto3&quot; json:&quot;NewUserName,omitempty&quot;`&#125;func (m *NickResponse) Reset()      &#123; *m = NickResponse&#123;&#125; &#125;func (*NickResponse) ProtoMessage() &#123;&#125;func (*NickResponse) Descriptor() ([]byte, []int) &#123;\treturn fileDescriptor_5da3cbeb884d181c, []int&#123;5&#125;&#125;func (m *NickResponse) XXX_Unmarshal(b []byte) error &#123;\treturn m.Unmarshal(b)&#125;func (m *NickResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) &#123;\tif deterministic &#123;\t\treturn xxx_messageInfo_NickResponse.Marshal(b, m, deterministic)\t&#125; else &#123;\t\tb = b[:cap(b)]\t\tn, err := m.MarshalTo(b)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\treturn b[:n], nil\t&#125;&#125;func (m *NickResponse) XXX_Merge(src proto.Message) &#123;\txxx_messageInfo_NickResponse.Merge(m, src)&#125;func (m *NickResponse) XXX_Size() int &#123;\treturn m.Size()&#125;func (m *NickResponse) XXX_DiscardUnknown() &#123;\txxx_messageInfo_NickResponse.DiscardUnknown(m)&#125;var xxx_messageInfo_NickResponse proto.InternalMessageInfofunc (m *NickResponse) GetOldUserName() string &#123;\tif m != nil &#123;\t\treturn m.OldUserName\t&#125;\treturn &quot;&quot;&#125;func (m *NickResponse) GetNewUserName() string &#123;\tif m != nil &#123;\t\treturn m.NewUserName\t&#125;\treturn &quot;&quot;&#125;func init() &#123;\tproto.RegisterType((*Connect)(nil), &quot;messages.Connect&quot;)\tproto.RegisterType((*Connected)(nil), &quot;messages.Connected&quot;)\tproto.RegisterType((*SayRequest)(nil), &quot;messages.SayRequest&quot;)\tproto.RegisterType((*SayResponse)(nil), &quot;messages.SayResponse&quot;)\tproto.RegisterType((*NickRequest)(nil), &quot;messages.NickRequest&quot;)\tproto.RegisterType((*NickResponse)(nil), &quot;messages.NickResponse&quot;)&#125;func init() &#123; proto.RegisterFile(&quot;protos.proto&quot;, fileDescriptor_5da3cbeb884d181c) &#125;var fileDescriptor_5da3cbeb884d181c = []byte&#123;\t// 296 bytes of a gzipped FileDescriptorProto\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x29, 0x28, 0xca, 0x2f,\t0xc9, 0x2f, 0xd6, 0x03, 0x53, 0x42, 0x1c, 0xb9, 0xa9, 0xc5, 0xc5, 0x89, 0xe9, 0xa9, 0xc5, 0x52,\t0x66, 0xe9, 0x99, 0x25, 0x19, 0xa5, 0x49, 0x7a, 0xc9, 0xf9, 0xb9, 0xfa, 0x8e, 0xc5, 0x95, 0x79,\t0xd9, 0x45, 0xf9, 0x79, 0x9e, 0x21, 0xfa, 0x60, 0x65, 0x89, 0xc9, 0x25, 0xf9, 0x45, 0xba, 0xe9,\t0xf9, 0xfa, 0x60, 0x86, 0x3e, 0xb2, 0x09, 0x4a, 0xba, 0x5c, 0xec, 0xce, 0xf9, 0x79, 0x79, 0xa9,\t0xc9, 0x25, 0x42, 0x4a, 0x5c, 0x6c, 0xc1, 0xa9, 0x79, 0x29, 0xa9, 0x45, 0x12, 0x8c, 0x0a, 0x8c,\t0x1a, 0xdc, 0x46, 0x5c, 0x7a, 0x60, 0xf5, 0x7a, 0x01, 0x9e, 0x2e, 0x41, 0x50, 0x19, 0x25, 0x55,\t0x2e, 0x4e, 0xa8, 0xf2, 0xd4, 0x14, 0x21, 0x09, 0x2e, 0x76, 0x5f, 0x88, 0xfd, 0x60, 0x1d, 0x9c,\t0x41, 0x30, 0xae, 0x92, 0x13, 0x17, 0x57, 0x70, 0x62, 0x65, 0x50, 0x6a, 0x61, 0x69, 0x6a, 0x71,\t0x89, 0x90, 0x14, 0x17, 0x47, 0x68, 0x71, 0x6a, 0x91, 0x5f, 0x62, 0x2e, 0x4c, 0x21, 0x9c, 0x8f,\t0x6c, 0x06, 0x13, 0xaa, 0x19, 0xce, 0x5c, 0xdc, 0x60, 0x33, 0x8a, 0x0b, 0xf2, 0xf3, 0x8a, 0x53,\t0xc9, 0x34, 0x24, 0x90, 0x8b, 0xdb, 0x2f, 0x33, 0x39, 0x1b, 0xe6, 0x12, 0x05, 0x2e, 0x6e, 0xff,\t0x9c, 0x14, 0x34, 0x73, 0x90, 0x85, 0x40, 0x2a, 0xfc, 0x52, 0xcb, 0xe1, 0x2a, 0x20, 0xc6, 0x21,\t0x0b, 0x29, 0x05, 0x71, 0xf1, 0x40, 0x8c, 0x84, 0x3a, 0x8c, 0x0a, 0x66, 0x3a, 0x99, 0x5c, 0x78,\t0x28, 0xc7, 0x70, 0xe3, 0xa1, 0x1c, 0xc3, 0x87, 0x87, 0x72, 0x8c, 0x0d, 0x8f, 0xe4, 0x18, 0x57,\t0x3c, 0x92, 0x63, 0x3c, 0xf1, 0x48, 0x8e, 0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4, 0x18,\t0x5f, 0x3c, 0x92, 0x63, 0xf8, 0xf0, 0x48, 0x8e, 0x71, 0xc2, 0x63, 0x39, 0x86, 0x0b, 0x8f, 0xe5,\t0x18, 0x6e, 0x3c, 0x96, 0x63, 0x48, 0x62, 0x03, 0x47, 0xa1, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff,\t0x10, 0x62, 0xa9, 0x3d, 0x14, 0x02, 0x00, 0x00,&#125;func (this *Connect) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*Connect)\tif !ok &#123;\t\tthat2, ok := that.(Connect)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif !this.Sender.Equal(that1.Sender) &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *Connected) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*Connected)\tif !ok &#123;\t\tthat2, ok := that.(Connected)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif this.Message != that1.Message &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *SayRequest) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*SayRequest)\tif !ok &#123;\t\tthat2, ok := that.(SayRequest)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif this.UserName != that1.UserName &#123;\t\treturn false\t&#125;\tif this.Message != that1.Message &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *SayResponse) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*SayResponse)\tif !ok &#123;\t\tthat2, ok := that.(SayResponse)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif this.UserName != that1.UserName &#123;\t\treturn false\t&#125;\tif this.Message != that1.Message &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *NickRequest) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*NickRequest)\tif !ok &#123;\t\tthat2, ok := that.(NickRequest)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif this.OldUserName != that1.OldUserName &#123;\t\treturn false\t&#125;\tif this.NewUserName != that1.NewUserName &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *NickResponse) Equal(that interface&#123;&#125;) bool &#123;\tif that == nil &#123;\t\treturn this == nil\t&#125;\tthat1, ok := that.(*NickResponse)\tif !ok &#123;\t\tthat2, ok := that.(NickResponse)\t\tif ok &#123;\t\t\tthat1 = &amp;that2\t\t&#125; else &#123;\t\t\treturn false\t\t&#125;\t&#125;\tif that1 == nil &#123;\t\treturn this == nil\t&#125; else if this == nil &#123;\t\treturn false\t&#125;\tif this.OldUserName != that1.OldUserName &#123;\t\treturn false\t&#125;\tif this.NewUserName != that1.NewUserName &#123;\t\treturn false\t&#125;\treturn true&#125;func (this *Connect) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 5)\ts = append(s, &quot;&amp;messages.Connect&#123;&quot;)\tif this.Sender != nil &#123;\t\ts = append(s, &quot;Sender: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.Sender)+&quot;,\\n&quot;)\t&#125;\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func (this *Connected) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 5)\ts = append(s, &quot;&amp;messages.Connected&#123;&quot;)\ts = append(s, &quot;Message: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.Message)+&quot;,\\n&quot;)\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func (this *SayRequest) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 6)\ts = append(s, &quot;&amp;messages.SayRequest&#123;&quot;)\ts = append(s, &quot;UserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.UserName)+&quot;,\\n&quot;)\ts = append(s, &quot;Message: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.Message)+&quot;,\\n&quot;)\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func (this *SayResponse) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 6)\ts = append(s, &quot;&amp;messages.SayResponse&#123;&quot;)\ts = append(s, &quot;UserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.UserName)+&quot;,\\n&quot;)\ts = append(s, &quot;Message: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.Message)+&quot;,\\n&quot;)\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func (this *NickRequest) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 6)\ts = append(s, &quot;&amp;messages.NickRequest&#123;&quot;)\ts = append(s, &quot;OldUserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.OldUserName)+&quot;,\\n&quot;)\ts = append(s, &quot;NewUserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.NewUserName)+&quot;,\\n&quot;)\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func (this *NickResponse) GoString() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := make([]string, 0, 6)\ts = append(s, &quot;&amp;messages.NickResponse&#123;&quot;)\ts = append(s, &quot;OldUserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.OldUserName)+&quot;,\\n&quot;)\ts = append(s, &quot;NewUserName: &quot;+fmt.Sprintf(&quot;%#v&quot;, this.NewUserName)+&quot;,\\n&quot;)\ts = append(s, &quot;&#125;&quot;)\treturn strings.Join(s, &quot;&quot;)&#125;func valueToGoStringProtos(v interface&#123;&#125;, typ string) string &#123;\trv := reflect.ValueOf(v)\tif rv.IsNil() &#123;\t\treturn &quot;nil&quot;\t&#125;\tpv := reflect.Indirect(rv).Interface()\treturn fmt.Sprintf(&quot;func(v %v) *%v &#123; return &amp;v &#125; ( %#v )&quot;, typ, typ, pv)&#125;func (m *Connect) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *Connect) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif m.Sender != nil &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(m.Sender.Size()))\t\tn1, err := m.Sender.MarshalTo(dAtA[i:])\t\tif err != nil &#123;\t\t\treturn 0, err\t\t&#125;\t\ti += n1\t&#125;\treturn i, nil&#125;func (m *Connected) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *Connected) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif len(m.Message) &gt; 0 &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.Message)))\t\ti += copy(dAtA[i:], m.Message)\t&#125;\treturn i, nil&#125;func (m *SayRequest) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *SayRequest) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif len(m.UserName) &gt; 0 &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.UserName)))\t\ti += copy(dAtA[i:], m.UserName)\t&#125;\tif len(m.Message) &gt; 0 &#123;\t\tdAtA[i] = 0x12\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.Message)))\t\ti += copy(dAtA[i:], m.Message)\t&#125;\treturn i, nil&#125;func (m *SayResponse) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *SayResponse) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif len(m.UserName) &gt; 0 &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.UserName)))\t\ti += copy(dAtA[i:], m.UserName)\t&#125;\tif len(m.Message) &gt; 0 &#123;\t\tdAtA[i] = 0x12\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.Message)))\t\ti += copy(dAtA[i:], m.Message)\t&#125;\treturn i, nil&#125;func (m *NickRequest) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *NickRequest) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif len(m.OldUserName) &gt; 0 &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.OldUserName)))\t\ti += copy(dAtA[i:], m.OldUserName)\t&#125;\tif len(m.NewUserName) &gt; 0 &#123;\t\tdAtA[i] = 0x12\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.NewUserName)))\t\ti += copy(dAtA[i:], m.NewUserName)\t&#125;\treturn i, nil&#125;func (m *NickResponse) Marshal() (dAtA []byte, err error) &#123;\tsize := m.Size()\tdAtA = make([]byte, size)\tn, err := m.MarshalTo(dAtA)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn dAtA[:n], nil&#125;func (m *NickResponse) MarshalTo(dAtA []byte) (int, error) &#123;\tvar i int\t_ = i\tvar l int\t_ = l\tif len(m.OldUserName) &gt; 0 &#123;\t\tdAtA[i] = 0xa\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.OldUserName)))\t\ti += copy(dAtA[i:], m.OldUserName)\t&#125;\tif len(m.NewUserName) &gt; 0 &#123;\t\tdAtA[i] = 0x12\t\ti++\t\ti = encodeVarintProtos(dAtA, i, uint64(len(m.NewUserName)))\t\ti += copy(dAtA[i:], m.NewUserName)\t&#125;\treturn i, nil&#125;func encodeVarintProtos(dAtA []byte, offset int, v uint64) int &#123;\tfor v &gt;= 1&lt;&lt;7 &#123;\t\tdAtA[offset] = uint8(v&amp;0x7f | 0x80)\t\tv &gt;&gt;= 7\t\toffset++\t&#125;\tdAtA[offset] = uint8(v)\treturn offset + 1&#125;func (m *Connect) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tif m.Sender != nil &#123;\t\tl = m.Sender.Size()\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func (m *Connected) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tl = len(m.Message)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func (m *SayRequest) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tl = len(m.UserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\tl = len(m.Message)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func (m *SayResponse) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tl = len(m.UserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\tl = len(m.Message)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func (m *NickRequest) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tl = len(m.OldUserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\tl = len(m.NewUserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func (m *NickResponse) Size() (n int) &#123;\tif m == nil &#123;\t\treturn 0\t&#125;\tvar l int\t_ = l\tl = len(m.OldUserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\tl = len(m.NewUserName)\tif l &gt; 0 &#123;\t\tn += 1 + l + sovProtos(uint64(l))\t&#125;\treturn n&#125;func sovProtos(x uint64) (n int) &#123;\tfor &#123;\t\tn++\t\tx &gt;&gt;= 7\t\tif x == 0 &#123;\t\t\tbreak\t\t&#125;\t&#125;\treturn n&#125;func sozProtos(x uint64) (n int) &#123;\treturn sovProtos(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))&#125;func (this *Connect) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;Connect&#123;`,\t\t`Sender:` + strings.Replace(fmt.Sprintf(&quot;%v&quot;, this.Sender), &quot;PID&quot;, &quot;actor.PID&quot;, 1) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func (this *Connected) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;Connected&#123;`,\t\t`Message:` + fmt.Sprintf(&quot;%v&quot;, this.Message) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func (this *SayRequest) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;SayRequest&#123;`,\t\t`UserName:` + fmt.Sprintf(&quot;%v&quot;, this.UserName) + `,`,\t\t`Message:` + fmt.Sprintf(&quot;%v&quot;, this.Message) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func (this *SayResponse) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;SayResponse&#123;`,\t\t`UserName:` + fmt.Sprintf(&quot;%v&quot;, this.UserName) + `,`,\t\t`Message:` + fmt.Sprintf(&quot;%v&quot;, this.Message) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func (this *NickRequest) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;NickRequest&#123;`,\t\t`OldUserName:` + fmt.Sprintf(&quot;%v&quot;, this.OldUserName) + `,`,\t\t`NewUserName:` + fmt.Sprintf(&quot;%v&quot;, this.NewUserName) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func (this *NickResponse) String() string &#123;\tif this == nil &#123;\t\treturn &quot;nil&quot;\t&#125;\ts := strings.Join([]string&#123;`&amp;NickResponse&#123;`,\t\t`OldUserName:` + fmt.Sprintf(&quot;%v&quot;, this.OldUserName) + `,`,\t\t`NewUserName:` + fmt.Sprintf(&quot;%v&quot;, this.NewUserName) + `,`,\t\t`&#125;`,\t&#125;, &quot;&quot;)\treturn s&#125;func valueToStringProtos(v interface&#123;&#125;) string &#123;\trv := reflect.ValueOf(v)\tif rv.IsNil() &#123;\t\treturn &quot;nil&quot;\t&#125;\tpv := reflect.Indirect(rv).Interface()\treturn fmt.Sprintf(&quot;*%v&quot;, pv)&#125;func (m *Connect) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: Connect: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: Connect: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field Sender&quot;, wireType)\t\t\t&#125;\t\t\tvar msglen int\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tmsglen |= int(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tif msglen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + msglen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tif m.Sender == nil &#123;\t\t\t\tm.Sender = &amp;actor.PID&#123;&#125;\t\t\t&#125;\t\t\tif err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func (m *Connected) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: Connected: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: Connected: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field Message&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.Message = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func (m *SayRequest) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: SayRequest: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: SayRequest: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field UserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.UserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tcase 2:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field Message&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.Message = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func (m *SayResponse) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: SayResponse: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: SayResponse: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field UserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.UserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tcase 2:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field Message&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.Message = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func (m *NickRequest) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: NickRequest: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: NickRequest: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field OldUserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.OldUserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tcase 2:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field NewUserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.NewUserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func (m *NickResponse) Unmarshal(dAtA []byte) error &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tpreIndex := iNdEx\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\tfieldNum := int32(wire &gt;&gt; 3)\t\twireType := int(wire &amp; 0x7)\t\tif wireType == 4 &#123;\t\t\treturn fmt.Errorf(&quot;proto: NickResponse: wiretype end group for non-group&quot;)\t\t&#125;\t\tif fieldNum &lt;= 0 &#123;\t\t\treturn fmt.Errorf(&quot;proto: NickResponse: illegal tag %d (wire type %d)&quot;, fieldNum, wire)\t\t&#125;\t\tswitch fieldNum &#123;\t\tcase 1:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field OldUserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.OldUserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tcase 2:\t\t\tif wireType != 2 &#123;\t\t\t\treturn fmt.Errorf(&quot;proto: wrong wireType = %d for field NewUserName&quot;, wireType)\t\t\t&#125;\t\t\tvar stringLen uint64\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tstringLen |= uint64(b&amp;0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tintStringLen := int(stringLen)\t\t\tif intStringLen &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tpostIndex := iNdEx + intStringLen\t\t\tif postIndex &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif postIndex &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tm.NewUserName = string(dAtA[iNdEx:postIndex])\t\t\tiNdEx = postIndex\t\tdefault:\t\t\tiNdEx = preIndex\t\t\tskippy, err := skipProtos(dAtA[iNdEx:])\t\t\tif err != nil &#123;\t\t\t\treturn err\t\t\t&#125;\t\t\tif skippy &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &lt; 0 &#123;\t\t\t\treturn ErrInvalidLengthProtos\t\t\t&#125;\t\t\tif (iNdEx + skippy) &gt; l &#123;\t\t\t\treturn io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tiNdEx += skippy\t\t&#125;\t&#125;\tif iNdEx &gt; l &#123;\t\treturn io.ErrUnexpectedEOF\t&#125;\treturn nil&#125;func skipProtos(dAtA []byte) (n int, err error) &#123;\tl := len(dAtA)\tiNdEx := 0\tfor iNdEx &lt; l &#123;\t\tvar wire uint64\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\tif shift &gt;= 64 &#123;\t\t\t\treturn 0, ErrIntOverflowProtos\t\t\t&#125;\t\t\tif iNdEx &gt;= l &#123;\t\t\t\treturn 0, io.ErrUnexpectedEOF\t\t\t&#125;\t\t\tb := dAtA[iNdEx]\t\t\tiNdEx++\t\t\twire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift\t\t\tif b &lt; 0x80 &#123;\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t\twireType := int(wire &amp; 0x7)\t\tswitch wireType &#123;\t\tcase 0:\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn 0, ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn 0, io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tiNdEx++\t\t\t\tif dAtA[iNdEx-1] &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn iNdEx, nil\t\tcase 1:\t\t\tiNdEx += 8\t\t\treturn iNdEx, nil\t\tcase 2:\t\t\tvar length int\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\treturn 0, ErrIntOverflowProtos\t\t\t\t&#125;\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\treturn 0, io.ErrUnexpectedEOF\t\t\t\t&#125;\t\t\t\tb := dAtA[iNdEx]\t\t\t\tiNdEx++\t\t\t\tlength |= (int(b) &amp; 0x7F) &lt;&lt; shift\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tif length &lt; 0 &#123;\t\t\t\treturn 0, ErrInvalidLengthProtos\t\t\t&#125;\t\t\tiNdEx += length\t\t\tif iNdEx &lt; 0 &#123;\t\t\t\treturn 0, ErrInvalidLengthProtos\t\t\t&#125;\t\t\treturn iNdEx, nil\t\tcase 3:\t\t\tfor &#123;\t\t\t\tvar innerWire uint64\t\t\t\tvar start int = iNdEx\t\t\t\tfor shift := uint(0); ; shift += 7 &#123;\t\t\t\t\tif shift &gt;= 64 &#123;\t\t\t\t\t\treturn 0, ErrIntOverflowProtos\t\t\t\t\t&#125;\t\t\t\t\tif iNdEx &gt;= l &#123;\t\t\t\t\t\treturn 0, io.ErrUnexpectedEOF\t\t\t\t\t&#125;\t\t\t\t\tb := dAtA[iNdEx]\t\t\t\t\tiNdEx++\t\t\t\t\tinnerWire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift\t\t\t\t\tif b &lt; 0x80 &#123;\t\t\t\t\t\tbreak\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tinnerWireType := int(innerWire &amp; 0x7)\t\t\t\tif innerWireType == 4 &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t\tnext, err := skipProtos(dAtA[start:])\t\t\t\tif err != nil &#123;\t\t\t\t\treturn 0, err\t\t\t\t&#125;\t\t\t\tiNdEx = start + next\t\t\t\tif iNdEx &lt; 0 &#123;\t\t\t\t\treturn 0, ErrInvalidLengthProtos\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn iNdEx, nil\t\tcase 4:\t\t\treturn iNdEx, nil\t\tcase 5:\t\t\tiNdEx += 4\t\t\treturn iNdEx, nil\t\tdefault:\t\t\treturn 0, fmt.Errorf(&quot;proto: illegal wireType %d&quot;, wireType)\t\t&#125;\t&#125;\tpanic(&quot;unreachable&quot;)&#125;var (\tErrInvalidLengthProtos = fmt.Errorf(&quot;proto: negative length found during unmarshaling&quot;)\tErrIntOverflowProtos   = fmt.Errorf(&quot;proto: integer overflow&quot;))\n\n客户端package mainimport (   &quot;log&quot;   &quot;chat/messages&quot;   console &quot;github.com/AsynkronIT/goconsole&quot;   &quot;github.com/AsynkronIT/protoactor-go/actor&quot;   &quot;github.com/AsynkronIT/protoactor-go/remote&quot;)func main() &#123;   system := actor.NewActorSystem()   config := remote.Configure(&quot;127.0.0.1&quot;, 0)   remoter := remote.NewRemote(system, config)   remoter.Start()   server := actor.NewPID(&quot;127.0.0.1:8080&quot;, &quot;chatserver&quot;)   // define root context   rootContext := system.Root   // spawn our chat client inline   props := actor.PropsFromFunc(func(context actor.Context) &#123;      switch msg := context.Message().(type) &#123;      case *messages.Connected:         log.Println(msg.Message)      case *messages.SayResponse:         log.Printf(&quot;%v: %v&quot;, msg.UserName, msg.Message)      case *messages.NickResponse:         log.Printf(&quot;%v is now known as %v&quot;, msg.OldUserName, msg.NewUserName)      &#125;   &#125;)   client := rootContext.Spawn(props)   rootContext.Send(server, &amp;messages.Connect&#123;      Sender: client,   &#125;)   nick := &quot;Roger&quot;   cons := console.NewConsole(func(text string) &#123;      rootContext.Send(server, &amp;messages.SayRequest&#123;         UserName: nick,         Message:  text,      &#125;)   &#125;)   // write /nick NAME to change your chat username   cons.Command(&quot;/nick&quot;, func(newNick string) &#123;      rootContext.Send(server, &amp;messages.NickRequest&#123;         OldUserName: nick,         NewUserName: newNick,      &#125;)      nick = newNick   &#125;)   cons.Run()&#125;\n\n服务端package mainimport (   &quot;log&quot;   &quot;chat/messages&quot;   console &quot;github.com/AsynkronIT/goconsole&quot;   &quot;github.com/AsynkronIT/protoactor-go/actor&quot;   &quot;github.com/AsynkronIT/protoactor-go/remote&quot;)// define root contextfunc notifyAll(context actor.Context, clients *actor.PIDSet, message interface&#123;&#125;) &#123;   for _, client := range clients.Values() &#123;      context.Send(client, message)   &#125;&#125;func main() &#123;   system := actor.NewActorSystem()   config := remote.Configure(&quot;127.0.0.1&quot;, 8080)   remoter := remote.NewRemote(system, config)   remoter.Start()   clients := actor.NewPIDSet()   props := actor.PropsFromFunc(func(context actor.Context) &#123;      switch msg := context.Message().(type) &#123;      case *messages.Connect:         log.Printf(&quot;Client %v connected&quot;, msg.Sender)         clients.Add(msg.Sender)         context.Send(msg.Sender, &amp;messages.Connected&#123;Message: &quot;Welcome!&quot;&#125;)      case *messages.SayRequest:         notifyAll(context, clients, &amp;messages.SayResponse&#123;            UserName: msg.UserName,            Message:  msg.Message,         &#125;)      case *messages.NickRequest:         notifyAll(context, clients, &amp;messages.NickResponse&#123;            OldUserName: msg.OldUserName,            NewUserName: msg.NewUserName,         &#125;)      &#125;   &#125;)   _, _ = system.Root.SpawnNamed(props, &quot;chatserver&quot;)   _, _ = console.ReadLine()&#125;\n\nReferencesImporting Protobuf with Go Modules | stepan.wtf\nGo Generated Code  | Protocol Buffers  | Google Developers\nChat Example Using Proto.Remote\n","categories":["Go"]},{"title":"state","url":"/2020/05/19/state/","content":"状态\n定义允许一个对象在其内部状态改变时改变它的行为对象看起来似乎修改了它的类栗子qq的状态\n我在线上\nQ我吧\n离开\n离线\n\n\n\n实现类的内部持有一个State，根据情况可以切换State把不同的状态分布到不同的类里价值连城的机器人package eternal.fire;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Robot arina = new Robot();        Scanner scanner = new Scanner(System.in);        while (true) &#123;            String s = scanner.next();            arina.chat(s);        &#125;    &#125;&#125;\n\npackage eternal.fire;public class ConnectedState implements State&#123;    @Override    public void reply() &#123;        System.out.println(&quot;my name is Arina, it&#x27;s nice to be with you&quot;);    &#125;&#125;\n\npackage eternal.fire;public class DisConnectedState implements State&#123;    @Override    public void reply() &#123;        System.out.println(&quot;hang on a second~, I will coming soon~~~&quot;);    &#125;&#125;\n\npackage eternal.fire;public class Robot &#123;    private State state = new DisConnectedState();    public void chat(String s) &#123;        if (s.equals(&quot;hi&quot;)) &#123;            state = new ConnectedState();        &#125;        if (s.equals(&quot;bye&quot;)) &#123;            state = new DisConnectedState();        &#125;        state.reply();    &#125;&#125;\n\n","categories":["Design Patterns"]},{"title":"visitor","url":"/2020/05/21/visitor/","content":"Visitor\n定义表示一个作用于某对象结构中的各元素的操作可以在不改变各元素的类的前提下定义作用于这些元素的新操作\n\n栗子递归遍历某个文件夹下的所有文件夹和文件package eternal.fire;import java.io.File;public interface Visitor &#123;    //visit a directory    void visitDir(File dir);    //visit a file    void visitFile(File file);&#125;\n\npackage eternal.fire;import java.io.File;import java.util.Objects;public class FileStructure &#123;    private File path;    public FileStructure(File path) &#123;        this.path = path;    &#125;    public void handle(Visitor visitor) &#123;        scan(path, visitor);    &#125;    private void scan(File file, Visitor visitor) &#123;        if (file.isDirectory()) &#123;            visitor.visitDir(file);            for (File f : Objects.requireNonNull(file.listFiles())) &#123;                scan(f, visitor);            &#125;        &#125; else if (file.isFile()) &#123;            visitor.visitFile(file);        &#125;    &#125;&#125;\n\npackage eternal.fire;import java.io.File;public class JavaFileVisitor implements Visitor &#123;    @Override    public void visitDir(File dir) &#123;        System.out.println(&quot;I&#x27;m visiting the directory:&quot; + dir);    &#125;    @Override    public void visitFile(File file) &#123;        System.out.println(&quot;I&#x27;m visiting the file:&quot; + file);    &#125;&#125;\n\npackage eternal.fire;import java.io.File;public class ClassFileVisitor implements Visitor&#123;    @Override    public void visitDir(File dir) &#123;    &#125;    @Override    public void visitFile(File file) &#123;        if (file.getName().endsWith(&quot;.class&quot;)) &#123;            System.out.println(&quot;I&#x27;m visiting the class file&quot;);        &#125;    &#125;&#125;\n\npackage eternal.fire;import java.io.File;public class Main &#123;    public static void main(String[] args) &#123;        FileStructure fileStructure = new FileStructure(new File(&quot;.&quot;));        fileStructure.handle(new JavaFileVisitor());        fileStructure.handle(new ClassFileVisitor());    &#125;&#125;\n\n输出I&#x27;m visiting the directory:.I&#x27;m visiting the directory:.\\.ideaI&#x27;m visiting the file:.\\.idea\\.gitignoreI&#x27;m visiting the file:.\\.idea\\misc.xmlI&#x27;m visiting the file:.\\.idea\\modules.xmlI&#x27;m visiting the file:.\\.idea\\workspace.xmlI&#x27;m visiting the directory:.\\outI&#x27;m visiting the directory:.\\out\\productionI&#x27;m visiting the directory:.\\out\\production\\VisitorI&#x27;m visiting the directory:.\\out\\production\\Visitor\\eternalI&#x27;m visiting the directory:.\\out\\production\\Visitor\\eternal\\fireI&#x27;m visiting the file:.\\out\\production\\Visitor\\eternal\\fire\\ClassFileVisitor.classI&#x27;m visiting the file:.\\out\\production\\Visitor\\eternal\\fire\\FileStructure.classI&#x27;m visiting the file:.\\out\\production\\Visitor\\eternal\\fire\\JavaFileVisitor.classI&#x27;m visiting the file:.\\out\\production\\Visitor\\eternal\\fire\\Main.classI&#x27;m visiting the file:.\\out\\production\\Visitor\\eternal\\fire\\Visitor.classI&#x27;m visiting the directory:.\\srcI&#x27;m visiting the directory:.\\src\\eternalI&#x27;m visiting the directory:.\\src\\eternal\\fireI&#x27;m visiting the file:.\\src\\eternal\\fire\\ClassFileVisitor.javaI&#x27;m visiting the file:.\\src\\eternal\\fire\\FileStructure.javaI&#x27;m visiting the file:.\\src\\eternal\\fire\\JavaFileVisitor.javaI&#x27;m visiting the file:.\\src\\eternal\\fire\\Main.javaI&#x27;m visiting the file:.\\src\\eternal\\fire\\Visitor.javaI&#x27;m visiting the file:.\\Visitor.imlI&#x27;m visiting the class file:.\\out\\production\\Visitor\\eternal\\fire\\ClassFileVisitor.classI&#x27;m visiting the class file:.\\out\\production\\Visitor\\eternal\\fire\\FileStructure.classI&#x27;m visiting the class file:.\\out\\production\\Visitor\\eternal\\fire\\JavaFileVisitor.classI&#x27;m visiting the class file:.\\out\\production\\Visitor\\eternal\\fire\\Main.classI&#x27;m visiting the class file:.\\out\\production\\Visitor\\eternal\\fire\\Visitor.classProcess finished with exit code 0\n\n\n\n优势新增操作而不必对现有的对象结构做任何改动","categories":["Design Patterns"]},{"title":"上路","url":"/2020/08/14/%E4%B8%8A%E8%B7%AF/","content":"八个月的假期已经结束，开学即期末，期末即挂科。\n","categories":["Experience"]},{"title":"两个有序数组中第K大的数","url":"/2021/04/06/%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0/","content":"一道算法上机题目，大概记录下思路。\n\n\n很容易想到的一个思路是，将两个数组归并，但这需要常数级的时间复杂度。\n两个数组A和B，各自有序，寻找其中第K大的数。\n可以从数组A中选前i个数，从数组B中选前j个数，使 i + j &#x3D; k\n再去比较一下 A[i] 和 B[j] 的大小关系，如此一来，便可以排除一部分元素。\n\nA[i] &lt; B[j]：我们的目标便锁定在A[i+1:]和B[:j+1]之间，接着在剩下的区间里找第 k - i 大的数\nA[i] &gt; B[j]：我们的目标便锁定在A[:i+1]和B[j+1:]之间，接着在剩下的区间里找第 k - j 大的数\n\npackage mainimport (\t&quot;fmt&quot;\t&quot;math/rand&quot;\t&quot;sort&quot;\t&quot;strconv&quot;)func main() &#123;\tvar nums1, nums2 []int\tset := make(map[int]bool)\tfor i := 0; i &lt; 10; i++ &#123;\t\trandNum := rand.Intn(100)\t\tif _, ok := set[randNum]; !ok &#123;\t\t\tset[randNum] = true\t\t\tnums1 = append(nums1, randNum)\t\t&#125;\t\trandNum = rand.Intn(100)\t\tif _, ok := set[randNum]; !ok &#123;\t\t\tset[randNum] = true\t\t\tnums2 = append(nums2, randNum)\t\t&#125;\t&#125;\tnums := append(nums1, nums2...)\tsort.Ints(nums1)\tsort.Ints(nums2)\tsort.Ints(nums)\tfmt.Println(nums1, nums2)\tfmt.Println(nums)\tfmt.Println(&quot;expect:&quot; + strconv.Itoa(nums[8]))\tfmt.Println(&quot;what I get:&quot; + strconv.Itoa(kthLargestNum(nums1, nums2, 9)))&#125;func kthLargestNum(A, B []int, k int) int &#123;\tif len(A) &gt; len(B) &#123;\t\treturn kthLargestNum(B, A, k)\t&#125;\tif len(A) == 0 &#123;\t\treturn B[k-1]\t&#125;\tif k == 1 &#123;\t\treturn min(A[0], B[0])\t&#125;\tvar i, j int\t// average if possible\tif k/2 &lt; len(A) &#123;\t\ti = (k / 2) - 1\t&#125; else &#123;\t\ti = len(A) - 1\t&#125;\tj = k - (i + 1) - 1\tfmt.Println(A, B, k, i, j)\tif A[i] &lt; B[j] &#123;\t\treturn kthLargestNum(A[i+1:], B[:j+1], k-i-1)\t&#125; else &#123;\t\treturn kthLargestNum(A[:i+1], B[j+1:], k-j-1)\t&#125;&#125;func min(a, b int) int &#123;\tif a &gt; b &#123;\t\treturn b\t&#125;\treturn a&#125;\n\n","categories":["数据结构与算法"]},{"title":"事件系统体系结构风格","url":"/2021/04/18/%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC/","content":"\n\n\n\n\n\n","categories":["软件体系结构"]},{"title":"事务（Transanction）","url":"/2020/12/08/%E4%BA%8B%E5%8A%A1%EF%BC%88Transanction%EF%BC%89/","content":"\n\n\n概念\n满足ACID特性的一组操作\n\n可以通过Commit提交，Rollback回滚\n\n\nACIDAtomicity\n特点\n\n不可分割的最小单元\n事务的操作要么全部提交成功，要么全部失败回滚\n\n\n回滚的实现\n\n回滚日志（Undo Log）\n\n\n\nConsistency\n特点\n\n数据库在事务执行前后都呆在正确的状态\n\n\n\nIsolation\n事务操作做出的修改在最终提交以前，对其它事务不可见\n\nDurability\n事务提交后，事务所做的修改永远保存在数据库中\n\nAuto Commit在MySQL里，如果不使用Start Transaction，每个语句都会被当做事务自动提交\n"},{"title":"人生的青春之问","url":"/2019/01/06/%E4%BA%BA%E7%94%9F%E7%9A%84%E9%9D%92%E6%98%A5%E4%B9%8B%E9%97%AE/","content":"","categories":["思修"]},{"title":"从微博图床到gitee","url":"/2020/07/24/%E4%BB%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A%E5%88%B0gitee/","content":"前因博客里经常需要插入一些图片，在我最开始写博客的时候，和大多数人一样，我的博客部署在github上，首先接触到的是微博图床。\n新浪微博的稳定性不必多说，加上Chrome微博图床插件更是妙不可言。\n最开始的那会儿微博对我这种白嫖行为没什么限制，到后来，因为觉得github访问速度慢，于是想把博客迁移到自己的服务器上。迁移成功之后，却发现所有图片都不能正常访问了。究其原因，原来是微博加上了某种限制措施。\n值得一提的是，如果博客部署在github或者gitee上，通过新浪微博生成的图片外链仍然可以正常访问，大概是因为github和gitee在微博的白名单里。\n最后，我把博客迁移到了gitee上。gitee相比于github的优势主要在于访问速度，美中不足的是普通用户需要手动去更新仓库内容。\n现在，我又觉得不过瘾，部署在github pages或者gitee pages的博客是很难被搜索引擎搜索到的（尤其是百度），还是想把博客部署在自己的服务器。\n无意中了解到Github也可以当做图床来使用，于是我做了一番尝试，发现github的资源保存在亚马逊s3上，而访问亚马逊s3需要科学上网，我又把注意力放在了国产github之gitee上。\ngitee也可以当做图床来用，现在最大的问题是：如何将我之前所有博客中微博图床的图片链接替换成gitee的链接呢？\n\n手动替换 ×\n用java √\n\n\n\n思路\n将markdown文件里的新浪微博图床的链接下载到本地\n将下载到本地的图片上传到gitee\n将markdown文件里的新浪微博图床的链接换成新的gitee的链接\n对所有markdown文件执行上述操作\n\n实现准备工作在gitee里建一个新的仓库，必须是public类型，在设置里new一个新的token备用。\n下载微博图片到本地package eternal.fire;import java.io.*;import java.net.URL;import java.net.URLConnection;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        URL url = new URL(&quot;http://ww1.sinaimg.cn/large/005VT09Qly1gh2fui1lhqj318w0u0aem.jpg&quot;);        URLConnection connection = url.openConnection();        InputStream inputStream = connection.getInputStream();        File pic = new File(&quot;D:\\\\Project\\\\IdeaProjects\\\\image-bed\\\\src\\\\main\\\\resources\\\\pic.jpg&quot;);        OutputStream outputStream = new FileOutputStream(pic);        int data;        while ((data = inputStream.read()) != -1) &#123;            outputStream.write(data);        &#125;        outputStream.flush();    &#125;&#125;\n\n这段代码执行完成之后，一张图片就成功的从微博图床下载到了本地。\n\n\n—————-未完待续—————-","categories":["Experience"]},{"title":"从溥仪看社会变迁","url":"/2019/06/14/%E4%BB%8E%E6%BA%A5%E4%BB%AA%E7%9C%8B%E7%A4%BE%E4%BC%9A%E5%8F%98%E8%BF%81/","content":"\n\n\n\n\n\n从溥仪看社会变迁讲述时间顺序叙述为主内容溥仪\n家世\n\n生平经历\n\n早年生涯\n第一次皇帝登基和退位\n第二次皇帝登基和退位\n溥仪与庄士敦时期\n被驱逐离开紫禁城时期\n第三次皇帝登基和退位时期\n满洲国康德年代时期\n战犯囚禁时期\n中华人民共和国公民和任职全国政协时期\n文革时期\n去世\n\n\n家庭成员\n\n妻妾\n嗣子\n家系\n\n\n影响\n\n个人自传和相关书籍\n\n影视形象\n\n电影\n纪录片\n电视剧\n\n\n\n\n\n社会的变迁\n辛亥革命\n张勋复辟\n逊清皇室小朝廷\n逊清皇室流亡小朝廷\n满洲国\n日本投降\n新中国成立\n文化大革命\n\n参考文献《我的前半生》知网论文\n溥仪大婚中的民国角色\n浅谈爱新觉罗·溥仪(清朝末代宣统皇帝)图谋“复辟满清”之历程\n从溥仪的元首生涯看伪满政权的傀儡性\n电影《末代皇帝》的视听风格\n溥仪被俘囚禁于苏联远东的日子\n\n维基百科\nhttps://zh.m.wikipedia.org/zh-hans/%E6%BA%A5%E4%BB%AA\n\n网络上关于溥仪的故事","categories":["近代史"]},{"title":"以前后端分离的方式实现表单验证","url":"/2020/07/08/%E4%BB%A5%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/","content":"以前后端分离的方式实现表单验证现在可以公开的情报之前做过登录页面的是使用Spring + ThymeLeaf实现的（可以搜“表单输入验证”找到那篇博客），这次用前后端分离的方式来试试。\n这是我方才想出来的方法，我还没去了解过别人的表单验证怎么实现的。所以，由于自己是闭门造车，也不知道代码水平怎么样。\n技术栈\nSpring Boot\nHTML + CSS + Bootstrap\nJavaScript + Vue + axios\n\n\n\n过程后端业务逻辑后端用Spring Boot实现，核心逻辑是在controller里处理对“&#x2F;login”的get和post请求。\n@Controllerpublic class MyController &#123;\t...&#125;\n\n对于get请求，返回login.html这个页面。\n@GetMapping(&quot;/login&quot;)public String login() &#123;    return &quot;login&quot;;&#125;\n\n对于post请求，检查传过来的username和password是否和数据库里的正确匹配，根据结果返回一个json。匹配成功则返回\n&#123;    &#x27;status&#x27;: &#x27;ok&#x27;&#125;\n\n否则返回\n&#123;    &#x27;status&#x27;: &#x27;no&#x27;&#125;\n\n代码@Controller@CrossOrigin(&quot;*&quot;)public class MyController &#123;        private static final Logger log = LoggerFactory.getLogger(MyController.class);    @GetMapping(&quot;/login&quot;)    public String login() &#123;        return &quot;login&quot;;    &#125;    @PostMapping(&quot;/login&quot;)    public void validate(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        log.info(&quot;侦测到login页面的post请求，我必须回应&quot;);        log.info(&quot;正在从数据库中获取账号密码&quot;);        String username = &quot;overwatch&quot;;        String password = &quot;tracer&quot;;        log.info(&quot;将post内容json转化为java bean&quot;);        ValidateInfo info = getValidateInfo(request);        log.info(&quot;正在初始化回复内容&quot;);        String successfulMessage = &quot;&#123;\\&quot;status\\&quot;: \\&quot;ok\\&quot;&#125;&quot;;        String failedMessage = &quot;&#123;\\&quot;status\\&quot;: \\&quot;no\\&quot;&#125;&quot;;        log.info(&quot;正在回复&quot;);        response.setContentType(&quot;application/json; charset=utf-8&quot;);        PrintWriter printWriter = response.getWriter();        if (info.getUsername().equals(username) &amp;&amp; info.getPassword().equals(password)) &#123;            printWriter.write(successfulMessage);        &#125; else &#123;            printWriter.write(failedMessage);        &#125;        printWriter.flush();        log.info(&quot;回复完毕&quot;);    &#125;        public ValidateInfo getValidateInfo(HttpServletRequest request) throws IOException &#123;        log.info(&quot;正在尝试获取ValidatePost的内容&quot;);        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream(), StandardCharsets.UTF_8));        StringBuilder responseContent = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) &#123;            responseContent.append(line);        &#125;        log.info(&quot;获取完毕，ValidatePost的内容：\\n&#123;&#125;&quot;, responseContent.toString());        log.info(&quot;正在尝试将JSON转化为Java Bean&quot;);        String json = responseContent.toString();        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        return objectMapper.readValue(json, ValidateInfo.class);    &#125;&#125;\n\npublic class ValidateInfo &#123;    private String username;    private String password;    public ValidateInfo() &#123;    &#125;    public ValidateInfo(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    &#125;\n\n注意到这里并没有一个真正的数据库，我们就假装有一个数据库吧。\n注意使用@CrossOrigin(&quot;*&quot;)注解Controller，不然js的post请求发不出去（这儿我有点儿疑惑，按理说不设置也可以正常使用js，但是我用排除变量法发现不行）。\n前端勉强能看的登录页面效果\n\n很简陋的页面，可以使用Bootstrap美化一下。\n代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Log in&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css&quot;          integrity=&quot;sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk&quot; crossorigin=&quot;anonymous&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css&quot;          integrity=&quot;sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+&quot; crossorigin=&quot;anonymous&quot;&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot;            integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js&quot;            integrity=&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js&quot;            integrity=&quot;sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI&quot;            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@latest/lodash.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@latest/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;h1 class=&quot;display-3 text-primary text-center&quot; style=&quot;font-family: Lobster, serif&quot;&gt;LOGIN&lt;/h1&gt;    &lt;form method=&quot;post&quot; v-on:submit.prevent=&quot;submit&quot; id=&quot;form&quot;&gt;        &lt;div class=&quot;form-group&quot;&gt;            &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;            &lt;input v-model=&quot;username&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; placeholder=&quot;User Name&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;form-group&quot;&gt;            &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;            &lt;input v-model=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; placeholder=&quot;Password&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;form-check&quot;&gt;            &lt;label class=&quot;form-check-label&quot;&gt;                &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot;&gt; Remember me            &lt;/label&gt;        &lt;/div&gt;        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n代码中用到了vue，但这个和页面的样式没关系，等下再说。\n业务逻辑使用Vue绑定表单的输入&lt;form method=&quot;post&quot; v-on:submit.prevent=&quot;submit&quot; id=&quot;form&quot;&gt;    &lt;div class=&quot;form-group&quot;&gt;        &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;        &lt;input v-model=&quot;username&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; placeholder=&quot;User Name&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;form-group&quot;&gt;        &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;        &lt;input v-model=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;form-check&quot;&gt;        &lt;label class=&quot;form-check-label&quot;&gt;            &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot;&gt; Remember me        &lt;/label&gt;    &lt;/div&gt;    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;\n\n注意到v-model这种vue特有的代码，他可以绑定一个vue实例的数据。\n&lt;script&gt;    const vm = new Vue(&#123;        el: &#x27;#form&#x27;,        data: &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;        &#125;    &#125;);&lt;/script&gt;\n\n我们用prevent拦截表单的submit请求，并调用我们设置好的函数：\n&lt;script&gt;    const vm = new Vue(&#123;        el: &#x27;#form&#x27;,        data: &#123;            username: &#x27;&#x27;,            password: &#x27;&#x27;        &#125;,        methods: &#123;            submit: function () &#123;                console.log(&quot;准备用ajax向服务器发送post请求&quot;);                axios.post(&#x27;http://localhost:7000/login&#x27;, &#123;                    username: this.username,                    password: this.password                &#125;).then(function (res) &#123;                    const text = res.request.response;                    console.log(text);                    const json = JSON.parse(text);                    if (json.status === &#x27;ok&#x27;) &#123;                        alert(&#x27;登陆成功&#x27;);                    &#125; else &#123;                        alert(&#x27;账号或密码错误，请重新输入&#x27;);                    &#125;                &#125;).catch(function (error) &#123;                    alert(error);                &#125;);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n用axios向服务器发送post请求，请求内容是一个携带username和passwrod的JSON，然后得到响应结果，根据结果的内容进行下一步处理。\n最终效果登陆成功\n\n登录失败\n\n登录成功之后该做些什么完全由前端去控制决定了，整个过程中，服务器和浏览器之间传递的是json数据，而不是html页面（第一次除外）。\n经验表明，如果是很简单的页面，用模板引擎来的更方便一些。\n","categories":["Java"]},{"title":"传输层","url":"/2020/12/12/%E4%BC%A0%E8%BE%93%E5%B1%82/","content":"\n\n\n作用网络层把数据包发送到目的主机，但真正通信的是主机间的进程\n传输层提供了进程间的逻辑通信，向高层屏蔽了底层的核心细节\nUDPUser Datagram Protocol\n特点\n无连接\n尽力而为\nUDP连接可以一对一、一对多、多对一、多对多\n\nHeader格式\nTCPTransmission Control Protocol\n特点\n面向连接\n可靠的\nTCP连接是点对点的\n\nHeader格式\n建立连接\n\n客户端A，服务端B\n\n三次握手\n\nB处于监听状态，监听指定的端口\n\nA向B发送连接请求报文\n\nSYN&#x3D;1，ACK&#x3D;0\n\n\nB收到请求后，如果同意建立连接，则向A发送连接确认报文\n\nSYN&#x3D;1，ACK&#x3D;1\n\n\nA收到B的确认报文后，再向B发送一个确认报文\n\nACK&#x3D;1\n\n\nB收到A的确认后，建立连接\n\n\n\n第三次握手的必要性\n\n\n关闭连接\n\n四次挥手\n\nA向B发送连接释放报文\n\nFIN&#x3D;1，ACK&#x3D;0\n\n\nB收到报文后向A发送确认报文\n\nACK&#x3D;1\n\n\n当B不再需要连接时，向A发送连接释放报文\n\nFIN&#x3D;1\n\n\nA收到后向B发送确认报文，等待2MSL后释放连接\n\nB收到A的确认报文后释放连接\n\n\n\n第四次挥手的必要性\n\n2MSL的必要性\n\n\nTCP可靠传输实现\n超时重传\n如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n\n超时时间RTO\n应该略大于RTT\n\nTCP滑动窗口发送方窗口\n已经发送但未收到确认\n可以发送但未发送的\n\n接受方窗口\n对最后一个按序到达的字节确认\n\nTCP流量控制作用\n使得发送方的发送速率和接收方的接受速率有一个好的匹配\n\n实现\n通过控制确认报文中窗口字段的大小来控制发送方窗口大小，进而控制发送速率\n\nTCP拥塞控制网络拥塞引起超时，超时引起重发，重发加剧了拥塞，正反馈\n作用\n降低网络的拥塞程度\n\n算法\n慢开始+拥塞避免\n\ncwdn从1开始指数增长，超过慢开始门限 ssthresh时线性增长，超时后ssthresh&#x3D;cwnd&#x2F;2，重新慢开始\n\n\n快重传+快恢复\n\n三个同样的ACK说明丢包了，不等超时，直接重传，之后执行快恢复ssthresh&#x3D;cwnd&#x2F;2，cnwd设定为ssthresh，直接进入拥塞避免状态\n\n\n\n","categories":["计网"]},{"title":"以数据为中心的体系结构风格","url":"/2021/03/29/%E4%BB%A5%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC/","content":"\n\n\n\n概念在共享的区域内，进行数据的交换栗子\nwin注册表\n\n存储系统中的硬件和软件的配置信息\n\nApp1.ini\nApp2.ini\nHardware.ini\n\n\n影响软件的行为\n\n资源集中配置管理和调度\n\n\n\n剪贴板\n\n作用\n\n短时间数据存储\n可以在不同的应用之间进行数据传递\n\n\n共享仓库\n\n\n\n\n仓库体系结构风格组成\nrepository\n\n存储和维护数据的场所\n\n\ncomponents operate on the center data store\n\nconnectors\n\ninteractions between repository and components\n\n\n\n交互机制\nDatabase\n\n输入流中的事务类型触发需要执行的过程\n\n\nBlackBoard\n\n由中心数据结构决定要执行的过程\n\n\n\n应用场合\n数据处理\n软件开发环境\n编译器中的符号表和语法树\n\n黑板体系结构风格定义\n中心数据结构当前状态触发并选择需要执行的过程\n\n组成\n黑板\n\n输入&#x2F;解空间\n求解状态\n\n\n知识源\n\n作用\n\n策略知识\n求解知识\n\n\n条件-动作：被触发后执行相应的动作，修改黑板的数据\n\n\n\n控制器\n\n监视黑板状态\n激活知识源\n\n\n\n典型应用\nHearsay\n\n","categories":["软件体系结构"]},{"title":"使用RSA加密http请求中的数据","url":"/2020/12/13/%E4%BD%BF%E7%94%A8RSA%E5%8A%A0%E5%AF%86http%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/","content":"概念Http协议报文明文传输，如果被恶意分子抓包，未经加密的数据便一览无余。\n为了数据的安全传输，可以采用对称加密和非对称加密算法保驾护航。\n\n\n过程以客户端到服务器为例。\n在客户端向服务器发送数据之前，服务器将自己通过RSA算法产生的公钥交给客户端。在发送数据时，客户端用得到的公钥加密要传输的数据，加密完成后传输密文给服务器，服务器收到数据后首先使用之前产生的私钥进行解密，解密成功后得到数据。\n这个过程服务器的私钥从未传输，所以恶意分子无法通过窃听获得原始的数据。\n具体实现以Spring + Thyme Leaf + Vue.js + axios为例。\n产生秘钥@Component@Scope(&quot;singleton&quot;)public class CipherUtil &#123;    private final PublicKey publicKey;    private final Cipher decryptCipher;    public CipherUtil() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException &#123;        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.generateKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        this.publicKey = keyPair.getPublic();        this.decryptCipher = Cipher.getInstance(&quot;RSA&quot;);        decryptCipher.init(Cipher.DECRYPT_MODE, privateKey);    &#125;    public String getPublicKey() &#123;        return Base64.getEncoder().encodeToString(publicKey.getEncoded());    &#125;    public String decrypt(String content) throws BadPaddingException, IllegalBlockSizeException &#123;        return new String(decryptCipher.doFinal(Base64.getDecoder().decode(content)));    &#125;&#125;\n\n将服务器端产生的秘钥交给客户端Controller@GetMapping(&quot;/&quot;)public String home(Model model) &#123;    model.addAttribute(&quot;publicKey&quot;, cipherUtil.getPublicKey());    return &quot;home&quot;;&#125;\n\nHTML&lt;script th:inline=&quot;javascript&quot;&gt;    const publicKey = [[$&#123;publicKey&#125;]];&lt;/script&gt;\n\n客户端使用公钥加密拦截表单提交&lt;form method=&quot;post&quot; name=&quot;form&quot; action=&quot;/submit&quot; v-on:submit.prevent=&quot;upload&quot;&gt;\t.............&lt;form&gt;\n\n对数据加密后提交表单new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;        xx: &#x27;&#x27;,        yy: &#x27;&#x27;    &#125;,    methods: &#123;        upload() &#123;            const encryptor = new JSEncrypt();            encryptor.setPublicKey(publicKey);            const formData = new FormData();            formData.append(&quot;xx&quot;, encryptor.encrypt(this.xx));            formData.append(&quot;yy&quot;, encryptor.encrypt(this.yy));            formData.append(&quot;zz&quot;, this.action);                        axios(&#123;                method: &quot;post&quot;,                url: &quot;/submit&quot;,                headers: &#123;                    &quot;Content-Type&quot;: &quot;multipart/form-data&quot;                &#125;,                data: formData            &#125;).then((res) =&gt; &#123;                console.log(res);            &#125;);        &#125;    &#125;&#125;);\n\n服务端收到数据后解密@PostMapping(&quot;/submit&quot;)@ResponseBodypublic String submit(@RequestParam(&quot;action&quot;) String value, @RequestParam(&quot;id&quot;) String id, @RequestParam(&quot;password&quot;) String password) &#123;    id = cipherUtil.decrypt(id);    password = cipherUtil.decrypt(password);    /////////////////// operations here /////////////////////////    return &quot;hhh&quot;;&#125;","categories":["Experience"]},{"title":"八皇后","url":"/2021/06/20/%E5%85%AB%E7%9A%87%E5%90%8E/","content":"八皇后问题八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n &#x3D; 1或n ≥ 4时问题有解。\n\n\n使用回溯法求解八皇后问题可以用一个向量x(x1, x2, x3, x4...xn)表示n个皇后的位置：xi表示第i个皇后在第i行的位置。\nState Space Tree\n\n代码package mainimport &quot;fmt&quot;func main() &#123;\tfourQueen := solveNQueens(4)\tfor _, v := range fourQueen &#123;\t\tfor _, vv := range v &#123;\t\t\tfmt.Println(vv)\t\t&#125;\t\tfmt.Println(&quot;------------------------&quot;)\t&#125;\teightQueen := solveNQueens(8)\tfor _, v := range eightQueen &#123;\t\tfor _, vv := range v &#123;\t\t\tfmt.Println(vv)\t\t&#125;\t\tfmt.Println(&quot;------------------------&quot;)\t&#125;&#125;func solveNQueens(n int) (ans [][]string) &#123;\tvar backtrack func([]int)\tbacktrack = func(vector []int) &#123;\t\t// 递归终止条件\t\tif isConflict(vector) &#123;\t\t\treturn\t\t&#125; else if len(vector) == n &#123;\t\t\tans = append(ans, output(vector))\t\t\treturn\t\t&#125;\t\tfor i := 0; i &lt; n; i++ &#123;\t\t\tnewVector := make([]int, len(vector))\t\t\tcopy(newVector, vector)\t\t\tnewVector = append(newVector, i)\t\t\tbacktrack(newVector)\t\t&#125;\t&#125;\t// vector[i]表示第i个皇后在第i行的位置\tvar vector []int\tbacktrack(vector)\treturn&#125;// 所有的皇后是否有冲突func isConflict(vector []int) bool &#123;\t// 只需判断新添加的（最后一个）皇后和已有的皇后是否有冲突\tfor i := 0; i &lt; len(vector)-1; i++ &#123;\t\tif _isConflict(i, vector[i], len(vector)-1, vector[len(vector)-1]) &#123;\t\t\treturn true\t\t&#125;\t&#125;\treturn false&#125;// (x1, y1) 和 (x2, y2) 两个皇后是否有冲突func _isConflict(x1, y1, x2, y2 int) bool &#123;\t// 在一条直线上\tif x1 == x2 || y1 == y2 &#123;\t\treturn true\t&#125;\t// 在一条对角线上\tif abs(y1-y2) == abs(x1-x2) &#123;\t\treturn true\t&#125;\treturn false&#125;// 输出结果：Q代表皇后func output(vector []int) (ans []string) &#123;\tdots := make([]byte, len(vector))\tfor i := range dots &#123;\t\tdots[i] = &#x27;.&#x27;\t&#125;\tfor i := 0; i &lt; len(vector); i++ &#123;\t\tpos := make([]byte, len(vector))\t\tcopy(pos, dots)\t\tpos[vector[i]] = &#x27;Q&#x27;\t\tans = append(ans, string(pos))\t&#125;\treturn&#125;// absolutefunc abs(x int) int &#123;\tif x &lt; 0 &#123;\t\treturn -x\t&#125;\treturn x&#125;\n\n如果不使用闭包，也可以用全局变量，并且回溯函数需要更多的参数。\n","categories":["数据结构与算法"],"tags":["backtrack","回溯","数据结构与算法"]},{"title":"关于Tomcat的一个坑","url":"/2020/05/13/%E5%85%B3%E4%BA%8ETomcat%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/","content":"之前我的spring项目都是直接在Intellij Idea里跑的，今天想把我的程序部署在服务器上，于是就尝试把项目打成War包，放在Tomcat的Webapps底下，然后启动Tomcat服务器运行，运行结果和我在Idea里的结果完全不同，Idea运行是正常的，Tomcat运行时报错，说找不到数据库的驱动。\n\n\n nested exception is java.lang.RuntimeException: Failed to get driver instance for jdbcUrl=jdbc:mysql://localhost:3306/overwatch?serverTimezone=UTC\n\n\n报错内容大概就是：Failed to get driver instance for。。。。。。巴拉巴拉。经过我百般尝试，我把Mysql驱动手动复制一份放在了Tomcat的lib目录下，终于正常运行了。\n\n\n\n\n\n在linux环境下，也需要做同样的操作：把mysql驱动放在tomcat的lib里。\nBy The Way，IntelliJ Idea 可以把talble生成SQL脚本，也可以把Table中的数据生成SQL脚本，给数据库搬家，从windows到linux只需要两个脚本就可以办到，不得不说Idea牛逼。\n成功了！hooray\n","categories":["Spring"]},{"title":"关于超星平台视频失去焦点后的自动暂停","url":"/2021/11/05/%E5%85%B3%E4%BA%8E%E8%B6%85%E6%98%9F%E5%B9%B3%E5%8F%B0%E8%A7%86%E9%A2%91%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E5%90%8E%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9A%82%E5%81%9C/","content":"学校在“学在西电（超星平台）”新开设了一门网课，要求学习时长不小于16学时（720分钟），打开视频播放页面后，正当我切屏去做其他事时，视频竟自动暂停播放，这还怎么愉快地刷网课？\n\n\n\n\n根据我浅薄的JavaScript知识来猜测，应该存在一段代码将**“鼠标移动或者切换窗口”**作为浏览器中某个部分的监听事件，当检测到这样的事件发生时对应的函数就被调用，视频被暂停。\n仔细观察，鼠标移开视频区域并不会导致视频的暂停，而只有当鼠标指针移开页面时才会发生，因此很可能是body这个部分设置的EventListener（监听函数）。\n使用ctrl+shift+C选中整个页面（body）：\n\n\n在右下角找到body的EventListener：mouseout，点击remove就大功告成了。\n","categories":["Experience"],"tags":["超星,JavaScript,EventListener"]},{"title":"关系数据库设计理论","url":"/2020/12/12/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/","content":"\n\n\n关系数据库设计理论函数依赖\n部分函数依赖\n完全函数依赖\n传递函数依赖\n\n异常冗余数据\n数据重复出现\n\n修改数据\n需要修改多个相同的数据\n\n删除异常\n删除一个信息会丢掉其他信息\n\n插入异常\n因为依赖关系，无法插入\n\n范式作用\n解决异常\n\n分类\n第一范式\n\n属性不可分\n\n\n第二范式\n\n每个非主属性完全函数依赖于键码\n\n\n第三范式\n\n非主属性 不 传递函数依赖于键码\n\n\n\n","categories":["数据库"]},{"title":"再看java注解","url":"/2020/10/19/%E5%86%8D%E7%9C%8Bjava%E6%B3%A8%E8%A7%A3/","content":"最初学习注解的时候，很多地方没弄明白，在对java本身和一些框架有了一些更深的认识之后，回过头再巩固一下。\n定义注解可以在编译、运行期间为编译器、JVM提供一些信息，目的是让程序借助这些信息完成一些特定功能\n\n\n分类编译过程使用\n编译结束后丢弃\n\n栗子\n\n@Override\n@SuppressWarnings\n@Deprecated\n@AllArgsConstructor\n\n\n\n其它工具使用\n保存在class文件中\n\n栗子\n\n？？？\n\n\n\n运行期间使用\n存在于JVM中\n\n栗子\n\n@PostMapping\n@GetMapping\n@Component\n\n\n\n自定义注解元注解\n@Target\n\nTYPE\nFIELD\nMETHOD\nPARAMETER\n\n\n@Retention\n\nSOURCE\nCLASS\nRUNTIME\n\n\n…\n\n\n使用注解仅仅是提供一些信息，如何利用这些信息需要程序员来决定。具体过程大概是先判断注解是否存在，然后读取注解提供的内容信息，再添加相应的逻辑。\n判断某个注解是否存在\nClass.isAnnotationPresent(Class)\nField.isAnnotationPresent(Class)\nMethod.isAnnotationPresent(Class)\nConstructor.isAnnotationPresent(Class)\n\n使用反射API读取Annotation\nClass.getAnnotation(Class)\nField.getAnnotation(Class)\nMethod.getAnnotation(Class)\nConstructor.getAnnotation(Class)\n\n思维导图"},{"title":"分布式事务","url":"/2021/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","content":"\n\n\n\n分布式事务概念\n分布式环境下，一个事务的多个操作位于不同的物理机&#x2F;虚拟机上\n分布式环境下如何保证事务的ACID特性\n\n锁 VS 事务\n分布式锁关心进程间的互斥关系（隔离性）\n\n分布式事务关心ACID四个特性\n\n\n实现方法2PC2 phase commit\n\n组成\n\n协调者（coordinator）\n参与者 × N\n\n\n过程\n\ncoordinator询问所有参与者，事务执行（是否成功\n\n一票否决\n\n所有参与者提交\n所有参与者回滚\n\n\n\n\n缺点\n\n同步\n\n等待coordinator消息过程中阻塞\n\n\n单点故障\n\n数据不一致\n\n网络问题导致只有部分参与者收到commit消息\n\n\n一票否决，不“乐观”\n\n\n\n\n本地消息表\n组成\n\n本地\n\n业务数据表\n消息表\n\n\n消息队列\n\n\n\n过程\n\n一个本地事务\n\n写业务数据表\n写本地消息表\n\n\n一方将本地消息表中的消息移到消息队列\n\n一方从消息队列中读取消息进行下一步操作\n\n\n\n\n","categories":["分布式"]},{"title":"函数绘图语言之解释器","url":"/2020/11/24/%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8/","content":"函数绘图语言\n\n\nGithub：carpediemtal&#x2F;Drawlang-Interpreter (github.com)\n概述5 种语句\n循环绘图（FOR-DRAW）\n\n比例设置（SCALE）\n\n角度旋转（ROT）\n\n坐标平移（ORIGIN）\n\n注释    （– 或 &#x2F;&#x2F;）\n\n\n坐标系\n左上角为原点\n\nx方向从左向右增长\n\ny方向从上到下增长\n\n\n栗子--------------- 函数f(t)=t的图形origin is (100, 300);\t-- 设置原点的偏移量rot is 0;\t\t\t-- 设置旋转角度(不旋转)scale is (1, 1);\t\t-- 设置横坐标和纵坐标的比例for T from 0 to 200 step 1 draw (t, 0);\t\t\t\t-- 横坐标的轨迹（纵坐标为0）for T from 0 to 150 step 1 draw (0, -t);\t\t\t\t-- 纵坐标的轨迹（横坐标为0）for T from 0 to 120 step 1 draw (t, -t);\t\t\t\t-- 函数f(t)=t的轨迹 \n\norigin is (100, 300);rot is 0;scale is (1, 2);for T from 0 to 100 step 1 draw (100 * cos(T), 100*sin(T));scale is (2, 1);for T from 0 to 2*PI step PI/50 draw (20 * cos(T), -20 * sin(T));for T from 0 to 300 step 1 draw (T, -T);for T from 0 to 500 step 5 draw (-T, -2 * T);// 三个椭圆origin is (380,340);scale is (100,100/3);rot is pi/2;for T from -pi to pi step pi/50 draw (cos(t),sin(t));rot is pi/2 + 2*pi/3;for T from -pi to pi step pi/50 draw (cos(t),sin(t));rot is pi/2 - 2*pi/3;for T from -pi to pi step pi/50 draw (cos(t),sin(t));// 新的图形:万花筒origin is (250,250);scale is (100,100);rot is 0;for t from 0 to 2*pi step pi/50 draw (cos(t), sin(t));for t from 0 to pi*20 step Pi/50 draw ((1-1/(10/7))*cos(T)+1/(10/7)*cos(-T*(((10/7)-1))), (1-1/(10/7))*sin(T)+1/(10/7)*sin(-T*((10/7)-1)));\n\n为函数绘图语言构造‘解释器’\n词法分析器记号的种类public enum TokenType &#123;    /**     * 保留关键字     */    ORIGIN, SCALE, ROT, IS, TO, STEP, DRAW, FOR, FROM,    /**     * 参数和标点符号     */    T, SEMICOLON, L_BRACKET, R_BRACKET, COMMA,    /**     * 运算符号     */    PLUS, MINUS, MUL, DIV, POWER,    /**     * 函数     */    FUNC,    /**     * 常数     */    CONST_VAL,    /**     * 文件末尾和错误     */    END, ERROR;&#125;\n\n\n常数\n数值字面量和标识符形式的常量名均称为常数。\n\n字面量的形式为普通的数值，如果没有小数部分，可以省略小数点。例如2、2.、2.0都是合法的常数。\n\n标识符PI、E也是常数，它们分别代表圆周率和自然对数的底。常数不能有符号位，如-1和+2不是常数而是（一元运算的）表达式。\n\n\n\n参数\n本绘图语言中唯一的、已经被定义好的变量名T被称为参数，它也是一个表达式。由于绘图语言中只有这唯一的变量，因此绘图语言中无需变量或参数的声明和定义语句。\n\n函数\n为简单起见，当前函数调用仅支持Sin、Cos、Tan、Sqrt、Exp 和 Ln。\n\n保留字\n语句中具有固定含义的标识符，包括：\n\nORIGIN, SCALE, ROT,  IS,\n\nFOR,  FROM,  TO,  STEP,  DRAW\n\n\n\n运算符\n\n+           -             *             &#x2F;           **\n\n结合性： ** 右结合， 其他 左结合\n\n优先级：** ＞ 一元+- ＞ *&#x2F; ＞ 二元+-\n\n\n\n分隔符\n；  （     ）   ，\n\n\n建立hash表将字符串和Token相对应\nprivate void initTable() &#123;    tokenTable.put(&quot;PI&quot;, new Token(TokenType.CONST_VAL, &quot;PI&quot;, 3.1415926));    tokenTable.put(&quot;E&quot;, new Token(TokenType.CONST_VAL, &quot;E&quot;, 2.71828));    tokenTable.put(&quot;T&quot;, new Token(TokenType.T, &quot;T&quot;, 0));    tokenTable.put(&quot;SIN&quot;, new Token(TokenType.FUNC, &quot;SIN&quot;, 0));    tokenTable.put(&quot;COS&quot;, new Token(TokenType.FUNC, &quot;COS&quot;, 0));    tokenTable.put(&quot;TAN&quot;, new Token(TokenType.FUNC, &quot;TAN&quot;, 0));    tokenTable.put(&quot;LN&quot;, new Token(TokenType.FUNC, &quot;LN&quot;, 0));    tokenTable.put(&quot;EXP&quot;, new Token(TokenType.FUNC, &quot;EXP&quot;, 0));    tokenTable.put(&quot;SQRT&quot;, new Token(TokenType.FUNC, &quot;SQRT&quot;, 0));    tokenTable.put(&quot;ORIGIN&quot;, new Token(TokenType.ORIGIN, &quot;ORIGIN&quot;, 0));    tokenTable.put(&quot;SCALE&quot;, new Token(TokenType.SCALE, &quot;SCALE&quot;, 0));    tokenTable.put(&quot;ROT&quot;, new Token(TokenType.ROT, &quot;ROT&quot;, 0));    tokenTable.put(&quot;IS&quot;, new Token(TokenType.IS, &quot;IS&quot;, 0));    tokenTable.put(&quot;FOR&quot;, new Token(TokenType.FOR, &quot;FOR&quot;, 0));    tokenTable.put(&quot;FROM&quot;, new Token(TokenType.FROM, &quot;FROM&quot;, 0));    tokenTable.put(&quot;TO&quot;, new Token(TokenType.TO, &quot;TO&quot;, 0));    tokenTable.put(&quot;STEP&quot;, new Token(TokenType.STEP, &quot;STEP&quot;, 0));    tokenTable.put(&quot;DRAW&quot;, new Token(TokenType.DRAW, &quot;DRAW&quot;, 0));&#125;\n\n识别出的函数会在后面的语法分析器进一步细分：\n/** * 计算带有函数的表达式的值 * * @param funcName 函数名 * @param val      函数 * @return 函数值 */private double function(String funcName, double val) &#123;    switch (funcName) &#123;        case &quot;COS&quot; -&gt; &#123;            return Math.cos(val);        &#125;        case &quot;SIN&quot; -&gt; &#123;            return Math.sin(val);        &#125;        case &quot;TAN&quot; -&gt; &#123;            return Math.tan(val);        &#125;        case &quot;SQRT&quot; -&gt; &#123;            return Math.sqrt(val);        &#125;        case &quot;EXP&quot; -&gt; &#123;            return Math.exp(val);        &#125;        case &quot;LN&quot; -&gt; &#123;            return Math.log(val);        &#125;        default -&gt; throw new RuntimeException(&quot;Syntax Error&quot;);    &#125;&#125;\n\nDFA\n核心代码/**        * 每次调用获得一个Token *         * @return 返回下一个Token */public Token getToken() &#123;    // 跳过最初的空白字符    jumpSpace();    // 读到了源代码末尾    if (index &gt;= src.length()) &#123;        return new Token(TokenType.END, &quot;END&quot;, 0);    &#125;    // 存储Token字符    StringBuilder tokenString = new StringBuilder();    // 第一个非空字符    char ch = getChar();    tokenString.append(ch);    // 识别保留字、常量名和参数名:纯字母    if (Character.isAlphabetic(ch)) &#123;        while (true) &#123;            ch = getChar();            if (Character.isAlphabetic(ch)) &#123;                tokenString.append(ch);            &#125; else &#123;                break;            &#125;        &#125;        index--;        return lookUpTable(tokenString.toString());    &#125; else if (Character.isDigit(ch)) &#123; // 识别数字常量        while (true) &#123;            ch = getChar();            if (Character.isDigit(ch)) &#123;                tokenString.append(ch);            &#125; else &#123;                break;            &#125;        &#125;        if (ch == &#x27;.&#x27;) &#123;            tokenString.append(ch);            while (true) &#123;                ch = getChar();                if (Character.isDigit(ch)) &#123;                    tokenString.append(ch);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;        index--;        return new Token(TokenType.CONST_VAL, tokenString.toString(), Double.parseDouble(tokenString.toString()));    &#125; else &#123;        // 识别运算符或者分隔符，跳过注释        switch (ch) &#123;            case &#x27;;&#x27; -&gt; &#123;                return new Token(TokenType.SEMICOLON, &quot;;&quot;, 0);            &#125;            case &#x27;(&#x27; -&gt; &#123;                return new Token(TokenType.L_BRACKET, &quot;(&quot;, 0);            &#125;            case &#x27;)&#x27; -&gt; &#123;                return new Token(TokenType.R_BRACKET, &quot;)&quot;, 0);            &#125;            case &#x27;,&#x27; -&gt; &#123;                return new Token(TokenType.COMMA, &quot;,&quot;, 0);            &#125;            case &#x27;+&#x27; -&gt; &#123;                return new Token(TokenType.PLUS, &quot;+&quot;, 0);            &#125;            // comment or minus            case &#x27;-&#x27; -&gt; &#123;                ch = getChar();                // 跳过注释                if (ch == &#x27;-&#x27;) &#123;                    while (ch != &#x27;\\n&#x27; &amp;&amp; ch != &#x27;!&#x27;) &#123;                        ch = getChar();                    &#125;                    index--;                    return getToken();                &#125; else &#123;                    index--;                    return new Token(TokenType.MINUS, &quot;-&quot;, 0);                &#125;            &#125;            case &#x27;*&#x27; -&gt; &#123;                ch = getChar();                if (ch == &#x27;*&#x27;) &#123;                    return new Token(TokenType.POWER, &quot;**&quot;, 0);                &#125; else &#123;                    index--;                    return new Token(TokenType.MUL, &quot;*&quot;, 0);                &#125;            &#125;            // comment or div            case &#x27;/&#x27; -&gt; &#123;                ch = getChar();                if (ch == &#x27;/&#x27;) &#123;                    while (ch != &#x27;\\n&#x27; &amp;&amp; ch != &#x27;!&#x27;) &#123;                        ch = getChar();                    &#125;                    index--;                    return getToken();                &#125; else &#123;                    index--;                    return new Token(TokenType.DIV, &quot;/&quot;, 0);                &#125;            &#125;            // 不能识别的字符返回ERROR类型的Token            default -&gt; &#123;                return new Token(TokenType.ERROR, &quot;ERROR&quot;, 0);            &#125;        &#125;    &#125;&#125;\n\n语法分析器流程\n语法分析器Parser内部持有一个词法分析器Lexer实例，通过该实例的getToken获得Token，再进一步分析。\npublic void parse() &#123;    fetchToken();    program();&#125;\n\n文法经过各种处理之后的最终文法规则\n\n表达式的语法树函数绘图语言比较简单，只有表达式需要建立语法树进一步求值。\npackage eternal.fire.syntax;import eternal.fire.token.TokenType;/** * 当节点有两个孩子的时候，使用left和right * 当节点只有一个孩子的时候，使用child */public class ExprNode &#123;    private TokenType tokenType;    private ExprNode left;    private ExprNode right;    private ExprNode child;    // 针对CONST_VAL    private double val;    // 针对FUNC    private String funcName;    // 针对FUNC类型的节点    public ExprNode(TokenType tokenType, String funcName) &#123;        this.tokenType = tokenType;        this.funcName = funcName;    &#125;    // CONST_VAL类型的节点    public ExprNode(TokenType tokenType, double val) &#123;        this.tokenType = tokenType;        this.val = val;    &#125;    // 针对二元运算类型的节点（已经构造好了左子树和右子树）    public ExprNode(TokenType tokenType, ExprNode left, ExprNode right) &#123;        this.tokenType = tokenType;        this.left = left;        this.right = right;    &#125;    public ExprNode() &#123;    &#125;        // ......只截取了一部分&#125;\n\n构造语法树的片段节选/** * 匹配一个表达式expression，为表达式expression构造语法树ExprNode * * @return 构造出的语法树 */private ExprNode expression() &#123;    var left = term();    while (token.getTokenType() == TokenType.PLUS || token.getTokenType() == TokenType.MINUS) &#123;        var tmp = token.getTokenType();        matchToken(token.getTokenType());        var right = term();        // 不断更新左节点        left = new ExprNode(tmp, left, right);    &#125;    return left;&#125;\n\n\n\nTo be continued…\n绘图：JavaFX核心思路利用JavaFx的canvas可以轻松在窗口面板上绘制一个点。\nCanvas canvas = new Canvas(500, 500);var context = canvas.getGraphicsContext2D();context.setFill(Color.GREEN);context.fillOval(x, y, dotSize, dotSize);\n\n当语法分析器获得绘图语句的结果后，使用循环语句在面板上画上若干个点，于是一切都结束了。\n前端界面设计画板大小：500px*500px\n使用JFoenix和css样式对部分组件稍加美化\n\n布局\n窗口图标\nprimaryStage.getIcons().add(new Image(Draw.class.getResourceAsStream(&quot;/draw.png&quot;)));\n\n补充的功能\n改变画笔颜色添加一个拾色器组件，当拾色器组件的值发生变化，就以新的值为画笔颜色，清空画板，重新渲染。\n// 拾色器ColorPicker colorPicker = new ColorPicker(Color.GREEN);colorPicker.setOnAction(event -&gt; &#123;    logger.info(&quot;画笔颜色改变为&#123;&#125;&quot;, colorPicker.getValue());    context.clearRect(0, 0, 500, 500);    context.setFill(colorPicker.getValue());    parser.getLexer().reload();    parser.parse();&#125;);\n\n改变画笔宽度和上面的思路类似。\n// 滑动按钮JFXSlider slider = new JFXSlider(0, 10, 0.5);slider.setValue(5);slider.valueProperty().addListener((observable, oldValue, newValue) -&gt; &#123;    logger.info(&quot;画笔宽度改变为&#123;&#125;&quot;, newValue.doubleValue());    context.clearRect(0, 0, 500, 500);    parser.setDotSize(newValue.doubleValue());    parser.getLexer().reload();    parser.parse();&#125;);\n\nHelp按钮跳转到我的博客。\n// HelpJFXButton helpBtn = new JFXButton(&quot;Help&quot;);helpBtn.setMaxWidth(90);helpBtn.getStyleClass().add(&quot;button-raised&quot;);helpBtn.setStyle(&quot;-fx-background-color: #0F9D58&quot;);/*var helpIcon = new ImageView(new Image(Draw.class.getResourceAsStream(&quot;/help.png&quot;)));helpIcon.setFitWidth(25);helpIcon.setFitHeight(25);helpBtn.setGraphic(helpIcon);*/helpBtn.setOnAction(event -&gt; &#123;    try &#123;        Desktop.getDesktop().browse(new URI(BLOG_URL));    &#125; catch (IOException | URISyntaxException e) &#123;        e.printStackTrace();    &#125;&#125;);\n\nhelp的图标看上去好丑，我注释掉了。\nGithub按钮跳转到我的github仓库。\n// GithubJFXButton githubBtn = new JFXButton(&quot;Github&quot;);githubBtn.setMaxWidth(90);githubBtn.getStyleClass().add(&quot;button-raised&quot;);// 为按钮添加图标var githubIcon = new ImageView(new Image(Draw.class.getResourceAsStream(&quot;/github.png&quot;)));githubIcon.setFitWidth(20);githubIcon.setFitHeight(20);githubBtn.setGraphic(githubIcon);githubBtn.setOnAction(event -&gt; &#123;    try &#123;        Desktop.getDesktop().browse(new URI(GITHUB_URL));    &#125; catch (IOException | URISyntaxException e) &#123;        e.printStackTrace();    &#125;&#125;);\n\n日志使用SLF4J和Logback\n依赖项：\ndependencies &#123;// https://mvnrepository.com/artifact/org.slf4j/slf4j-api    compile group: &#x27;org.slf4j&#x27;, name: &#x27;slf4j-api&#x27;, version: &#x27;1.7.30&#x27;// https://mvnrepository.com/artifact/ch.qos.logback/logback-classic    compile group: &#x27;ch.qos.logback&#x27;, name: &#x27;logback-classic&#x27;, version: &#x27;1.2.3&#x27;// https://mvnrepository.com/artifact/ch.qos.logback/logback-core    compile group: &#x27;ch.qos.logback&#x27;, name: &#x27;logback-core&#x27;, version: &#x27;1.2.3&#x27;&#125;\n\n构建使用Gradle管理依赖项\nplugins &#123;    id &#x27;application&#x27;    id &#x27;org.openjfx.javafxplugin&#x27; version &#x27;0.0.8&#x27;&#125;group &#x27;eternal.fire&#x27;version &#x27;1.0-SNAPSHOT&#x27;repositories &#123;    maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;    maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27; &#125;&#125;dependencies &#123;// https://mvnrepository.com/artifact/org.slf4j/slf4j-api    compile group: &#x27;org.slf4j&#x27;, name: &#x27;slf4j-api&#x27;, version: &#x27;1.7.30&#x27;// https://mvnrepository.com/artifact/ch.qos.logback/logback-classic    compile group: &#x27;ch.qos.logback&#x27;, name: &#x27;logback-classic&#x27;, version: &#x27;1.2.3&#x27;// https://mvnrepository.com/artifact/ch.qos.logback/logback-core    compile group: &#x27;ch.qos.logback&#x27;, name: &#x27;logback-core&#x27;, version: &#x27;1.2.3&#x27;    compile &#x27;com.jfoenix:jfoenix:9.0.10&#x27;&#125;javafx &#123;    version = &quot;13&quot;    modules = [&#x27;javafx.controls&#x27;, &#x27;javafx.fxml&#x27;]&#125;application &#123;    mainClass = &#x27;eternal.fire.Draw&#x27;//    mainClass = &#x27;eternal.fire.Parser&#x27;&#125;tasks.withType(JavaCompile) &#123;    options.encoding = &#x27;UTF-8&#x27;&#125;\n\n运行gradlew run\n","categories":["编译原理"]},{"title":"分布式锁","url":"/2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","content":"\n\n\n\n\n\n单机情况线程间同步\n多线程\n\n进程间同步\nIPC\n\n实现互斥量\n整型0-1\n某个数据的存在与否\n\n数据库唯一索引\n上锁\n\n向表中插入记录\n\n\n解锁\n\n删除表中的记录\n\n\n特点\n\n无失效时间\n\n定时任务清理表数据\n\n\n非阻塞\n\n轮询\n\n\n不可重入\n\n数据库记录主机和进程的信息，获取锁之前先查表\n\n\n\n\n\nREDIS SETNX\nSETNX\n\nset if not exist\n\n返回值\n\n成功时返回true\n失败时返回false\n\n\n\n\nEXPIRE\n\n为某个键值对设置过期时间\n\n\n\nREDIS REDLOCK\n保证单点故障时分布式锁仍可用\n\n规则\n\n尝试从所有Redis实例（n个）获取锁，获得n&#x2F;2+1个锁后才算上锁成功\n上锁失败时要释放上锁过程中获得的锁\n\n\n\nZookeeper\n模型\n\n树\n\n节点\n\n永久\n\n临时\n\n会话结束或超时节点会被删除\n\n\n有序\n\n根据插入顺序形成数字后缀\n\n\n\n\n\n\n监听器\n\n节点状态变更时通知监听者\n\n\n分布式锁实现\n\n上锁\n\n创建临时且有序的节点\n如果当前节点不是序号最小的就监听前一个节点并阻塞\n\n\n解锁\n\n删除对应的节点\n临时节点超时会被删掉\n\n\n\n\n\n","categories":["分布式"]},{"title":"创建一个RESTful的web服务","url":"/2020/06/04/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AARESTful%E7%9A%84web%E6%9C%8D%E5%8A%A1/","content":"Building a RESTful Web Service最终的效果你会创建一个能处理http://localhost:8080/greeting的get请求的web服务，它会回复一个如图所示的json。\n\n\n\n\n你还可以加入一个自定义的name参数，回复将会如图所示：\n\n\n注意到id每次访问都会递增。\n\n\n你需要的\n大概10分钟时间\n一个你喜欢的编辑器或者java IDE\nJDK1.8以上\nMaven 3.2以上\n\n如何完成这个简单的项目用Spring Initializr创建一个项目\n\n注意：需要Spring Web依赖\npom&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;xyz.eternal.fire&lt;/groupId&gt;    &lt;artifactId&gt;demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;14&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n创建一个Greeting类package xyz.eternal.fire.demo;public class Greeting &#123;    private final long id;    private final String content;    public Greeting(long id, String content) &#123;        this.id = id;        this.content = content;    &#125;    public long getId() &#123;        return id;    &#125;    public String getContent() &#123;        return content;    &#125;&#125;\n\nSpringWeb内置了Jackson JSON，这个Greeting类最终会被自动转化成JSON。\n创建一个Resource Controller在Spring里，HTTP请求会被标记有Controller的类处理。\npackage xyz.eternal.fire.demo;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicLong;@RestControllerpublic class GreetingController &#123;    private static final String template = &quot;Hello, %s!&quot;;    private final AtomicLong counter = new AtomicLong();    @GetMapping(&quot;/greeting&quot;)    public Greeting greeting(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) String name) &#123;        return new Greeting(counter.incrementAndGet(), String.format(template, name));    &#125;&#125;\n\n@GetMapping注解保证了对&#x2F;greeting的get请求会被greeting方法处理。\n@RequestParam注解可以把url里的name参数注入到方法参数String name里，如果没找到这个参数，将使用默认的“world”。\ngreeting方法内部返回了一个Greeting类的对象，这个对象将会被自动转成JSON。\n说明传统MVC controller和RESTful web service controller的区别区别主要体现在HTTP RESPONSE的建立上。传统的MVC controller要利用模板引擎把数据渲染成HTML，然而RESTful web service controller直接返回一个Greeting对象，这个对象将会被转换成JSON然后直接写到Response里。\n@RestController注解相当于@Controller+@ResponseBody\n自动生成的Application类@SpringBootApplicationpublic class RESTfulApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(RESTfulApplication.class, args);    &#125;&#125;\n\nmain方法里只有一行，没啥好说的。\n@SpringBootApplication注解相当于@Configuration+@EnableAutoConfiguration+@ComponentScan\n@Configuration说明这是一个配置类，里面可能有很多Bean。\n@EnableAutoConfiguration告诉Spring Boot自动添加位于classpath下的Bean，设置。\n@ComponentScan告诉Spring 去寻找当前package下的Components。\n运行可以使用maven命令：java -jar target&#x2F;gs-rest-service-0.1.0.jar生成jar包运行。\n可以在IDE里直接运行。\n","categories":["Spring"]},{"title":"创建型模式","url":"/2020/05/12/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","content":"创建型模式\nFactory MethodAbstract FactoryBuilderPrototypeSingleton","categories":["Design Patterns"]},{"title":"初等变换的应用","url":"/2019/08/25/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8/","content":"\n\n\n\n初等变换的应用行阶梯形矩阵求矩阵的秩\n原理\n\n初等变换不改变矩阵的秩\n\n\n操作\n\n行变换将矩阵化为行阶梯形\n非零行即为矩阵的秩\n\n\n\n确定向量组的线性相关性\n以所有向量为列向量构成矩阵\n列满秩则线性无关\n列不满秩则线性相关\n\n求向量组的秩极大线性无关组所含向量个数为向量组的秩\n\n作出对应的矩阵\n\n化为行阶梯型\n\n非零行的每一行的首非零元素所在列的向量构成极大线性无关组\n极大先行无关组并不唯一取每一行第一个首非零元素所在列的向量构成的极大先行无关组可能是若干个极大先行无关组的一个秩即为极大先行无关组中向量的个数\n\n得到极大先行无关组和向量组的秩\n\n\n判断两个向量组是否等价\n向量组A&amp;向量组B组成矩阵C（A，B）\n将C化为行阶梯型\n若r（A）&#x3D;r（B）&#x3D;r（A，B）则A和B等价\n\n行最简形矩阵确定向量是否能由向量组线性表出\n以向量组和所给向量组成矩阵\n\n观察看能不能线性表出\n\n能\n\n解一手非齐次线性方程组\n\n\n不能\n\n\n\n\n求向量空间中一个向量在一组基下的坐标\n基和向量组成矩阵\n把基化成单位矩阵\n向量所在列即为坐标\n\n解线性方程组\n齐次线性方程组\n\n系数矩阵\n行最简型\nn-r个自由变量\n6\n基础解系的线性组合就是通解\n\n\n非齐次线性方程组\n\n对应齐次线性方程组的通解\n令自由变量全为0得到一个特解\n齐次的通解+非齐次的特解即为非齐次的通解\n\n\n\n分块矩阵求矩阵的逆\n初等行变换\n\n原理\n\n（A|E）左乘A^(-1)得到（E|A^(-1))\n左乘可逆矩阵相当于做初等行变换\n\n\n\n操作\n\n作矩阵（A|E）\n初等行变换将A变化为E\n得到A^(-1)\n\n\n\n\n初等列变换\n\n图\n\n\n\n解矩阵方程\n图\n\n过渡矩阵两组基之间的过渡矩阵若X是在A基下的坐标，而Y是在B基下的坐标，则X，Y满足X&#x3D;PY；过渡矩阵P为可逆矩阵。\n\n作两组基组成的矩阵\n前n列化为单位矩阵\n后n列即为所求的过渡矩阵\n\n化二次型为标准型\n图\n得到对角矩阵和可逆矩阵C\n由对角矩阵写出关于y的标准二次型\n\n求矩阵的最高阶非零子式","categories":["线代"]},{"title":"利用bat运行java程序","url":"/2020/07/31/%E5%88%A9%E7%94%A8bat%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/","content":"如果是用C&#x2F;C++写的程序，可以直接编译成二进制的exe文件，在windows上执行起来很方便。\n而java程序，一般都是利用工具把程序打成jar包，通过java -jar xxx.jar运行，此外还需要有jdk或者jre环境才可以如此。\n\n\n我很好奇，MineCraft既然是用java编写的，他是怎样解决这一问题的呢？\n打包发布并不是一件容易的事儿，javaFX的打包我弄了好久也没明白。据我所知，打包主要有以下方式：\n\n普通的java项目，可以用ide提供的一些功能去生成可执行的jar包。Idea里的Modules，Libraries还有Artifacts我没弄明白，平时也都是稀里糊涂的。\n\nmaven程序可以通过两个常见的打包工具生成可执行的jar包\n\nspring boot程序最为方便，他提供了一个专门的打包工具，直接package就可以生成可执行的jar包。\n\n\n有时候jar包执行起来会有很多问题，希望以后可以有一个一统天下的打包神器。\n要想像exe程序一样直接双击运行，有一个叫做exe4j的软件可以把可执行jar包转为exe文件。我没试过，因为觉得麻烦，exe4j的界面好像是上个世纪的软件。\n通过bat执行java程序本质和java -jar xxx.jar没有区别。\n如果已经有一个可执行的jar包，可以新建一个bat格式的文件，举个栗子：\n@echo offjava -jar -Dfile.encoding=UTF-8 D:\\BlogForServer\\image-bed.jar \n\n@echo off的作用是关掉黑框中的路径信息。\n如果你在用IDEA，可以直接复制程序在IDEA运行时的命令：\n\n\n举个栗子：\n@echo offD:\\Software\\Java\\jdk-14\\bin\\java.exe --module-path D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib --add-modules javafx.controls,javafx.fxml --add-modules javafx.base,javafx.graphics --add-reads javafx.base=ALL-UNNAMED --add-reads javafx.graphics=ALL-UNNAMED &quot;-javaagent:D:\\Software\\JetBrains\\IntelliJ IDEA 2019.2.2\\lib\\idea_rt.jar=64980:D:\\Software\\JetBrains\\IntelliJ IDEA 2019.2.2\\bin&quot; -Dfile.encoding=UTF-8 -classpath D:\\Project\\IdeaProjects\\openJFX\\target\\classes;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\src.zip;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx-swt.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.web.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.base.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.fxml.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.media.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.swing.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.controls.jar;D:\\Software\\Java\\javafx-sdk-14.0.2.1\\lib\\javafx.graphics.jar sample.Main\n\n只要能在ide里运行，用bat文件也能运行。\n不过，上述方法只适合在本地小打小闹，如果要想要在别人的电脑上随意运行，此路不通。\n等我会一点儿docker之后，这个问题也许能迎刃而解。\n","categories":["Java"]},{"title":"剑指offer-03","url":"/2020/07/07/%E5%89%91%E6%8C%87offer-03/","content":"剑指offer-03  数组中重复的数字题目\n\n\n\n结果\n\n代码class Solution &#123;    public int findRepeatNumber(int[] nums) &#123;        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        for (int i : nums) &#123;            if (!set.add(i)) &#123;                return i;            &#125;        &#125;        return 0;    &#125;&#125;\n\n上面代码的时间复杂度是O（n）。最开始，我的代码是这样的：\nclass Solution &#123;    public int findRepeatNumber(int[] nums) &#123;        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();        for (int i : nums) &#123;            if (list.contains(i)) &#123;                return i;            &#125; else &#123;                list.add(i);            &#125;        &#125;        return 0;    &#125;&#125;\n\n思路和用集合set是一样的，但是这种方法超时了，原因是list的contains方法本身也有O（n）的时间复杂度。但是set不一样，set内部是用HashMap实现的，查找的时间复杂度只有O（1）。\n值得一提的是，set的add方法有一个布尔类型的返回值，如果添加失败（集合中已经存在这样的元素）会返回false，否则返回true，这一点是我之前所不知道的，可以善加利用。\n","categories":["剑指offer"]},{"title":"剑指offer-07","url":"/2020/07/09/%E5%89%91%E6%8C%87offer-07/","content":"剑指offer-07 重建二叉树题目\n\n\n\n结果普通版\n\n\n\n改进版\n\n代码普通版public class LeetCode &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        int[] preorder = new int[]&#123;3, 9, 20, 15, 7&#125;;        int[] inorder = new int[]&#123;9, 3, 15, 20, 7&#125;;        TreeNode root = solution.buildTree(preorder, inorder);    &#125;&#125;class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        // 递归终止的情况        int len = preorder.length;        if (len == 0) &#123;            return null;        &#125;        // 构造树的根节点        TreeNode tree = new TreeNode(preorder[0]);        // 找到根节点在中序遍历中的位置        int root = 0;        for (int i = 0; i &lt; len; i++) &#123;            if (inorder[i] == preorder[0]) &#123;                root = i;                break;            &#125;        &#125;        // 初始化左右子树的先序和中序遍历结果        int[] leftPre = new int[root];        int[] rightPre = new int[len - root - 1];        int[] leftIn = new int[root];        int[] rightIn = new int[len - root - 1];        // 构造左子树的先序和中序遍历结果        for (int i = 0; i &lt; root; i++) &#123;            leftPre[i] = preorder[i + 1];            leftIn[i] = inorder[i];        &#125;        // 构造右子树的先序和中序遍历结果        for (int i = 0; i &lt; rightPre.length; i++) &#123;            rightPre[i] = preorder[root + i + 1];            rightIn[i] = inorder[root + i + 1];        &#125;        // 递归地构造左右子树        tree.left = buildTree(leftPre, leftIn);        tree.right = buildTree(rightPre, rightIn);        return tree;    &#125;&#125;class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n改进版package eternal.fire.java;import java.util.HashMap;import java.util.Map;public class LeetCode &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        int[] preorder = new int[]&#123;1, 2, 3&#125;;        int[] inorder = new int[]&#123;3, 2, 1&#125;;        TreeNode root = solution.buildTree(preorder, inorder);    &#125;&#125;class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        // 特殊情况        if (preorder.length == 0) &#123;            return null;        &#125;        // map存储根节点再inorder出现的位置        Map&lt;Integer, Integer&gt; rootIndex = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) &#123;            rootIndex.put(inorder[i], i);        &#125;        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, rootIndex);    &#125;    /**     * @param preorder  先序遍历数组     * @param preBegin  先序遍历数组的起点     * @param preEnd    先序遍历数组的终点     * @param inorder   中序遍历数组     * @param inBegin   中序遍历数组的起点     * @param inEnd     中序遍历数组的终点     * @param rootIndex 根节点在inorder中出现的位置     * @return 构造好的二叉树     */    private TreeNode buildTree(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd, Map&lt;Integer, Integer&gt; rootIndex) &#123;        if (preBegin &gt; preEnd) &#123;            return null;        &#125;        // 构造根节点        TreeNode treeRoot = new TreeNode(preorder[preBegin]);        if (preBegin == preEnd) &#123;            return treeRoot;        &#125;        // 根节点的在中序遍历中的位置        int root = rootIndex.get(preorder[preBegin]);        // 左右子树的元素个数        int leftLen = root - inBegin;        treeRoot.left = buildTree(preorder, preBegin + 1, preBegin + leftLen, inorder, inBegin, root - 1, rootIndex);        treeRoot.right = buildTree(preorder, preBegin + leftLen + 1, preEnd, inorder, root + 1, inEnd, rootIndex);        return treeRoot;    &#125;&#125;class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n改进版用一个map存储根元素在中序遍历序列中出现的位置，避免了每次都要去找根节点，节约了时间。\n改进版只使用了原来的数组，没有new新的数组，节约了空间和时间。\n这题真做吐了。\n","categories":["剑指offer"]},{"title":"剑指offer-11","url":"/2020/07/11/%E5%89%91%E6%8C%87offer-11/","content":"剑指offer-11  旋转数组的最小数字题目\n\n\n\n结果\n\n代码class Solution &#123;    public int minArray(int[] numbers) &#123;        Arrays.sort(numbers);        return numbers[0];    &#125;&#125;\n\n","categories":["剑指offer"]},{"title":"剑指offer-12","url":"/2020/08/01/%E5%89%91%E6%8C%87offer-12/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private static final char VISITED = &#x27;/&#x27;;    public boolean exist(char[][] board, String word) &#123;        for (int i = 0; i &lt; board.length; i++) &#123;            for (int j = 0; j &lt; board[0].length; j++) &#123;                if (search(board, word, i, j, 0)) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    private boolean search(char[][] board, String word, int row, int col, int index) &#123;        // 是否越界或访问过或不符合预期        if (row &lt; 0 || row &gt;= board.length || col &lt; 0 || col &gt;= board[0].length || board[row][col] == VISITED || board[row][col] != word.charAt(index)) &#123;            return false;        &#125;        // 已经找到合适的序列        if (index == word.length() - 1) &#123;            return true;        &#125;        // 标记避免重复访问        char tmp = board[row][col];        board[row][col] = VISITED;        // 上下左右递归        if (search(board, word, row - 1, col, index + 1) || search(board, word, row + 1, col, index + 1) || search(board, word, row, col + 1, index + 1) || search(board, word, row, col - 1, index + 1)) &#123;            return true;        &#125; else &#123;            // 恢复            board[row][col] = tmp;            return false;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：大于O（m×n）\n空间复杂度：O（index），最大递归深度不超过index\n","categories":["剑指offer"]},{"title":"剑指offer-14","url":"/2020/07/22/%E5%89%91%E6%8C%87offer-14/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int cuttingRope(int n) &#123;        if (n &lt;= 3) &#123;            return n - 1;        &#125;        int x = n / 3;        int b = n % 3;        if (b == 0) &#123;            return (int) Math.pow(3, x);        &#125; else if (b == 1) &#123;            return (int) Math.pow(3, x - 1) * 4;        &#125; else &#123;            return (int) Math.pow(3, x) * 2;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（1）\n空间复杂度：O（1）\n"},{"title":"剑指offer-15","url":"/2020/07/18/%E5%89%91%E6%8C%87offer-15/","content":"剑指offer-15  二进制中1的个数题目\n\n\n\n结果\n\n代码版本一class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        return Integer.toBinaryString(n).replace(&quot;0&quot;, &quot;&quot;).length();    &#125;&#125;\n\n版本二public class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        String s = Integer.toBinaryString(n);        int count = 0;        for (char ch : s.toCharArray()) &#123;            if (ch == &#x27;1&#x27;) &#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;\n\n","categories":["剑指offer"]},{"title":"剑指offer-17","url":"/2020/07/25/%E5%89%91%E6%8C%87offer-17/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int[] printNumbers(int n) &#123;        int length = (int) (Math.pow(10, n) - 1);        int[] nums = new int[length];        for (int i = 0; i &lt; length; i++) &#123;            nums[i] = i + 1;        &#125;        return nums;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["剑指offer"]},{"title":"剑指offer-18","url":"/2020/07/26/%E5%89%91%E6%8C%87offer-18/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        if (head.next == null) &#123;            if (head.val == val) &#123;                return null;            &#125; else &#123;                return head;            &#125;        &#125;        if (head.val == val) &#123;            head = head.next;            return head;        &#125;        ListNode pre = head;        ListNode p = head.next;        while (p != null) &#123;            if (p.val == val) &#123;                pre.next = p.next;                return head;            &#125; else &#123;                p = p.next;                pre = pre.next;            &#125;        &#125;        return head;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["剑指offer"]},{"title":"剑指offer-20","url":"/2020/07/31/%E5%89%91%E6%8C%87offer-20/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isNumber(String s) &#123;        try &#123;            if (s.endsWith(&quot;f&quot;) || s.endsWith(&quot;D&quot;)) &#123;                return false;            &#125;            Double.parseDouble(s);            return true;        &#125; catch (NumberFormatException e) &#123;            return false;        &#125;    &#125;&#125;\n\n复杂度idk\n","categories":["剑指offer"]},{"title":"剑指offer-21","url":"/2020/07/28/%E5%89%91%E6%8C%87offer-21/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int[] exchange(int[] nums) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] % 2 != 0) &#123;                moveBack(nums, i);            &#125;        &#125;        return nums;    &#125;    private void moveBack(int[] nums, int index) &#123;        for (int i = index; i &gt; 0; i--) &#123;            if (nums[i - 1] % 2 == 0) &#123;                int tmp = nums[i];                nums[i] = nums[i - 1];                nums[i - 1] = tmp;            &#125; else &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：小于O（n²）\n空间复杂度：O（1）\n","categories":["剑指offer"]},{"title":"剑指offer-22","url":"/2020/07/31/%E5%89%91%E6%8C%87offer-22/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode p = head;        int length = 0;        while (p != null) &#123;            length++;            p = p.next;        &#125;        for (int i = 0; i &lt; length - k; i++) &#123;            head = head.next;        &#125;        return head;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["剑指offer"]},{"title":"剑指offer-27","url":"/2020/08/25/%E5%89%91%E6%8C%87offer-27/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        if (root == null) &#123;            return null;        &#125;        mirror(root);        return root;    &#125;    public void mirror(TreeNode root) &#123;        if (root == null) &#123;            return;        &#125;        TreeNode tmp = root.left;        mirror(root.left);        mirror(root.right);        root.left = root.right;        root.right = tmp;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["剑指offer"]},{"title":"剑指offer-25","url":"/2020/08/11/%E5%89%91%E6%8C%87offer-25/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        // Special case        if (l1 == null) &#123;            return l2;        &#125; else if (l2 == null) &#123;            return l1;        &#125;        // Head node        ListNode ans = new ListNode(0);        var p = ans;        var p1 = l1;        var p2 = l2;        while (p1 != null &amp;&amp; p2 != null) &#123;            if (p1.val &lt;= p2.val) &#123;                var tmp = p1;                p1 = p1.next;                tmp.next = null;                p.next = tmp;                p = p.next;            &#125; else &#123;                var tmp = p2;                p2 = p2.next;                tmp.next = null;                p.next = tmp;                p = p.next;            &#125;        &#125;        if (p1 != null) &#123;            p.next = p1;        &#125; else &#123;            p.next = p2;        &#125;        return ans.next;    &#125;&#125;\n\n复杂度时间复杂度：O（m + n）\n空间复杂度：O（1）\n","categories":["剑指offer"]},{"title":"剑指offer-28","url":"/2020/09/02/%E5%89%91%E6%8C%87offer-28/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if (root == null) &#123;            return true;        &#125;        return isSymmetric(root.left, root.right);    &#125;    private boolean isSymmetric(TreeNode left, TreeNode right) &#123;        if (left == null || right == null) &#123;            return left == right;        &#125;        return left.val == right.val &amp;&amp; isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);    &#125;&#125;\n\n复杂度时间复杂度：O（n），n为节点个数\n空间复杂度：O（递归层数）\n","categories":["剑指offer"]},{"title":"剑指offer-24","url":"/2020/07/31/%E5%89%91%E6%8C%87offer-24/","content":"题目\n\n\n\n结果\n\n代码class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head;        &#125; else &#123;            ListNode ans = reverseList(head.next);            head.next.next = head;            head.next = null;            return ans;        &#125;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n","categories":["剑指offer"]},{"title":"剑指offer-26","url":"/2020/08/12/%E5%89%91%E6%8C%87offer-26/","content":"题目\n\n\n\n结果\n\n代码class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;class Solution &#123;    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;        // Special case        if (A == null || B == null) &#123;            return A == B;        &#125;        // Find the nodes which has same value with B&#x27;s root        List&lt;TreeNode&gt; roots = new LinkedList&lt;&gt;();        dfs(A, B.val, roots);        for (TreeNode root : roots) &#123;            if (root != null &amp;&amp; cmp(root, B)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    private boolean cmp(TreeNode A, TreeNode B) &#123;        if (A == null || B == null) &#123;            return A == B;        &#125;        if (A.val == B.val) &#123;            if (B.left == null &amp;&amp; B.right == null) &#123;                return true;            &#125; else if (B.left == null) &#123;                return cmp(A.right, B.right);            &#125; else if (B.right == null) &#123;                return cmp(A.left, B.left);            &#125; else &#123;                return cmp(A.right, B.right) &amp;&amp; cmp(A.right, B.right);            &#125;        &#125;        return false;    &#125;    private void dfs(TreeNode A, int val, List&lt;TreeNode&gt; roots) &#123;        if (A == null) &#123;            return;        &#125;        if (A.val == val) &#123;            roots.add(A);        &#125;        dfs(A.left, val, roots);        dfs(A.right, val, roots);    &#125;&#125;\n\n复杂度时间复杂度：不好算啊，dfs时间复杂度是O（m），m是A的节点个数，cmp时间复杂度小于O（n），n是B的节点个数。\n空间复杂度：不好算啊，最多事O（m）\n","categories":["剑指offer"]},{"title":"剑指offer-29","url":"/2020/09/03/%E5%89%91%E6%8C%87offer-29/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final int RIGHT = 0, DOWN = 1, LEFT = 2, UP = 3;    private int direction = 0;    private boolean[][] flag;    public int[] spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (matrix.length == 0) &#123;            return new int[0];        &#125;        flag = new boolean[matrix.length][matrix[0].length];        int i = 0, j = 0;        while (true) &#123;            flag[i][j] = true;            ans.add(matrix[i][j]);            if (!reachable(matrix, i, j)) &#123;                direction = (direction + 1) % 4;                if (!reachable(matrix, i, j)) &#123;                    break;                &#125;            &#125;            if (direction == RIGHT) &#123;                j++;            &#125; else if (direction == DOWN) &#123;                i++;            &#125; else if (direction == LEFT) &#123;                j--;            &#125; else if (direction == UP) &#123;                i--;            &#125;        &#125;        int[] array = new int[ans.size()];        for (int k = 0; k &lt; array.length; k++) &#123;            array[k] = ans.get(k);        &#125;        return array;    &#125;    private boolean reachable(int[][] matrix, int row, int col) &#123;        if (direction == RIGHT) &#123;            if (col + 1 &gt;= matrix[0].length) &#123;                return false;            &#125; else return !flag[row][col + 1];        &#125;        if (direction == DOWN) &#123;            if (row + 1 &gt;= matrix.length) &#123;                return false;            &#125; else return !flag[row + 1][col];        &#125;        if (direction == LEFT) &#123;            if (col - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row][col - 1];        &#125;        if (direction == UP) &#123;            if (row - 1 &lt; 0) &#123;                return false;            &#125; else return !flag[row - 1][col];        &#125;        throw new RuntimeException(&quot;Impossible&quot;);    &#125;&#125;\n\n复杂度时间复杂度：O(m*n)\n空间复杂度：O(m*n)\n","categories":["剑指offer"]},{"title":"剑指offer-31","url":"/2020/09/10/%E5%89%91%E6%8C%87offer-31/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;        // Stack simulation        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();        // Check out if the num has been used        boolean[] flag = new boolean[pushed.length];        for (int pop : popped) &#123;            for (int i = 0; i &lt; pushed.length; i++) &#123;                // If the num has not been used                if (!flag[i]) &#123;                    stack.push(pushed[i]);                    flag[i] = true;                &#125;                if (!stack.isEmpty() &amp;&amp; stack.peek() == pop) &#123;                    stack.pop();                    break;                &#125;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;\n\n","categories":["剑指offer"]},{"title":"剑指offer-45","url":"/2020/08/04/%E5%89%91%E6%8C%87offer-45/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public String minNumber(int[] nums) &#123;        Integer[] integers = new Integer[nums.length];        for (int i = 0; i &lt; nums.length; i++) &#123;            integers[i] = nums[i];        &#125;        Arrays.sort(integers, (o1, o2) -&gt; &#123;            if (o1.intValue() == o2.intValue()) &#123;                return 0;            &#125;            if (o1.toString().length() == o2.toString().length()) &#123;                return o1.compareTo(o2);            &#125; else &#123;                return cmp(o1.toString(), o2.toString());            &#125;        &#125;);        StringBuilder ans = new StringBuilder();        for (int i = 0; i &lt; nums.length; i++) &#123;            ans.append(integers[i]);        &#125;        System.out.println(Arrays.toString(integers));        return ans.toString();    &#125;    public int cmp(String s1, String s2) &#123;        int tmp = cmp(s1.charAt(0), s2.charAt(0));        if (tmp != 0) &#123;            return tmp;        &#125;        int num1 = Integer.parseInt(s1 + s2);        int num2 = Integer.parseInt(s2 + s1);        return Integer.compare(num1, num2);    &#125;    private int cmp(char c1, char c2) &#123;        return Character.compare(c1, c2);    &#125;&#125;\n\n复杂度时间复杂度：O（nlogn）\n空间复杂度：O（n）\n","categories":["剑指offer"]},{"title":"化二次型为标准型","url":"/2019/08/25/%E5%8C%96%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B8%BA%E6%A0%87%E5%87%86%E5%9E%8B/","content":"\n\n\n\n\n\n化二次型为标准型正交变换法基础知识\n二次型对应一个实对称矩阵\n对角矩阵对应二次型的标准型\n实对称矩阵一定可以化成对角阵\n\n步骤\n求出二次型的矩阵A\n求出A的所有特征值\n求出特征值对应的特征向量\n将特征向量正交化、单位化作为列向量组成矩阵C\n作正交变换x&#x3D;Cy得到f的标准型\n\n配方法初等变换法图得到对角矩阵和可逆矩阵C由对角矩阵写出关于y的标准二次型","categories":["线代"]},{"title":"半导体二极管","url":"/2019/12/24/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1/","content":"","categories":["模电"]},{"title":"华为机试","url":"/2021/03/27/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/","content":"题目\n有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？\n现有一组砝码，重量互不相等，分别为m1,m2,m3…mn；每种砝码对应的数量为x1,x2,x3…xn。现在要用这些砝码去称物体的重量(放在同一侧)，问能称出多少种不同的重量。\n\n\n\n代码\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n    var num int\n    for &#123;\n        n, _ := fmt.Scan(&amp;num)\n        if n == 0 || num == 0 &#123;\n            break\n        &#125;\n        fmt.Println(drink(num))\n    &#125;\n&#125;\n\nfunc drink(num int) (ans int) &#123;\n    return num / 2\n&#125;\n\n2. ```go   package main      import (   \t&quot;fmt&quot;   )      func main() &#123;   \tfor &#123;   \t\tvar n int   \t\tnn, err := fmt.Scan(&amp;n)   \t\tif nn == 0 || err != nil &#123;   \t\t\tbreak   \t\t&#125;      \t\tvar nums []int   \t\tfor i := 0; i &lt; n; i++ &#123;   \t\t\tvar num int   \t\t\t_, _ = fmt.Scan(&amp;num)   \t\t\tnums = append(nums, num)   \t\t&#125;      \t\tvar amount []int   \t\tfor i := 0; i &lt; n; i++ &#123;   \t\t\tvar num int   \t\t\t_, _ = fmt.Scan(&amp;num)   \t\t\tamount = append(amount, num)   \t\t&#125;      \t\tvar weights []int   \t\tfor i := 0; i &lt; n; i++ &#123;   \t\t\tfor j := 0; j &lt; amount[i]; j++ &#123;   \t\t\t\tweights = append(weights, nums[i])   \t\t\t&#125;   \t\t&#125;   \t\tfmt.Println(cnt(weights))   \t&#125;   &#125;      func cnt(weights []int) int &#123;   \tvar set Set   \tset = make(map[int]bool)   \tset.add(0)   \tfor _, weight := range weights &#123;   \t\tvar nums []int   \t\tfor k := range set &#123;   \t\t\tnums = append(nums, k+weight)   \t\t&#125;   \t\tfor _, v := range nums &#123;   \t\t\tset.add(v)   \t\t&#125;   \t&#125;   \treturn len(set)   &#125;      type Set map[int]bool      func (s Set) add(num int) &#123;   \tif _, ok := s[num]; !ok &#123;   \t\ts[num] = true   \t&#125;   &#125;   \n\n\n\n","categories":["LeetCode"]},{"title":"单例","url":"/2020/05/12/%E5%8D%95%E4%BE%8B/","content":"单例\n定义保证一个类仅有一个实例，并提供一个访问它的全局访问点。特点在某个进程中，某个类有且只有一个实例实现方式一\nprivate的构造方法确保外部无法实例化\nprivate的static变量持有唯一的实例\npublic的static方法返回此实例确保外部能获得此唯一实例\n\n方式二\nenum\n\n枚举类的每个枚举都是单例\n\n\n\n方式三\n自觉\n\n\n\n栗子Runtime.getRuntime()","categories":["Design Patterns"]},{"title":"单元测试","url":"/2020/08/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"黑白盒黑盒\n已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用\n\n白盒\n已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查\n\n\n\n集成测试自顶向下\n概念\n\n从主程序开始，调用的单元用桩代替\n\n\n方法\n\n可以DFS\\BFS\n\n\n优点\n\n能够较早的验证主要的控制点和判断点，如果主控制出现问题能够及时发现\n\n\n缺点\n\n桩的开发和维护\n\n\n\n自底向上\n概念\n\n对底层模型的行为进行较早的验证\n\n\n缺点\n\n对顶部的验证推迟了，设计上的错误不能被及时发现\n\n\n\n白盒测试\n语句测试\n\n分支测试\n\n路径测试\n\n\n","categories":["软件工程概论"]},{"title":"博客踩过的坑","url":"/2019/09/28/%E5%8D%9A%E5%AE%A2%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","content":"不踩坑是不可能的。  \n\n关于tags的坑  用hexo new “title”新建文章时，默认生成的文本文件中有tags一行，我原以为此处是填与标签有关的内容，但是发现填了之后，用hexo生成会报错，栗子：  ERROR Process failed: _posts/鬼灭之刃.md   YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:   现在还不知道这个tags到底是做什么用的，记得之前修改主题的时候，配置文件里tags后必须有一个空格，我因此卡了很久。等我弄明白了再补上吧。   \n\n关于插入的图片  用图床插入的图片在本地服务器（localhost:4000）是无法正常显示的，需要部署在服务器上，才能预览。\n\n如果使用新浪图床并且博客部署在自己的服务器上，图片将无法显示。\n\n更换了主题之后却没得到想要的结果，可以试试hexo clean命令，之后再执行hexo g和hexo d。\n\n设置阅读全文：\n\n\n\n在文章中使用 手动进行截断，Hexo 提供的方式\n在文章的 front-matter 中添加 description，并提供文章摘录\n自动形成摘要，在 主题配置文件 中添加：auto_excerpt:  enable: true  length: 150\n自动摘要会失去格式\n\n","categories":["Experience"]},{"title":"原型","url":"/2020/05/12/%E5%8E%9F%E5%9E%8B/","content":"原型\n概念用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。创建新对象的时候，根据现有的一个对象创建栗子Arrays.copyofObject.clone","categories":["Design Patterns"]},{"title":"原子操作","url":"/2020/03/16/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","content":"下面哪个选项不需要同步(synchronized)？\n\na++;\n\na &#x3D; b;\n\na &#x3D; 1;\n\n\n\n\n分析：a++ 实质上是 a &#x3D; a + 1，要想实现这个操作，首先要知道a的值，所以需要取出a的值，然后把a+1赋给a。\na &#x3D; b这个操作首先将a加载到寄存器中，然后将b加载的寄存器中，再赋值。\na &#x3D; 1这个操作无需读取，直接把1写到内存即可。\n综上所述，只有a &#x3D; 1是原子操作（要么不做，要么一步到位），不需要同步。\n","categories":["Java"]},{"title":"反对外国侵略的斗争","url":"/2019/06/14/%E5%8F%8D%E5%AF%B9%E5%A4%96%E5%9B%BD%E4%BE%B5%E7%95%A5%E7%9A%84%E6%96%97%E4%BA%89/","content":"\n\n\n\n\n\n反对外国的侵略斗争资本-帝国主义对中国的侵略及近代中国社会性质的演变鸦片战争前的中国与世界\n鸦片战争前的中国\n\n经济\n\n封建地主土地所有制经济占主导地位\n\n\n政治\n\n实行高度中央集权的封建君主专制制度\n\n\n社会结构\n\n族权和政权相结合的封建宗法等级制度，其核心是宗族家长制\n\n\n文化思想体系\n\n以儒家思想为核心\n\n\n\n\n鸦片战争前的世界\n\n一些国家先后经过资产阶级革命和工业革命，资本主义制度终于在欧美确立起来\n\n\n\n资本-帝国主义对中国的侵略\n“虎门硝烟”的定性\n\n维护国家利益和民族尊严的正义行动\n\n\n不平等条约\n\n中英《南京条约》\n中英《虎门条约》\n中美《望厦条约》\n中法《黄埔条约》\n\n\n签订不平等条约的结果\n\n破坏了\n\n中国的主权和领土完整\n中国的领海主权\n中国的司法主权\n中国的关税主权\n\n\n\n\n中国社会性质的变化\n\n中国逐步沦为半殖民地半封建国家\n社会主要矛盾发生变化，中国逐渐开始了反帝反封建的资产阶级民主革命\n\n\n\n近代中国社会的半殖民地半封建性质\n中国逐步沦为半殖民地的原因\n\n中国丧失了完全独立的地位，在相当程度上被殖民化了\n近代中国仍然维持着独立国家和政府的名义，还有一定的主权。与连名义上的独立也没有，而由殖民主义宗主国直接统治的殖民地尚有区别，因此被称作半殖民地\n\n\n中国逐步沦为半封建社会的原因\n\n外国资本主义列强用武力打开中国的门户，把中国卷入世界资本主义经济体系和世界市场之中\n西方列强并不容许中国发展成为独立的资本主义国家\n\n\n\n中国半殖民地半封建社会的基本特征\n资本-帝国主义侵略势力日益成为支配中国的决定性力量\n中国的封建势力成为资本-帝国主义压迫、奴役中国人民的社会基础和统治支柱\n封建地主的土地所有制依然在广大地区内保持着\n中国新兴的民族资本主义经济虽然已经产生，但它的发展很缓慢，力量很软弱\n近代中国各地区经济、政治和文化的发展是极不平衡的\n中国人民日益贫困 饥寒交迫 毫无政治权利\n\n近代中国社会阶级关系的变化\n近代中国诞生的工人阶级是中国新生产力的代表，是近代中国最革命的阶级\n\n近代中国的主要矛盾和历史任务\n近代中国的国情\n\n半殖民地半封建社会\n\n\n近代中国的主要矛盾\n\n帝国主义和中华民族\n封建主义和人民大众\n\n\n近代中国的主要任务\n\n民族独立\n人民解放\n\n\n近代中国的革命性质\n\n资产阶级民主革命\n\n\n近代中国的革命道路\n\n农村包围城市\n武装夺取政权\n\n\n近代中国的革命路线\n\n无产阶级领导的、人民大众的、反帝反封建反官僚资本主义的革命\n\n\n\n抵御外国武装侵略 争取民族独立的斗争反抗外来侵略的斗争\n人民群众的反侵略斗争\n\n广州三元里人民的抗英斗争，是中国近代史上中国人民第一次大规模的反侵略武装斗争\n\n\n爱国官兵的反侵略斗争\n\n邓世昌等人以身殉国\n\n\n\n粉碎瓜分中国的图谋\n边疆危机和瓜分危机\n\n瓜分中国的高潮到来的标志\n\n《马关条约》的签订\n\n\n《马关条约》\n\n台湾\n澎湖列岛\n辽东半岛\n\n\n“干涉还辽”事件\n\n俄、德、日三国迫使日本放弃了割占辽东半岛的要求，又以干涉还辽有功为由，要求租界中国港湾作为报酬\n\n\n列强瓜分中国图谋破产的原因\n\n重要原因：帝国主义列强之间的矛盾和制约\n根本原因：中华民族进行的不屈不挠的反侵略斗争\n\n\n义和团运动的评价\n\n由于当时中国人民对帝国主义的认识还停留在感性认识阶段，义和团运动存在着笼统的排外主义的错误\n由于认识不到帝国主义联合中国封建地主阶级以压迫中国人民的实质，义和团曾经蒙受封建统治者的欺骗\n由于小生产者的局限性，义和团运动中还存在着迷信、落后的倾向\n但是，一个基本的历史事实不容抹杀：义和团运动在粉碎帝国主义列强瓜分中国的斗争中，发挥了重大的历史作用\n\n\n\n反侵略战争的失败与民族意识的觉醒\n反侵略战争失败的原因\n\n根本原因：社会制度的腐败\n重要原因：经济技术的落后\n\n\n民族意识的觉醒\n\n鸦片战争以后，先进的中国人开始睁眼看世界\n甲午战争以后，中国人民的民族意识开始普遍觉醒\n\n\n先进中国人的觉醒主张\n\n林则徐、魏源\n王韬、薛福成、马建忠、郑观应\n严复\n孙中山\n\n\n\n","categories":["近代史"]},{"title":"反射","url":"/2020/05/09/%E5%8F%8D%E5%B0%84/","content":"反射Class类概念\nJvm为每一个加载到内存中的类都创建了一个特殊的Class类的实例\n相同的类有共同的Class实例\n\n获得\n通过class的静态变量class获得\n通过实例的getClass方法获得\n通过Class的静态方法forName获得\n\n概念\n类的Class实例包含的类的所有信息\n\n通过类对应的Class实例获得类和实例的信息即为反射\n\n\n动态加载\n检查是否已经加载，有就直接返回，避免重复加载\n\n当前缓存中确实没有该类，那么遵循父优先加载机制，加载.class文件\n\n上面两步都失败了，调用findClass()方法加载\n\n\n应用访问字段\n获得特定实例的某个字段的值\n\n获得该实例对应的类对应的Class实例\n通过Class实例获得该字段对应的field实例\n通过field实例的方法get获得该类的实例的该字段的值\n\n\n修改特定实例的某个字段的值\n\n获得该字段对应的field实例\n通过field实例的set方法修改字段的值\n\n\n\n访问方法\n获得方法的信息\n\n获得类对应的Class实例\n通过Class实例获得该方法对应的Method实例\n\n\n调用方法\n\n一般\n\n获得类对应的Class实例\n通过Class实例获得该方法对应的Method实例\n通过Method实例的invoke方法实现调用\n\n\n静态\n\n和“一般”的区别\n\ninvoke传入的实例参数为null\n\n\n\n\n构造\n\n\n\n\n创建实例\nClass.newInstance()可以调用class的public无参构造方法\n\n应用场景JVM创建实例\n通过Class对象判断真正类型\nSpring MVC自动组装\n思维导图","categories":["Java"]},{"title":"坚定理想信念","url":"/2019/01/16/%E5%9D%9A%E5%AE%9A%E7%90%86%E6%83%B3%E4%BF%A1%E5%BF%B5/","content":"","categories":["思修"]},{"title":"LeetCode-637","url":"/2020/09/12/LeetCode-637/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    private final Map&lt;Integer, Pair&gt; map = new HashMap&lt;&gt;();    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;        dfs(root, 0);        List&lt;Double&gt; ans = new LinkedList&lt;&gt;();        for (int key : map.keySet()) &#123;            ans.add(map.get(key).getSum() / map.get(key).getNum());        &#125;        return ans;    &#125;    private void dfs(TreeNode root, int level) &#123;        if (root == null) &#123;            return;        &#125;        if (map.containsKey(level)) &#123;            Pair pair = map.get(level);            pair.setNum(pair.getNum() + 1);            pair.setSum(pair.getSum() + root.val);        &#125; else &#123;            Pair pair = new Pair(root.val, 1);            map.put(level, pair);        &#125;        dfs(root.left, level + 1);        dfs(root.right, level + 1);    &#125;&#125;class Pair &#123;    private double sum;    // Record how many nums does this level has    private double num;    public double getSum() &#123;        return sum;    &#125;    public void setSum(double sum) &#123;        this.sum = sum;    &#125;    public double getNum() &#123;        return num;    &#125;    public void setNum(double num) &#123;        this.num = num;    &#125;    public Pair(double sum, double num) &#123;        this.sum = sum;        this.num = num;    &#125;    @Override    public String toString() &#123;        return String.format(&quot;num:%f,sum:%f&quot;, num, sum);    &#125;&#125;","categories":["LeetCode"]},{"title":"垃圾收集器与内存分配策略（1）","url":"/2020/07/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89/","content":"垃圾收集器与内存分配策略（1）\n序言Java和C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来\nGC（Garbage Collection）学习目的\n解决问题\n\n内存溢出、泄漏\nGC成了性能瓶颈\n\n\n\nGC区域无关紧要的\n与线程同生共死\n分配内存时大致内存是确定的，方法或线程结束，内存自动回收，所以整个生命周期内存是比较确定的，没什么好说的。GC主要关注java堆（又称gc堆）\n\n程序计数器\n虚拟机栈\n本地方法栈\n\n\n\n至关重要的\nJava堆\n主要存放对象的 实例。\n\n内存动态分配\n内存动态回收\n\n\n\n\n\n找垃圾算法回收之前要确定对象是死是活（未来还会用到吗）\n引用计数算法有一个人引用计数就加1，少一个人引用计数就减1\n\n优点\n\n立即执行\n计数为0就可以立即回收了\n\n自我诊断\n没必要再去new一个线程，是否可以回收自己就可以判断。\n\n\n\n缺点\n因为致命缺陷jvm不用这个\n\n计数本身有一定的工作量\n\n循环引用，形成永动\n两个变量互相引用是无解（无法回收）的\n\n\n\n\n根搜索算法有一些特殊的对象可以作为gc root，从gc root出发，能到达之处就不是垃圾，不能到达之处就是垃圾\n引用上古时代的定义\n存储着另一块内存的起始地址的变量\n\n分类\n强引用\nStrong\n\nObject obj &#x3D; new Object()\n只要引用存在，就不会被回收\n\n\n软引用\nSoft\n\n内存溢出之前会把软引用的对象回收，如果没用就报错了\n通过SoftReference实现软引用\n\n\n弱引用\nWeak\n\n比软引用更容易被回收\n朝生暮死（下次回收开始弱引用必死）\n通过WeakReference实现弱引用\n\n\n虚引用\nPhatom\n\n唯一用处是对象被回收时能收到一个系统通知\n通过PhatomReference实现虚引用\n\n\n\n生存还是死亡根搜索算法之后并未宣判死刑，对象仍有一线生机两次标记\n第一次标记\n\nfinalize方法\n这个方法时java对c\\c++程序员作出的妥协，这方法已经不适合这个版本了，应该被gc\n\n对象自我救赎的最后一次机会\n这个方法只可能被调用一次\n\n\n\n\n\n第二次标记\n\n如果对象救赎成功，就不会被标记，否则只有死路一条\n\n\n\n回收方法区回收废弃常量和无用的类性价比低，可以不gc垃圾收集算法标记-清除算法\n过程\n\n标记\n\n找垃圾算法\n\n\n清除\n\n\n\n缺点\n\n效率不行\n碎片太多，可能找不到大的连续的内存空间\n\n\n地位\n\n基石\n\n之后的算法都是改进版\n\n\n\n\n\n复制算法\n过程\n\n设置保留区，内存不够用时将所有活着的移到保留区，再清除\n50%-50%会减少一半的可用内存，代价太大，而且也不需要如此。90%-10%又没法交换，所以一般是三部分：80%-10%-10%，只有一个10%是闲置的\n\n分配担保\n\n\n\n优势\n\n简单易行\n\n\n缺点\n\n牺牲部分内存\n对象比较多时复制操作会比较多\n\n\n\n标记-整理算法\n过程\n\n标记\n\n整理\n\n把活着的拼接到一起\n\n\n清除\n\n\n\n\n分代收集算法\n内存划分\n\n新生代\n\n新生代每次存活数量少，选复制算法\n\n\n老生代\n\n存活率高，使用标记-整理\n\n\n\n\n\n","categories":["JVM"]},{"title":"基本电路元件模型","url":"/2019/09/03/%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E5%85%83%E4%BB%B6%E6%A8%A1%E5%9E%8B/","content":"","categories":["模电"]},{"title":"基本逻辑运算和集成逻辑门","url":"/2020/07/29/%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%92%8C%E9%9B%86%E6%88%90%E9%80%BB%E8%BE%91%E9%97%A8/","content":"基本逻辑运算概念\n对输入进行处理得出结果\n\n\n\n分类\n与\n\n逻辑表达式\n\n\n\n\n\n\n\n电路图\n\n与门\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n或\n\n逻辑表达式\n\n\n\n\n\n\n\n电路图\n\n或门\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n非\n\n逻辑表达式\n\n——\n\n\n电路图\n\n非门（反相器）\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n\n复合逻辑运算概念\n基本逻辑运算的组合\n\n分类\n与非\n\n概念\n\n先与后非\n\n\n电路\n\n与非门\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n或非\n\n概念\n\n先或后非\n\n\n电路\n\n或非门\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n与或非\n\n概念\n\n四个变量参与运算，先与再或后非\n\n\n电路\n\n与或非门\n\n\n逻辑符号\n\n常用\n国际\n国标\n\n\n\n\n异或\n\n概念\n\n不同1相同0\n\n\n逻辑表达式\n\n电路\n\n异或门\n\n\n奇偶特性\n\n偶数个1异或&#x3D;0\n奇数个1异或&#x3D;1\n\n\n\n\n同或\n\n概念\n\n相同1不同0\n\n\n逻辑表达式\n\n电路\n\n\n\n\n逻辑运算优先级别长非和括号\n乘\n\n异或同或\n\n加\n\n\n\n\n\n","categories":["数电"]},{"title":"复习","url":"/2020/08/01/%E5%A4%8D%E4%B9%A0/","content":"虽然已经8月了，但现在认真复习还来得及。\n以前不想复习的时候就去打游戏，打游戏久了就会愧疚，愧疚了就去复习。\n但这次有所不同，不想复习就逃避，选择敲代码，我就没那么愧疚，不愧疚就不想复习，所以拖到现在。\n路虽远，行则至。\n我决定暂停其他一切活动，专心复习。\n\n\n考试安排8月17日\n\n中午：操作系统\n\n8月18日\n\n早上：计组\n下午：C++\n\n8月19日\n\n早上：英语\n下午：毛概\n\n8月20日\n\n休\n\n8月21日\n\n中午：软件工程概论\n\n8月23日\n\n休\n\n8月24日\n\n早上：信号与系统\n下午：数电\n\n计划信号与系统既然选上了，就一定要及格啊。\n英语可以不复习，考之前稍微看看。\nC++我有java经验，想必问题不大。\n软件工程概论和毛概属于同一性质的科目，背一背。\n需要着重复习的是操作系统、计组、数电、信号与系统。\n复习方法主要是画思维导图、看ppt、做题。\n我可以，我能行！\n","categories":["Essay"]},{"title":"多版本并发控制","url":"/2020/12/12/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","content":"\n\n\n多版本并发控制Multi-Version Concurrency Control, MVCC\n地位InnoDB存储引擎实现隔离级别的一种具体方式\n主要用来实现Read Committed和Repeatable Read\nRead Uncommitted无需MVCC\n只靠MVCC无法实现Serializable\n\n基本思想脏读和不可重复读问题的根本原因\n未满足隔离性，事务可以读取到其它事务未提交的修改\n\n相关概念\n系统版本号（SYS_ID）\n\n每开始一个新的事务，系统版本号就会自动递增\n\n\n事务版本号（TRX_ID）\n\n事务开始时的系统版本号\n\n\n版本快照\n\n\nMVCC的要求\n修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照\n写操作更新最新的版本快照\n读操作读旧版本快照\n只能读取已经提交的快照\n\nUndo日志结构\n多个版本的快照存储在Undo日志中\n日志通过回滚指针ROLL_PTR把一个数据行的快照连起来\n\n栗子\n\n操作\nINSERT INTO t(id, x) VALUES(1, &quot;a&quot;);UPDATE t SET x=&quot;b&quot; WHERE id=1;UPDATE t SET x=&quot;c&quot; WHERE id=1;\n\n\n\n过程\nDel字段标记删除操作\n\n\nReadView\n内容\n当前系统未提交的事务列表（TRX_IDs ）\nTRX_ID_MIN、TRX_ID_MAX\n\n读操作过程\nTRX_ID &lt; TRX_ID_MIN\n\n该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用\n\n\nTRX_ID &gt; TRX_ID_MIN\n\n表示该数据行快照是在事务启动之后被更改的，因此不可使用\n\n\nTRX_ID_MIN &lt;&#x3D; TRX_ID &lt;&#x3D; TRX_ID_MAX\n\nRead Committed\n\nTRX_ID in TRX_IDs\n\n该数据行快照对应的事务还没提交，所以NO\n\n\nTRX_ID not in TRX_IDs\n\n该数据行快照对应的事务已经提交，所以YES\n\n\n\n\nRepeatable Read\n\nNo matter what， No\n为了避免不可重复读\n\n\n\n\n\n\n快照读与当前读快照读\nMVCC的Select读的是快照中的数据，无需加锁\n也可以手动加锁：\nSELECT * FROM table WHERE ? lock in share mode;SELECT * FROM table WHERE ? for update;\n\n当前读\nINSERT、UPDATE、DELETE需要进行加锁\n\nPhantom Read问题MVCC不能解决Phantom Read问题：\nMVCC只能解决快照读的幻读问题，不能解决当前读的幻读问题\n行锁\nRecord Locks\n\n锁定一个记录上的索引 而不是记录本身\n\n\nGap locks\n\n锁定索引之间的间隙\n\n\nNext-Key locks\n\n不仅锁定一个记录上的索引，也锁定索引之间的间隙\n\n概念\n\nInnoDB存储引擎的一种锁实现\n\n\n作用\n\n使用MVCC+Next-Key Locks可以在Repeatable Read级别下解决幻读问题\n\n\n\n\n\n","categories":["数据库"]},{"title":"多线程","url":"/2020/05/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"多线程\ncondition地位\nreentrantlock的partner\n类似于synchronized和（wait、notify）的关系\n一个lock对应一个condition\n\nnew\n必须使用对应lock的newCondition方法\n\n方法\nawait()\n\n可以设置等待时间、超过后自己醒来\n\n\nsignal()\n\nsignalAll()\n\n\n\n\nReadWriteLock存在的需求\n读操作\n\n单纯的读不会出什么幺蛾子\n\n\n写操作\n\n写和读之间不同步 不合逻辑的现象会出现\n\n\nTODO\n目的是提高性能\n\n读操作的时候大伙儿可以一起上\n写操作的时候只能我上\n\n\n\n意义\n大大的提高了并发读的效率\n\nStampedlock乐观锁允许读的过程中有写入悲观锁不允许读的过程中有写入","categories":["Java"]},{"title":"大师","url":"/2020/05/25/%E5%A4%A7%E5%B8%88/","content":"","categories":["Essay"]},{"title":"学习观","url":"/2021/04/17/%E5%AD%A6%E4%B9%A0%E8%A7%82/","content":"\n\n\n\n学习观的内容应该刻进DNA里。\n最初看到学习观的时候，感到十分震撼，并且很认同作者的观点。我同身边的很多人分享过其中的内容，然而到了现在，很多东西都忘却了。\n我也尝试着使用学习观中提到的方法，到现在也保留着画思维导图的习惯，这使我受益匪浅。\n也许我应该抽空再复习一遍，就这两天吧。\n","categories":["Experience"]},{"title":"安装RabbitMQ","url":"/2020/07/31/%E5%AE%89%E8%A3%85RabbitMQ/","content":"安装ErlangRabbitMQ是用Erlang编写的。\n下载二进制安装包并安装下载链接：http://erlang.org/download/otp_win64_23.0.exe\n温馨提示：下载请开代理。\n\n\n配置环境变量在环境变量里添加ERLANG_HOME:Erlang安装目录，在path里添加%ERLANG_HOME%\\bin。\n在shell里运行erl -v，出现版本号说明一切ok。\n\n\n安装RabbitMQ下载二进制安装包并安装下载链接：https://www.rabbitmq.com/install-windows.html\n配置环境变量在环境变量里添加RABBITMQ_HOME:RABBITMQ安装目录，在path里添加%RABBITMQ_HOME%\\sbin，在shell里运行rabbitmq-plugins.bat enable rabbitmq_management，接着运行rabbitmq-server.bat ，即可启动rabbitmq服务器。\n\n\n访问localhost:15672出现兔子表明一切ok。\n","categories":["Spring"]},{"title":"对前后端分离的理解","url":"/2020/07/02/%E5%AF%B9%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%90%86%E8%A7%A3/","content":"对前后端分离的一点理解对前后端分离的认知经历了一个比较长的过程。\n初体验记得大一的时候，我从一个同学那儿第一次听说了“前端”和“后端”这两个名词，我就问他什么是前端和后端啊，他告诉我前端就是用户可以看到的那部分，后端就是用户看不到的部分。\n初认识在学习MVC的时候，我了解到。传统的开发模式因为耦合性很高，所以有很多缺点。但是我只是听别人说耦合性高，自己从来没有试过传统的写法。在写了一些MVC架构的demo之后，才对这一点有了更深的理解。\n\n\n在学习WEB开发的时候，我用到了模板引擎（Pebble，ThymeLeaf）。用模板引擎可以把数据渲染到html页面上，等到我牛刀小试之后，对前后端分离有了新的认识。此时的我认为，前端写html、css，后端操作数据库，处理业务逻辑，把数据渲染到html上。前后端各司其职，这就是前后端分离。\n在最开始学习用spring写一个RESTful服务的时候，我不明白这东西有什么用。直到我学习到了Ajax，我才明白原来这东西是这样用的啊，此时对前后端如何交互有了新的认识。\n再后来，在我开始学习Vue的时候，我觉得这和ThymeLeaf等模板引擎不就是一回儿事儿嘛，他们负责把数据渲染到页面上，语法上也很相似。既如此，为什么把Vue叫做前端框架，把ThymeLeaf叫做模板引擎呢。\n再认识现在的我对前后端分离这件事儿又有了新的理解，是否可以称之为前后端分离，关键在于传输的数据，也可以这样说，浏览器和服务器两者，到底是谁把数据渲染到页面上的。\n前后端不分离是怎样的？把数据渲染到页面这个过程是在服务器完成的，传输的数据是整个html页面。\n前后端分离是怎样的？把数据渲染到页面这个过程是在浏览器完成的，传输的数据是需要渲染的数据。\n为什么需要前后端分离呢\n前端工程师和后端工程师的任务截然不同，正所谓闻道有先后，术业有专攻，分工合作，各司其职可以提高效率。\n\n让服务器传输整个html页面势必会造成许多浪费，也会增加服务器的压力。\n\n越是复杂的项目越需要解耦，简单的项目可以随便来。\n\n\n纸上得来终觉浅，绝知此事要躬行。\n","categories":["Experience"]},{"title":"对国家出路的早期探索","url":"/2019/06/14/%E5%AF%B9%E5%9B%BD%E5%AE%B6%E5%87%BA%E8%B7%AF%E7%9A%84%E6%97%A9%E6%9C%9F%E6%8E%A2%E7%B4%A2/","content":"\n\n\n\n\n\n对国家出路的早期探索农民阶级的探索太平天国运动\n爆发原因\n性质\n失败\n\n《天朝田亩制度》和《资政新篇》\n天朝田亩制度\n\n内容\n进步性\n局限性\n\n\n资政新篇\n\n内容\n进步性\n局限性\n\n\n\n太平天国运动的理论分析\n历史意义\n\n对清朝\n\n沉重打击封建统治阶级\n\n动摇了清王朝封建统治的根基\n\n加速了清王朝的衰败\n\n\n\n\n农民战争的最高峰\n\n\n\n对侵略者\n\n打击了外国侵略势力\n\n\n对社会\n\n冲击了儒家之权威\n削弱了封建统治的精神支柱\n\n\n对国际\n\n同其他国家的民族解放运动一起冲击了西方殖民者的统治\n\n\n\n\n失败原因\n\n根本原因：农民阶级的局限性\n\n无法从根本上提出完整的、正确的政治纲领和社会改革方案\n无法制止和克服领导集团自身腐败现象的滋生\n无法长期保持领导集团的团结\n\n\n没有科学理论的指导\n\n未能正确对待儒学\n\n对西方侵略者还缺乏理性认识\n\n\n\n教训\n\n农民具有伟大的革命潜力，但它自身不能担负起领导反帝反封建斗争取得胜利的重任\n\n\n\n封建（地主）阶级的探索洋务事业的兴办\n原因\n\n购买制造洋枪洋炮以镇压农民起义\n同时借此加强海防、边防\n乘机发展本集团的政治经济军事实力\n\n\n指导思想\n\n中学为体，西学为用\n\n以中国封建伦理纲常所维护的统治秩序为主体\n用西方的近代工业和技术为辅助\n\n\n\n\n洋务派举办的洋务事业\n\n兴办近代企业\n建立新式海陆军\n创办新式学堂，派遣留学生\n\n\n\n洋务运动\n历史作用\n\n对中国早期工业和民族资本主义的发展起了某些促进作用\n给当时的中国带来了新知识，开阔人们的眼界\n社会风气和价值观念开始变化，工商业者的地位上升。\n\n\n失败的标志\n\n甲午战争，北洋海军全军覆没\n\n\n失败的原因\n\n封建性（阶级局限性）\n对列强具有依赖性\n管理具有腐朽性\n\n\n\n资产阶级维新派的探索维新运动的开展\n兴起原因\n\n民族资本主义初步发展\n内忧外患的冲击和中西文化的碰撞\n\n\n活动内容\n\n向皇帝上书\n\n著书立说\n\n康有为:《新学伪经考》《孔子改制考》\n\n\n介绍外国变法的经验教训\n\n办学会\n\n强学会\n南学会\n保国会\n\n\n设学堂\n\n广州万木草堂\n长沙时务学堂\n\n\n办报纸\n\n上海《时务报》\n天津《国闻报》\n湖南《湘报》\n\n\n\n\n维新派改良的方式\n\n争取光绪帝及周围官员支持，希望藉此自上而下实行变法\n\n\n进步性\n\n政令由维新派提出\n\n资产阶级享受了一定程度的政治权利\n\n\n促进了资本主义工商业的发展\n\n\n\n局限性\n\n政令和措施未触及封建制度的根本\n所推行的是一种十分温和的不彻底的改革方案\n\n\n结果\n\n戊戌六君子\n除了京师大学堂被保留下来，其余新政措施被废除\n\n\n\n维新派与守旧派的论战\n内容\n\n要不要变法\n要不要兴民权、设议院，实现君主立宪\n要不要废八股、改科举和兴西学\n\n\n评价\n\n资产阶级思想与封建主义思想在中国的正面交锋\n开阔新型知识分子的眼界\n解放人们长期受到束缚的思想\n西方资产阶级社会政治学说在中国得到进一步的传播\n\n\n\n维新运动的意义和教训\n意义\n\n爱国救亡运动\n\n资产阶级性质的政治改良运动\n\n思想启蒙运动\n\n京师大学堂：近代国立高等教育的发端\n\n\n\n\n失败的原因\n\n根本原因：维新派自身的局限\n\n以慈禧太后为首的强大的守旧势力的反对\n\n客观原因：民族资产阶级力量弱小\n\n主观原因：\n\n不敢否定封建主义\n对帝国主义抱有幻想\n惧怕人民群众\n\n\n\n\n失败的教训\n\n在半殖民地半封建的旧中国，企图通过统治阶级走自上而下的改良实现国家独立民主富强是行不通的，必须用革命的手段，反帝反封建\n\n\n\n","categories":["近代史"]},{"title":"封锁","url":"/2020/12/11/%E5%B0%81%E9%94%81/","content":"\n\n\n封锁粒度粒度的辩证关系\n粒度小，系统开销大，并发程度高\n粒度大，系统开销小，并发程度低\n\nMySQL提供两种粒度\n行级锁\n表级锁\n\n封锁类型读写锁\n互斥锁（Exclusive）\n\nX锁、写锁\n加了X锁后，不能再加任何锁\n\n\n共享锁（Shared）\n\nS锁、读锁\n加了S锁后，还可以再加S锁\n\n\n\n意向锁\n作用\n\n快速判断表中是否有某一行上了锁\n\n\n过程\n\n表的IS锁–&gt;行的S锁\n表的IX锁–&gt;行的X锁\n\n\n兼容关系\n\n\n封锁协议三级封锁协议\n一级封锁协议\n\n概念\n\n事务修改数据时必须加X锁，事务结束后释放\n\n\n\n作用\n\n解决丢失修改问题\n\n\n\n\n二级封锁协议\n\n概念\n\n事务读取数据时必须加S锁，读完之后释放\n\n\n\n作用\n\n解决脏读问题\n\n\n\n\n三级封锁协议\n\n概念\n\n事务读取数据时必须加S锁，事务结束后释放\n\n\n\n作用\n\n解决不可重复读问题\n\n\n\n\n\n两段锁协议\n要求\n加锁和解锁分为两个阶段进行\n\n读写操作之前要获取数据对应的封锁\n释放封锁之后，不再请求任何封锁\n\n\n可串行化调度\n\n通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同\n\n\n两段锁协议是可串行化调度的充分不必要条件\n\n\nMySQL-InnoDB引擎隐式锁定\n根据隔离级别在需要的时候自动加锁\n所有的锁在同一时刻被释放\n\n显示锁定\n使用特定的语句\n\n","categories":["数据库"]},{"title":"将IntelliJ Idea的项目发布到github","url":"/2020/06/01/%E5%B0%86IntelliJ-Idea%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0github/","content":"将IntelliJ Idea的项目发布到githubIntelli Idea版本：\n\n安装git并在Idea中设置好git的路径\n\n\n\n在Idea设置-Version Control-github里登录github账号\n\n创建git仓库\n\n目录选择项目所在目录就可以\n将修改提交到git仓库在项目根目录处右键git-Add或使用快捷键Ctrl+Alt+A\n\n\nCommit\n\n\n\n将项目发布到github\n\n不出意外的话，登录github就可以看到成果了。\n","categories":["Experience"]},{"title":"将博客从github迁移到gitee","url":"/2020/07/06/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BB%8Egithub%E8%BF%81%E7%A7%BB%E5%88%B0gitee/","content":"将博客从github迁移到gitee起因我的博客是最常见的github pages+hexo搭建而成的，一切都好，唯一不足就是访问太慢了，因为众所周知的原因，偶尔甚至不能访问。我自己有梯子倒还好，开代理就行，但是博客还想给别的小伙伴分享，正好gitee也有类似的功能，所以决定给博客搬个家。\n步骤新建仓库在gitee上新建一个仓库，可以选择直接从github导入：\n\n\n\n\n仓库名和路径必须和gitee的用户名一致（和github要求一样）：\n\n\n\n如何创建一个首页访问地址不带二级目录的 pages，如ipvb.gitee.io？\n答：如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，你需要建立一个与自己个性地址同名的仓库，如 https://gitee.com/ipvb 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以ipvb.gitee.io直接访问，那么他就可以创建一个名字为ipvb的仓库 https://gitee.com/ipvb/ipvb 部署完成后，就可以以 https://ipvb.gitee.io 进行访问了。\n摘自gitee官方说明\n\n修改hexo配置\n\n修改_config.yml 中仓库的地址为新的gitee仓库地址。\n开启gitee pages服务\n\n\n\n现在可以公开的情报gitee有社区版和企业版，社区版每次更新博客之后要手动去update gitee pages。\n企业版会自动update，但是要钱，有得必有失。\n","categories":["Experience"]},{"title":"尊法学法守法用法","url":"/2019/01/16/%E5%B0%8A%E6%B3%95%E5%AD%A6%E6%B3%95%E5%AE%88%E6%B3%95%E7%94%A8%E6%B3%95/","content":"","categories":["思修"]},{"title":"布尔代数与逻辑函数化简","url":"/2020/07/30/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E4%B8%8E%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/","content":"基本公式交换律\n结合律\n分配率\n吸收律\n\n吸收律一\n吸收率二\n吸收率三\n\n多余项定律\n摩根律\n\n\n三大法则代入法则\n类似数学中变量替换\n\n対偶法则\n原式成立则对偶式成立\n\n对偶式\n\n求法\n\n与和或交换\n0和1交换\n原变量与反变量不变\n长非号不变\n\n\n\n\n\n反演法则\n反函数\n\n求法\n\n与和或交换\n0和1交换\n原变量与反变量交换\n长非号不变\n\n\n\n\n\n特点\n版本弃子，用卡诺图吧\n\n卡诺图化简最小项标准式表格\n表格的坐标是格雷码\n\n合并包含1的相邻项直接求得最简与或式其他逻辑形式\n最简与非式\n\n最简与或式求两次反\n\n\n最简与或非式\n\n圈0得到反函数的最简与或式\n取反得到原函数的最简与或非式\n\n\n最简或与式\n\n可以通过最简与或式手动化\n可以通过圈0取反得到或式再与\n\n\n最简或非式\n\n把与或非里的与用摩根律变成或\n\n\n\n含有无关项\n根据是否有利于化简，无关项可以取1或0\n考虑无关项，最终结果要加上约束条件\n\n","categories":["数电"]},{"title":"工厂方法","url":"/2020/05/12/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","content":"工厂方法\n栗子List.of()Map.of()MessageDigest.getInstance()过程接口实现类在接口中定义一个静态方法返回实现类的实例\n\n特点隐藏实现细节\n你需要的是List，我返回的可能是LinkedList也可能是ArrayList，这是你所不知道的\n\n创建产品的代码与调用产品的代码相分离调用方只和抽象工厂及其产品打交道优势创建产品的代码可以独立变化可能存在的优化\n静态工厂方法不一定创建产品，可能使用缓存已有的\n\n"},{"title":"常用maven依赖项和CDN","url":"/2020/07/24/%E5%B8%B8%E7%94%A8maven%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%92%8CCDN/","content":"常用Maven依赖项Java版本和UTF-8编码&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.ouputEncoding&gt;UTF-8&lt;/project.reporting.ouputEncoding&gt;        &lt;maven.compiler.source&gt;14&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;14&lt;/maven.compiler.target&gt;        &lt;java.version&gt;14&lt;/java.version&gt;&lt;/properties&gt;\n\n\n\nMaven打包插件 &lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;            &lt;version&gt;2.4&lt;/version&gt;            &lt;configuration&gt;                &lt;descriptorRefs&gt;                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                &lt;/descriptorRefs&gt;                &lt;archive&gt;                    &lt;manifest&gt;                        &lt;mainClass&gt;eternal.fire.Main&lt;/mainClass&gt;                    &lt;/manifest&gt;                &lt;/archive&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;make-assembly&lt;/id&gt;                    &lt;phase&gt;package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;single&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\nSpringMVC\n&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;        &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n数据库&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.19&lt;/version&gt;&lt;/dependency&gt;\n\nWebjarsBootstrap：依赖：&lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;            &lt;version&gt;4.5.0&lt;/version&gt;&lt;/dependency&gt;引用：&lt;link rel=&quot;stylesheet&quot; href=&quot;webjars/bootstrap/4.5.0/css/bootstrap.min.css&quot;/&gt;&lt;script src=&quot;webjars/jquery/3.5.1/jquery.slim.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;webjars/popper.js/1.16.0/umd/popper.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;webjars/bootstrap/4.5.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;JQuery:依赖：&lt;dependency&gt;\t&lt;groupId&gt;org.webjars.bower&lt;/groupId&gt;\t&lt;artifactId&gt;jquery&lt;/artifactId&gt;\t&lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;引用：&lt;script src=&quot;webjars/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;Font Awesome:版本4依赖：&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;font-awesome&lt;/artifactId&gt;    &lt;version&gt;4.7.0&lt;/version&gt;&lt;/dependency&gt;引用：&lt;link rel=&quot;stylesheet&quot; href=&quot;webjars/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;版本5：依赖：&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;font-awesome&lt;/artifactId&gt;    &lt;version&gt;5.13.1&lt;/version&gt;&lt;/dependency&gt;引用：&lt;link rel=&quot;stylesheet&quot; href=&quot;webjars/font-awesome/5.13.1/css/all.css&quot;&gt;\n\n常用CDNVue&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n\nBootstrap&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js&quot; integrity=&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n\nJQuery&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt;\n\nFont Awesome版本4：&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css&quot; integrity=&quot;sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=&quot; crossorigin=&quot;anonymous&quot;&gt;版本5：&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.css&quot; integrity=&quot;sha256-HmKKK3VimMDCOGPTx1mp/5Iaip6BWMZy5HMhLc+4o9E=&quot; crossorigin=&quot;anonymous&quot;&gt;\n\nLodash&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@latest/lodash.min.js&quot;&gt;&lt;/script&gt;\n\nAxios&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@latest/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n\n","categories":["Experience"]},{"title":"并发一致性问题","url":"/2020/12/08/%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","content":"\n\n\n\n\n概念并发环境下，事务的隔离性很难保证，从而会出现一致性的问题根本原因\n隔离性未得到保证\n\n解决方法\n封锁\n隔离级别\n\n分类丢失修改\n产生\n\n未满足隔离性，事务有更新操作，但事务结束之后结果和预期不符\n\n\n结果\n\n事务执行结果与预期不符\n\n\n图\n\n\nDirty Read\n产生\n\n未满足隔离性，因为另一个事务的回滚造成读的错误\n\n\n结果\n\n连续Read两遍结果不一样\n\n\n图\n\n\nNon Repeatable Read\n产生\n\n未满足隔离性，两次读之间另一个事物有修改操作\n\n\n结果\n\n连续Read两次结果不一样\n\n\n图\n\n\nPhantom Read\n产生\n\n未满足隔离性，两次读之间另一个事务有插入操作\n\n\n结果\n\n连续读两次，第一次读不到，第二次读的到\n\n\n图\n\n\n\n","categories":["数据库"]},{"title":"异常","url":"/2020/07/07/%E5%BC%82%E5%B8%B8/","content":"Java异常Error VS ExceptionError和Exception本质是两个Class，他们都继承自Throwable这个类。Error表示严重的错误，比如OutOfMemoryError和StackOverflowError，出现Error程序就会停止，Error无法被捕获处理。Exception表示常见的一般的错误，可以被捕获处理，也可以向上层函数抛出，可以一直抛到main方法为止，如果在main方法内部还没有捕获异常，程序将会停止。\nRuntimeException VS CheckedExceptionRuntimeException又叫UncheckedException，两者的区别从名字就可见一斑。RuntimeException及其子类不需要程序去捕获或者抛出，CheckedException及其子类必须去捕获或抛出。究其原因，在于RuntimeException及其子类是一些难以预估的错误，比如最常见的NullPointerException、IndexOutOfBoundsException等，这类错误编译器无法获知，只有当程序运行起来之后才能得到结果。而我们容易预估到CheckedException的出现，比如我们操作程序去读一个文件，就可能出现FileNotFoundException，这类Exception必须要去捕获处理或抛出。\n","categories":["Java"]},{"title":"弘扬中国精神","url":"/2019/01/16/%E5%BC%98%E6%89%AC%E4%B8%AD%E5%9B%BD%E7%B2%BE%E7%A5%9E/","content":"","categories":["思修"]},{"title":"思修-绪论","url":"/2019/01/06/%E6%80%9D%E4%BF%AE-%E7%BB%AA%E8%AE%BA/","content":"\n\n"},{"title":"快速排序","url":"/2020/11/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"学C语言的时候经常用库函数qsort，学数据结构的时候知道qsort是怎么一回事儿了，数据结构期末考试有一道题就是写快排的算法，当时很熟悉，但很久不用就忘了，再写一遍加深印象。\n\n\npublic class Main &#123;    public static void main(String[] args) &#123;        int[] nums = randomArray(100);        System.out.println(&quot;排序前：&quot; + Arrays.toString(nums));        qSort(nums);        System.out.println(&quot;排序后：&quot; + Arrays.toString(nums));    &#125;    private static void qSort(int[] nums) &#123;        qSort(nums, 0, nums.length - 1);    &#125;    private static void qSort(int[] nums, int left, int right) &#123;        if (left &gt;= right) &#123;            return;        &#125;        // 一趟快速排序        int std = order(nums, left, right);        qSort(nums, left, std - 1);        qSort(nums, std + 1, right);    &#125;    // 交换数组中两个元素    private static void swap(int[] nums, int index1, int index2) &#123;        int tmp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = tmp;    &#125;    // 一趟快速排序    private static int order(int[] nums, int left, int right) &#123;        int std = left;        int l = left + 1, r = right;        boolean flag = false;        while (l &lt;= r) &#123;            // &lt;----            if (flag) &#123;                if (nums[std] &lt; nums[l]) &#123;                    swap(nums, std, l);                    flag = false;                    std = l;                &#125;                l++;            &#125; else &#123; // ----&gt;                if (nums[std] &gt; nums[r]) &#123;                    swap(nums, std, r);                    flag = true;                    std = r;                &#125;                r--;            &#125;        &#125;        return std;    &#125;    private static int[] randomArray(int length) &#123;        int[] nums = new int[length];        for (int i = 0; i &lt; nums.length; i++) &#123;            nums[i] = (int) (Math.random() * 100);        &#125;        return nums;    &#125;&#125;\n\n核心是一趟快速排序的算法，如果选择第一个元素作为参考，就必需先从后往前对比交换位置，举个栗子：\n如果序列是：【5， 6， 4， 2】，先从左往右对比交换：\n\n第一次：5和6对比，不做变化。\n第二次：5和4对比，交换位置。【4，6， 5，2】\n第三次：换方向，5和2对比，交换位置。【4，6，2，5】\n\n出问题了，最大的数6没能移动到最后，这是因为5和6对比的时候5还在6的前面，而当5移动到6之后时，6已经失去了移动的机会。\n反过来，如果先从右往左，一开局5就处于一个尽可能靠后的位置，上面的情况则可以避免。\n","categories":["LeetCode"]},{"title":"找回我的blog","url":"/2025/02/09/%E6%89%BE%E5%9B%9E%E6%88%91%E7%9A%84blog/","content":"更好的备份博客3年没有更新，花了点时间查阅了hexo的使用方法，并在网盘找到了备份的博客目录，在新电脑上重新安装hexo、配置好git SSH KEY之后，我尝试再post一篇水文。\n如果没有较好的备份，快速恢复到一个能写博客的状态很难。之前通过网盘管理备份，这次我想把所有的markdown文件、hexo、next的配置都放到git仓库里。\n备份next主题从主仓中fork了新仓，将当前的文件全部上传：https://github.com/carpediemtal/hexo-theme-next\n备份hexo配置和markdown文件将hexo生成的blog文件夹作为git仓库上传，只保留配置文件和source文件夹（包含markdown）\n图床我多数文章的插图都在新浪的服务器上，但新浪也不是慈善机构，现在所有图片都无法正常访问了，我能接受花费些money让我的blog保持可访问状态，需要寻求解决方案。\n好在图片还在，并未从新浪的服务器中直接删除。参考了这篇帖子：2023 年微博图床 403 全失效，一个方法秒解决！\n"},{"title":"抽象工厂","url":"/2020/05/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","content":"抽象工厂\n含义工厂是抽象的产品也是抽象的\n\n栗子实现定义抽象工厂接口定义抽象产品接口定义代工厂定义产品作用抽象工厂模式可以让（工厂和产品的创建）同（工厂和产品的使用）相分离可以方便的切换实际工厂客户端之和抽象工厂及抽象产品打交道","categories":["Design Patterns"]},{"title":"拯救被墙的VPS","url":"/2021/04/24/%E6%8B%AF%E6%95%91%E8%A2%AB%E5%A2%99%E7%9A%84VPS/","content":"去年在搬瓦工买了一年的洛杉矶的VPS，用v2ray，注册了一个域名，开始很谨慎，用websocket伪装，用了几天，速度实在是慢。\n于是我从websocket换成了KPS协议，速度快的飞起，youtube 1080P毫无压力，A few moments later。。。。。\n被墙了。\n\n\n我付了一年的钱啊！还是dollar！\n搬瓦工换IP又要 8 dollar，但换了就不会被墙吗？\n被墙了两次，第一次的时候，感觉是试探性的墙，过了几天就恢复如初了，于是我想着第二次也能重归平静。\n但几个月过去了，从国内还是ping不同，我现在连VPS还要开代理。\n听舍友说国外有免费的CDN服务，可以拯救被墙的VPS，于是操作了一下。\n—————————- 剧情分割线 ————————————-\n拯救VPS这个网站就是大名鼎鼎的：Cloudflare | Web Performance &amp; Security\n\n\n具体操作呢，就是：\n\n注册一个CloudFlare账号\n\n选择CDN服务（选免费的那个\n\n在域名提供商（我是namesilo）那里修改 name server：clint.ns.cloudflare.com，liberty.ns.cloudflare.com\n\n\n这些操作完成后就算大功告成了，但是因为DNS有缓存，所以要等上那么几个小时才会生效。\n再ping一次！\n\n发现域名指向的ip已经变啦，就是延迟。。。也太大了\nCDN的原理域名解析解析域名分为两种：\n\n将一个域名解析为一个IP地址\n将一个域名解析为另外一个域名（CNAME）\n\n域名解析，实际上就是解析出指定域名所对应的IP地址，或者该域名的一个CNAME。\n在域名服务商那里改变name server之后，域名指向了CDN服务商的服务器，于是CDN服务器就充当了一个代理的角色，而这个代理人是自由的，不受墙的束缚。\n","categories":["Experience"]},{"title":"放大电路分析","url":"/2019/12/24/%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/","content":"","categories":["模电"]},{"title":"排序算法","url":"/2020/12/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"\n\n\n比较类交换类bubbleSort\n梦开始的地方\n\n\nJava\n\npublic void bubbleSort(int[] nums) &#123;      for (int i = 0; i &lt; nums.length; i++) &#123;          for (int j = 1; j &lt; nums.length - i - 1; j++) &#123;              if (nums[j] &lt; nums[j - 1]) &#123;                  swap(nums, j, j - 1);              &#125;          &#125;      &#125;  &#125;\n\n\nGo\n\nfunc bucketSort(nums []int) &#123;   buckets := make([][]int, 10)   for _, v := range nums &#123;      buckets[v/10] = append(buckets[v/10], v)   &#125;   index := 0   for i := range buckets &#123;      sort.Ints(buckets[i])      for _, v := range buckets[i] &#123;         nums[index] = v         index++      &#125;   &#125;&#125;\n\nquickSort我写的两个版本具体实现上稍微有些差别，但整体思路并无区别\n\nJava\n\npublic void quickSort(int[] nums) &#123;    quickSort(nums, 0, nums.length - 1);&#125;private void quickSort(int[] nums, int start, int end) &#123;    if (start &gt;= end) &#123;        return;    &#125;    int pivot = partition(nums, start, end);    quickSort(nums, start, pivot);    quickSort(nums, pivot + 1, end);&#125;private int partition(int[] nums, int start, int end) &#123;    int pivot = start++;    boolean flag = false;    while (start &lt;= end) &#123;        if (flag) &#123;            if (nums[pivot] &lt; nums[start]) &#123;                swap(nums, pivot, start);                flag = false;                pivot = start;            &#125;            start++;        &#125; else &#123;            if (nums[pivot] &gt; nums[end]) &#123;                swap(nums, pivot, end);                flag = true;                pivot = end;            &#125;            end--;        &#125;    &#125;    return pivot;&#125;\n\n\nGo\nGo虽然没有overload，但切片使得Go的快排更胜一筹\n\n\n// 美如画的快排func quickSort(nums []int) &#123;   if len(nums) &lt; 2 &#123;      return   &#125;   left, right := 0, len(nums)-1   pivot := nums[right]   for i := range nums &#123;      if nums[i] &lt; pivot &#123;         nums[i], nums[left] = nums[left], nums[i]         left++      &#125;   &#125;   nums[left], nums[right] = nums[right], nums[left]   quickSort(nums[:left])   quickSort(nums[left+1:])&#125;\n\n插入类insertionSort\nJava\n\npublic void insertionSort(int[] nums) &#123;    for (int i = 1; i &lt; nums.length; i++) &#123;        for (int j = i; j &gt; 0; j--) &#123;            if (nums[j] &lt; nums[j - 1]) &#123;                swap(nums, j, j - 1);            &#125; else &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\nGo\n\nfunc insertionSort(nums []int) &#123;   for i := 1; i &lt; len(nums); i++ &#123;      for j := i; j &gt; 0; j-- &#123;         if nums[j] &lt; nums[j-1] &#123;            nums[j-1], nums[j] = nums[j], nums[j-1]         &#125; else &#123;            break         &#125;      &#125;   &#125;&#125;\n\nshellSort\nShellSort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of shellSort is to allow exchange of far items. \n\n\nJava\n\npublic void shellSort(int[] nums) &#123;    for (int step = nums.length / 2; step &gt; 0; step /= 2) &#123;        for (int i = step; i &lt; nums.length; i++) &#123;            for (int j = i; j - step &gt;= 0; j -= step) &#123;                if (nums[j] &lt; nums[j - step]) &#123;                    swap(nums, j, j - step);                &#125;            &#125;        &#125;    &#125;&#125;\n\n\nGo\n\n// 希尔排序（Shell sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法func shellSort(nums []int) &#123;   for step := len(nums) / 2; step &gt; 0; step /= 2 &#123;      for i := step; i &lt; len(nums); i++ &#123;         for j := i; j-step &gt;= 0; j -= step &#123;            if nums[j] &lt; nums[j-step] &#123;               nums[j], nums[j-step] = nums[j-step], nums[j]            &#125; else &#123;               break            &#125;         &#125;      &#125;   &#125;&#125;\n\n选择类selectionSort\nJava\n\npublic void selectionSort(int[] nums) &#123;    for (int i = 0; i &lt; nums.length; i++) &#123;        int min = nums[i];        for (int j = i + 1; j &lt; nums.length; j++) &#123;            if (nums[j] &lt; min) &#123;                min = nums[j];                swap(nums, i, j);            &#125;        &#125;    &#125;&#125;\n\nheapSort\nA complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible \nA Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called as max heap and the latter is called min-heap. The heap can be represented by a binary tree or array.\nHeap Sort Algorithm for sorting in increasing order:1. Build a max heap from the input data.2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of the tree.3. Repeat step 2 while size of heap is greater than 1.\n\n\nJava\n\npublic void heapSort(int[] nums) &#123;    for (int i = (nums.length / 2) - 1; i &gt;= 0; i--) &#123;        sink(nums, i, nums.length);    &#125;    int last = nums.length - 1;    while (last &gt; 0) &#123;        swap(nums, 0, last);        last--;        sink(nums, 0, last + 1);    &#125;&#125;private void sink(int[] nums, int rootIndex, int length) &#123;    // 如果该节点有两颗子树    if (rootIndex * 2 + 2 &lt;= length - 1) &#123;        int left = rootIndex * 2 + 1;        int right = left + 1;        if (nums[rootIndex] &gt; Math.max(nums[left], nums[right])) &#123;            return;        &#125;        if (nums[left] &lt; nums[right]) &#123;            swap(nums, rootIndex, right);            sink(nums, right, length);        &#125; else &#123;            swap(nums, rootIndex, left);            sink(nums, left, length);        &#125;        return;    &#125;    // 如果只有左子树    if (rootIndex * 2 + 1 &lt;= length - 1) &#123;        int left = rootIndex * 2 + 1;        if (nums[rootIndex] &lt; nums[left]) &#123;            swap(nums, rootIndex, left);        &#125;    &#125;&#125;\n\n\nGo\n\n// 美如画的堆排序func headSort(nums []int) &#123;   // build max-heap   for i := len(nums)/2 - 1; i &gt;= 0; i-- &#123;      sink(nums, len(nums), i)   &#125;   // extract element from heap   for i := len(nums) - 1; i &gt; 0; i-- &#123;      nums[0], nums[i] = nums[i], nums[0]      sink(nums, i, 0)   &#125;&#125;func sink(nums []int, size, index int) &#123;\tmaxIdx := index\tleft, right := 2*index+1, 2*index+2\tif left &lt; size &amp;&amp; nums[left] &gt; nums[maxIdx] &#123;\t\tmaxIdx = left\t&#125;\tif right &lt; size &amp;&amp; nums[right] &gt; nums[maxIdx] &#123;\t\tmaxIdx = right\t&#125;\tif maxIdx != index &#123;\t\tnums[maxIdx], nums[index] = nums[index], nums[maxIdx]\t\t// now nums[maxIdx] is the smallest one of the three\t\tsink(nums, size, maxIdx)\t&#125;&#125;\n\n归并类mergeSort\nJava\n\npublic void mergeSort(int[] nums) &#123;    mergeSort(nums, 0, nums.length - 1, new int[nums.length]);&#125;private void mergeSort(int[] nums, int start, int end, int[] tmp) &#123;    if (start &gt;= end) &#123;        return;    &#125;    int mid = (start + end) / 2;    mergeSort(nums, start, mid, tmp);    mergeSort(nums, mid + 1, end, tmp);    merge(nums, start, mid, mid + 1, end, tmp);&#125;private void merge(int[] nums, int left1, int right1, int left2, int right2, int[] tmp) &#123;    int start = left1;    int index = left1;    while (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2) &#123;        if (nums[left1] &lt;= nums[left2]) &#123;            tmp[index] = nums[left1++];        &#125; else &#123;            tmp[index] = nums[left2++];        &#125;        index++;    &#125;    for (int i = left1; i &lt;= right1; i++) &#123;        tmp[index++] = nums[i];    &#125;    for (int i = left2; i &lt;= right2; i++) &#123;        tmp[index++] = nums[i];    &#125;    System.arraycopy(tmp, start, nums, start, right2 + 1 - start);&#125;\n\n\nGo\n\n切片被玩穿了啊\n// 有点丑陋的归并排序func mergeSort(nums []int) &#123;   n := len(nums)   if n == 1 &#123;      return   &#125;   mid := n / 2   left, right := make([]int, mid), make([]int, n-mid)   copy(left, nums[:mid])   copy(right, nums[mid:])   mergeSort(left)   mergeSort(right)   merge(left, right, nums)&#125;func merge(left, right, res []int) &#123;   var i int   for i = 0; len(left) &gt; 0 &amp;&amp; len(right) &gt; 0; i++ &#123;      if left[0] &lt; right[0] &#123;         res[i] = left[0]         left = left[1:]      &#125; else &#123;         res[i] = right[0]         right = right[1:]      &#125;   &#125;   for _, v := range left &#123;      res[i] = v      i++   &#125;   for _, v := range right &#123;      res[i] = v      i++   &#125;&#125;\n\n\n复杂度\n时间复杂度：O（nlogn）\n空间复杂度：O（n），非原地排序\n\n\n非比较类countingSort\nJava\n\npublic void countingSort(int[] nums) &#123;    var max = Arrays.stream(nums).max().getAsInt();    var min = Arrays.stream(nums).min().getAsInt();    int[] cnt = new int[max - min + 1];    for (int num : nums) &#123;        cnt[num - min]++;    &#125;    int index = 0;    for (int i = 0; i &lt; cnt.length; i++) &#123;        for (int j = 0; j &lt; cnt[i]; j++) &#123;            nums[index++] = i + min;        &#125;    &#125;&#125;\n\n\nGo\nfunc countingSort(nums []int) &#123;   var min, max int   for i, v := range nums &#123;      if i == 0 || min &gt; v &#123;         min = v      &#125;      if i == 0 || max &lt; v &#123;         max = v      &#125;   &#125;   cnt := make([]int, max-min+1)   for _, v := range nums &#123;      cnt[v-min]++   &#125;   index := 0   for i, v := range cnt &#123;      for j := 0; j &lt; v; j++ &#123;         nums[index] = i + min         index++      &#125;   &#125;&#125;\n\nbucketSort\nJava\n\npublic void bucketSort(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10; i++) &#123;        buckets.add(new ArrayList&lt;&gt;());    &#125;    for (int num : nums) &#123;        buckets.get(num / 10).add(num);    &#125;    int index = 0;    for (var bucket : buckets) &#123;        bucket.sort(Integer::compare);        for (int num : bucket) &#123;            nums[index++] = num;        &#125;    &#125;&#125;\n\n\nGo\nfunc bucketSort(nums []int) &#123;   buckets := make([][]int, 10)   for _, v := range nums &#123;      buckets[v/10] = append(buckets[v/10], v)   &#125;   index := 0   for i := range buckets &#123;      sort.Ints(buckets[i])      for _, v := range buckets[i] &#123;         nums[index] = v         index++      &#125;   &#125;&#125;\n\nradixSort\nJava\n\npublic void radixSort(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10; i++) &#123;        buckets.add(new ArrayList&lt;&gt;());    &#125;    int div = 1, mod = 10;    int length = Integer.toString(Arrays.stream(nums).max().getAsInt()).length();    for (int i = 0; i &lt; length; i++) &#123;        for (int num : nums) &#123;            buckets.get(num % mod / div).add(num);        &#125;        div *= 10;        mod *= 10;        int index = 0;        for (var bucket : buckets) &#123;            for (int num : bucket) &#123;                nums[index++] = num;            &#125;            bucket.clear();        &#125;    &#125;&#125;\n\n\nGo\n\nfunc radixSort(nums []int) &#123;   // how many digits does the max num has?   var max int   for i, v := range nums &#123;      if i == 0 || max &lt; v &#123;         max = v      &#125;   &#125;   maxLen := len(strconv.Itoa(max))   div, mod := 1, 10   for i := 0; i &lt; maxLen; i++ &#123;      buckets := make([][]int, 10)      for _, v := range nums &#123;         buckets[v%mod/div] = append(buckets[v%mod/div], v)      &#125;      div *= 10      mod *= 10      index := 0      for _, bucket := range buckets &#123;         for _, num := range bucket &#123;            nums[index] = num            index++         &#125;      &#125;   &#125;&#125;\n\nAssemblepublic class Main &#123;    public static void main(String[] args) &#123;        var sort = new Sort();        var nums = sort.randomArray();        System.out.println(Arrays.toString(nums));//        sort.bubbleSort(nums);//        sort.selectionSort(nums);//        sort.insertionSort(nums);//        sort.shellSort(nums);//        sort.mergeSort(nums);//        sort.quickSort(nums);//        sort.heapSort(nums);//        sort.countingSort(nums);//        sort.bucketSort(nums);//        sort.radixSort(nums);        System.out.println(Arrays.toString(nums));    &#125;&#125;\n\n\n\nclass Sort &#123;    public void bubbleSort(int[] nums) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            for (int j = 1; j &lt; nums.length - i - 1; j++) &#123;                if (nums[j] &lt; nums[j - 1]) &#123;                    swap(nums, j, j - 1);                &#125;            &#125;        &#125;    &#125;    public void selectionSort(int[] nums) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            int min = nums[i];            for (int j = i + 1; j &lt; nums.length; j++) &#123;                if (nums[j] &lt; min) &#123;                    min = nums[j];                    swap(nums, i, j);                &#125;            &#125;        &#125;    &#125;    public void insertionSort(int[] nums) &#123;        for (int i = 1; i &lt; nums.length; i++) &#123;            for (int j = i; j &gt; 0; j--) &#123;                if (nums[j] &lt; nums[j - 1]) &#123;                    swap(nums, j, j - 1);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    public void shellSort(int[] nums) &#123;        for (int step = nums.length / 2; step &gt; 0; step /= 2) &#123;            for (int i = step; i &lt; nums.length; i++) &#123;                for (int j = i; j - step &gt;= 0; j -= step) &#123;                    if (nums[j] &lt; nums[j - step]) &#123;                        swap(nums, j, j - step);                    &#125;                &#125;            &#125;        &#125;    &#125;    ////////////////////////////////////////////////////////    public void mergeSort(int[] nums) &#123;        mergeSort(nums, 0, nums.length - 1, new int[nums.length]);    &#125;    private void mergeSort(int[] nums, int start, int end, int[] tmp) &#123;        if (start &gt;= end) &#123;            return;        &#125;        int mid = (start + end) / 2;        mergeSort(nums, start, mid, tmp);        mergeSort(nums, mid + 1, end, tmp);        merge(nums, start, mid, mid + 1, end, tmp);    &#125;    private void merge(int[] nums, int left1, int right1, int left2, int right2, int[] tmp) &#123;        int start = left1;        int index = left1;        while (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2) &#123;            if (nums[left1] &lt;= nums[left2]) &#123;                tmp[index] = nums[left1++];            &#125; else &#123;                tmp[index] = nums[left2++];            &#125;            index++;        &#125;        for (int i = left1; i &lt;= right1; i++) &#123;            tmp[index++] = nums[i];        &#125;        for (int i = left2; i &lt;= right2; i++) &#123;            tmp[index++] = nums[i];        &#125;        System.arraycopy(tmp, start, nums, start, right2 + 1 - start);    &#125;    ////////////////////////////////////////////////////////    public void quickSort(int[] nums) &#123;        quickSort(nums, 0, nums.length - 1);    &#125;    private void quickSort(int[] nums, int start, int end) &#123;        if (start &gt;= end) &#123;            return;        &#125;        int pivot = partition(nums, start, end);        quickSort(nums, start, pivot);        quickSort(nums, pivot + 1, end);    &#125;    private int partition(int[] nums, int start, int end) &#123;        int pivot = start++;        boolean flag = false;        while (start &lt;= end) &#123;            if (flag) &#123;                if (nums[pivot] &lt; nums[start]) &#123;                    swap(nums, pivot, start);                    flag = false;                    pivot = start;                &#125;                start++;            &#125; else &#123;                if (nums[pivot] &gt; nums[end]) &#123;                    swap(nums, pivot, end);                    flag = true;                    pivot = end;                &#125;                end--;            &#125;        &#125;        return pivot;    &#125;    ////////////////////////////////////////////////////////    public void heapSort(int[] nums) &#123;        for (int i = (nums.length / 2) - 1; i &gt;= 0; i--) &#123;            sink(nums, i, nums.length);        &#125;        int last = nums.length - 1;        while (last &gt; 0) &#123;            swap(nums, 0, last);            last--;            sink(nums, 0, last + 1);        &#125;    &#125;    private void sink(int[] nums, int rootIndex, int length) &#123;        // 如果该节点有两颗子树        if (rootIndex * 2 + 2 &lt;= length - 1) &#123;            int left = rootIndex * 2 + 1;            int right = left + 1;            if (nums[rootIndex] &gt; Math.max(nums[left], nums[right])) &#123;                return;            &#125;            if (nums[left] &lt; nums[right]) &#123;                swap(nums, rootIndex, right);                sink(nums, right, length);            &#125; else &#123;                swap(nums, rootIndex, left);                sink(nums, left, length);            &#125;            return;        &#125;        // 如果只有左子树        if (rootIndex * 2 + 1 &lt;= length - 1) &#123;            int left = rootIndex * 2 + 1;            if (nums[rootIndex] &lt; nums[left]) &#123;                swap(nums, rootIndex, left);            &#125;        &#125;    &#125;    ////////////////////////////////////////////////////////    public void countingSort(int[] nums) &#123;        var max = Arrays.stream(nums).max().getAsInt();        var min = Arrays.stream(nums).min().getAsInt();        int[] cnt = new int[max - min + 1];        for (int num : nums) &#123;            cnt[num - min]++;        &#125;        int index = 0;        for (int i = 0; i &lt; cnt.length; i++) &#123;            for (int j = 0; j &lt; cnt[i]; j++) &#123;                nums[index++] = i + min;            &#125;        &#125;    &#125;    public void bucketSort(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            buckets.add(new ArrayList&lt;&gt;());        &#125;        for (int num : nums) &#123;            buckets.get(num / 10).add(num);        &#125;        int index = 0;        for (var bucket : buckets) &#123;            bucket.sort(Integer::compare);            for (int num : bucket) &#123;                nums[index++] = num;            &#125;        &#125;    &#125;    public void radixSort(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            buckets.add(new ArrayList&lt;&gt;());        &#125;        int div = 1, mod = 10;        int length = Integer.toString(Arrays.stream(nums).max().getAsInt()).length();        for (int i = 0; i &lt; length; i++) &#123;            for (int num : nums) &#123;                buckets.get(num % mod / div).add(num);            &#125;            div *= 10;            mod *= 10;            int index = 0;            for (var bucket : buckets) &#123;                for (int num : bucket) &#123;                    nums[index++] = num;                &#125;                bucket.clear();            &#125;        &#125;    &#125;    private void swap(int[] nums, int index1, int index2) &#123;        int tmp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = tmp;    &#125;    public int[] randomArray() &#123;        int[] nums = new int[10];        for (int i = 0; i &lt; nums.length; i++) &#123;            nums[i] = (int) (Math.random() * 100);        &#125;        return nums;    &#125;&#125;","categories":["数据结构与算法"]},{"title":"数制与编码","url":"/2020/07/29/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/","content":"数制基数和权重\n优势\n\n少量数码表示较大的数\n\n\n\n\n\n分类\n二进制（B）\nbinary\n\n计算机内部数据传输\n\n\n八进制（O）\noctonary\n\n书写程序\n\n\n十进制（D）\ndEcimal\n\n优势\n\n十个指头\n\n\n劣势\n\n计算机难以表示\n\n\n人机界面\n\n\n\n十六进制（H）\nhex\n\n书写程序\n\n\n\n转换\n其它转化为十进制\n\n权重展开法\n\n\n十进制转化为其它进制\n\n整数部分\n\n基数连除取余\n\n栗子\n8（D）&#x3D;1000（B）&#x3D;x12^3 +x22^2+x32^1+x42^0\n\n\n\n\n\n纯小数部分\n\n基数连乘取整\n\n\n\n\n二进制转化为八进制或十六进制\n\n思想\n\n三位二进制 &#x3D; 一位八进制\n四位二进制 &#x3D; 一位\n\n\n整数部分\n\n左边补0\n\n\n纯小数部分\n\n右边补0\n\n\n\n\n八进制或十六进制转化为二进制\n\n思想\n\n三位二进制 &#x3D; 一位八进制\n四位二进制 &#x3D; 一位\n\n\n整数部分\n\n每位数字转化为二进制\n\n\n小数部分\n\n每位数字转化为二进制\n\n\n\n\n\n编码BCD码binary code decimal\n\n常用\n\n8421\n\n5421\n某些数的表示不唯一\n\n2421\n\n余3\n\n\n\nBCD与十进制的转换\n\nreplace\n\n\nBCD之间的转换\n\n中间量：十进制\n\n\n劣势\n\n过程中有错码\n\n\n\n可靠性编码\n优势\n\n变化少\n\n\n格雷码\n\n规律\n\n相邻的数只有一位不同\n\n\n二进制转格雷码\n\n最高位\n\n与二进制相同\n\n\n低位\n\n从右向左一次进行异或运算\n\n\n\n\n\n\n\n奇偶校验码\n信息位\n\n原始数据\n\n\n校验位\n使原始数据各位数之和为奇数的称为奇校验码，偶数称为偶校验码\n\n1或0\n\n\n特点\n\n只能检测奇数个错误\n\n\n\n","categories":["数电"]},{"title":"数据库索引","url":"/2021/04/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/","content":"\n\n\n\nB树计算机科学中，B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。\nB+树B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。\nB+ 树在节点访问时间远远超过节点内部访问时间的时候，比可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。这种价值得以确立通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。\n\n\n平衡树平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。\n不平衡的树结构，在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。\n","categories":["数据库"]},{"title":"调用/返回体系结构风格","url":"/2021/03/23/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC/","content":"","categories":["软件体系结构"]},{"title":"数据流体系风格","url":"/2021/03/21/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC/","content":"\n\n\n\n数据流体系结构风格定义\nthe availability of data controls the computation\n\nthe structure of the design is decided by orderly motion of data from process to process\n\nin a pure data flow system, there is no other interaction between processes\n\n\n组成基本构件：处理\n作用\n\n数据处理\n\n\n接口\n\n输入输出端口\n\n\n计算模型\n\n输入端口读数，经过计算，写到输出端口\n\n\n\n连接件：数据流\n作用\n\n传递数据流\n\n\n特点\n\n单向\n异步\n有缓冲\n\n\n接口\n\nreader\nwriter\n\n\n计算模型\n\n构件A的输出\n构件B的输入\n\n\n\n分类批处理体系结构风格\n定义\n\n基本构件：独立的应用程序\n连接件：某种类型的媒质\n连接件定义了相应的数据流图，表达拓扑结构\n每个处理步骤是一个独立的程序\n每一步必须在前一步结束后才能开始\n数据必须是完整的，以整体的方式传递\n\n\n特点\n\n整体传递数据\n构件粒度大\n延迟高，实时性差\n无并发（应该说的是构件之间）\n\n\n栗子\n\n相似代码检测\n\n\n\n管道-过滤器体系结构风格\n场景\n\n数据源源不断的产生\n\n\n定义\n\n把系统分解为几个连贯的通过数据流连接的处理步骤\n递增的读取和消费数据流\n\n\n组成\n\n构件：过滤器\n\n作用\n\n将源数据变换成目标数据\n\n\n变换类型\n\n增删\n改类型\n分解、合并数据流\n\n\n特点：独立\n\n无上下文信息\n不保留状态\n不感知其它过滤器\n\n\n\n\n连接件：管道\n\n单向传输\n\n\n\n\n优势\n\n构件粒度小\n高内聚、低耦合\n软件复用\n并行执行\n\n\n劣势\n\n格式转换\n不适合处理交互的应用？？\n\n\n栗子\n\npipe and filter\n编译器\nUnix pipes\nImage processing\n\n\n\n过程控制","categories":["软件体系结构"]},{"title":"数码","url":"/2020/07/20/%E6%95%B0%E7%A0%81/","content":"原码存在意义&#x2F;功能\n数据在计算机中的一种表示\n数据要存储在计算机里, 然而计算机只有0和1, 没法存十进制, 也没法存正负号, 所以用一个bit表示正负, 剩下的表示数值.如此而已\n\n\n\n\n组成\n符号位\n\n二进制数\n\n1为负\n0为正\n\n\n\n反码存在意义&#x2F;功能\n或许是为补码做铺垫吧,idk\n\n与原码的关系\n原码为正\n\n反码与原码相同\n\n\n原码为负\n\n符号位不变\n\n数值部分按位取反\n按位取反：对于每一位：0变1,1变0\n\n\n\n\n补码存在意义&#x2F;功能\n减法变加法\n\nhow：存在一个类似周期的东西, 就如正弦函数, 向右走, 可以获得一个函数值, 向左走, 也可以获得相同的函数值.\n\n\n\n与反码的关系\n原码为正\n\n补码和反码相同\n\n\n原码为负\n\n补码 &#x3D; 反码末位加1\nmistake：反码加1是数值为加1, 也就是说，如果不进位到符号位solution ：反码加1如有必要，需要进位的符号位\n末位加1 不是 加1\n\n\n\n\n数小数\n纯小数&#x2F;定点小数\n\n整数位为0\n\n\n带小数\n\n整数位不为0\n\n\n\n","categories":["计组"]},{"title":"新浪图床问题","url":"/2021/03/05/%E6%96%B0%E6%B5%AA%E5%9B%BE%E5%BA%8A%E9%97%AE%E9%A2%98/","content":"因为家境贫寒用不起收费的图床，所以一直在用新浪图床。\n起初非常好用，后来白嫖的人太多了，新浪采取了一些措施，很多网站访问新浪图片都会403，但是github和gitee提供的page还能正常用，但到了现在，都没法用了。\n有个简单的方法是，在&lt;head&gt;标签内加上&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;。\n我使用的博客框架是hexo，只需要修改html模板就可以了，路径是：/themes/your_theme/layout/_partials/head.swig\n\n\n添加meta标签，就大功告成了。\n还有个方法是给所有的img标签加上referrerpolicy=”no-referrer”属性，可以写个脚本正则匹配，批处理一下，但是我的md里还有markdown格式的图片链接，有些麻烦。\n","categories":["Experience"]},{"title":"明大德守公德严私德","url":"/2019/01/16/%E6%98%8E%E5%A4%A7%E5%BE%B7%E5%AE%88%E5%85%AC%E5%BE%B7%E4%B8%A5%E7%A7%81%E5%BE%B7/","content":"","categories":["思修"]},{"title":"模电-map","url":"/2019/11/14/%E6%A8%A1%E7%94%B5-map/","content":"","categories":["模电"]},{"title":"更换hexo网页图标","url":"/2019/10/01/%E6%9B%B4%E6%8D%A2hexo%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87/","content":"网页图标就像是网页的头像，比如说百度的熊掌。next主题默认的网页图标是“N”，怎样改变图标呢？\n\n\n需要的东西\n心仪的图片\n\n\n2. 能把一般图片转为favicon.ico的工具  \n可以用Photoshop或者在线工具（http://www.faviconico.org/favicon）将图片转为favicon.ico\n\n操作步骤把生成好的图标文件移动到themes\\next\\source\\images目录下，打开主题的_config.iml文件，修改favicon-&gt;small和medium为图标的目录，保存退出，大功告成。效果：\n","categories":["Experience"]},{"title":"洋务运动","url":"/2019/06/14/%E6%B4%8B%E5%8A%A1%E8%BF%90%E5%8A%A8/","content":"\n\n\n\n洋务运动洋务事业的兴办洋务\n洋\n\n海洋\n之前称夷\n\n\n\n日不落帝国\n管理\n\n成本\n\n\n长跑\n\n\n洋务派\n皇族\n\n恭亲王奕䜣\n军机大臣文祥\n\n\n官员\n\n曾国潘\n李鸿章\n左宗棠\n张之洞\n\n\n士人\n\n著书立说\n\n\n\n指导思想\n中体西用\n\n统治者\n光绪帝\n\n慈禧\n\n保守\n\n\n\n\n明治天皇\n\n有权利\n长期向别人学习\n\n\n\n洋务事业的展开\n第一阶段\n\n自强\n\n军事工业\n\n造枪造炮造轮船\n\n\n武化\n\n\n\n\n\n第二阶段\n\n求富\n\n民用工业\n\n配合军事工业\n与洋人争利\n\n\n\n\n\n\n人才\n\n新式学堂与留学生\n翻译\nSubtopic 3\n军事\n海外培训\n\n\n\n洋务运动的失败标志\n马关条约\n\n历史作用\n积极方面\n\n早期工业\n\n民族资本主义\n\n近代教育\n\n人才\n\n\n传统观念和社会风气\n\n\n\n\n失败原因\n封建性\n\n指导思想\n\n中体西用\n\n\n根本宗旨\n\n维护满清统治\n\n\n开展方式\n\n官方主导\n\n制度束缚\n\n\n\n\n\n\n依赖性\n\n腐朽性\n\n政治经济制度未改\n企业同于封建衙门\n官员视办厂为肥缺\n\n\n\n","categories":["近代史"]},{"title":"电路中的基本物理量","url":"/2019/08/30/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F/","content":"","categories":["模电"]},{"title":"程序设计大作业之实验室管理系统","url":"/2020/10/20/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"功能介绍该系统有三种类型的用户：\n\n管理员\n实验员\n学生\n\n不同用户拥有不同的功能：\n\n管理员的功能主要有：实验课程管理（增删课程），实验课程安排（给某个的班级安排某个课程）\n实验员的功能：给自己负责的学生登入实验成绩\n学生的功能：课程查询（查看自己被安排了什么课），成绩查询（查询课程的成绩，如果未录入就查不到）\n\n页面设计主要设计了8个页面，展示一部分：\n\n&#x2F;index：主页面\n&#x2F;sign_in：登录页面\n&#x2F;profile：个人信息及功能页面（不同类型的用户有不同的展示）\n&#x2F;score_query：学生的成绩查询页面\n&#x2F;course_query：学生的课程查询页面\n&#x2F;record_score：实验员的录入成绩页面\n&#x2F;lab_management：管理员的实验课程管理页面\n&#x2F;lab_arrangement：管理员的实验课程安排页面\n\n数据库设计数据库使用MySQL，一共设计了六张表：\n\nadministrator\ncreate table administrator(    name     varchar(100) not null,    email    varchar(100) not null,    password varchar(100) not null,    constraint administrator_email_uindex        unique (email));alter table administrator    add primary key (email);\n\nexperimenter\ncreate table experimenter(    name     varchar(100) not null,    email    varchar(100) not null,    password varchar(100) not null,    constraint experimenter_email_uindex        unique (email));alter table experimenter    add primary key (email);\n\nstudent\ncreate table student(    id       varchar(100)                  not null,    name     varchar(100)                  not null,    email    varchar(100)                  not null,    _class   varchar(100)                  not null,    password varchar(100) default &#x27;123456&#x27; not null,    constraint student_email_uindex        unique (email),    constraint student_id_uindex        unique (id));alter table student    add primary key (id);\n\ncourses\ncreate table courses(    id           int auto_increment,    name         varchar(100) not null,    time         varchar(100) not null,    week         varchar(100) not null,    level        varchar(100) not null,    experimenter varchar(100) not null,    constraint courses_id_uindex        unique (id),    constraint courses_name_uindex        unique (name));alter table courses    add primary key (id);\n\nstudent_score\ncreate table student_score(    id         int auto_increment        primary key,    student_id varchar(100)  not null,    course_id  int           not null,    score      int default 0 null);\n\nclass_course\ncreate table class_course(    id        int auto_increment        primary key,    _class    varchar(100) not null,    course_id int          null);\n\n文件结构├─lab-management-system│  ├─.idea│  │  ├─codeStyles│  │  ├─dataSources│  │  │  └─0921148a-a36a-438f-93b9-aa568804f41d│  │  │      └─storage_v2│  │  │          └─_src_│  │  │              └─schema│  │  └─libraries│  ├─.mvn│  │  └─wrapper│  ├─src│  │  ├─main│  │  │  ├─java│  │  │  │  └─eternal│  │  │  │      └─fire│  │  │  │          ├─controller│  │  │  │          ├─entity│  │  │  │          └─service│  │  │  └─resources│  │  │      ├─static│  │  │      └─templates│  │  └─test│  │      └─java│  │          └─eternal│  │              └─fire│  └─target│      ├─classes│      │  ├─eternal│      │  │  └─fire│      │  │      ├─controller│      │  │      ├─entity│      │  │      └─service│      │  ├─static│      │  └─templates│      ├─generated-sources│      │  └─annotations│      ├─generated-test-sources│      │  └─test-annotations│      └─test-classes│          └─eternal│              └─fire\n\n\n\n用到的技术\nSpring Boot + Thyme Leaf + JDBC +MySQL\nHTML + CSS + JS + Bootstrap + Vue.js + Font Awesome\n\n","categories":["Java"]},{"title":"系统交付","url":"/2020/08/20/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BB%98/","content":"\n文档的定义和类型\nConsider the audience考虑读者\n\nUser manual用户手册\n\nSystem purpose or objectives系统目的或宗旨\n\nSystem capabilities and functions系统的性能与功能\n\nSystem features, characteristics, advantages系统特点、特征和优点\n\nOperator manual操作员手册\n\nGeneral system guide系统概况\n\nTutorials and automated overviews指南与自动的系统纵览\n\nProgrammer guide程序员指南\n\n\n\n\n培训类型User training用户培训Operator training操作员培训Special training needs特别培训需求\ninfrequent vs frequent\nnew users vs brush-up users\n\n文档\n图标和在线帮助\n\n演示与分类\n\n专家用户\n\n\n","categories":["软件工程概论"]},{"title":"用添加maven依赖项的方式引入JavaFX","url":"/2020/07/30/%E7%94%A8%E6%B7%BB%E5%8A%A0maven%E4%BE%9D%E8%B5%96%E9%A1%B9%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E5%85%A5JavaFX/","content":"并不是所有java项目都需要GUI，所以JavaFX在jdk11之后已经被移除了，现在需要手动添加。\n要使用JavaFX，一种方式是下载JavaFX的SDK，并做相关配置。\n另一种是通过添加maven依赖项，JavaFX的SDK里面其实也就几个jar包。\n\n\n只要通过Maven导入这些jar包即可使用JavaFX。\n\n\nmaven依赖项&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;    &lt;version&gt;14.0.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-base&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-web&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-swing&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;    &lt;artifactId&gt;javafx-media&lt;/artifactId&gt;    &lt;version&gt;14.0.2&lt;/version&gt;&lt;/dependency&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.openjfx&lt;/groupId&gt;                &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;0.0.4&lt;/version&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;Main&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\n\n运行通过这种方式运行JavaFX，需要通过JavaFX的Maven插件：mvn clean javafx:run\n\n\n有比较多的依赖项需要添加，记录下来复制备用。\n虽然JavaFX并不流行，但这不能怪他太垃圾，只能说生不逢时，JavaFX本身还是能打的。\n参考https://openjfx.io/\nhttp://www.javafxchina.net/main/\n","categories":["Java"]},{"title":"矩阵链乘积","url":"/2021/04/19/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E7%A7%AF/","content":"矩阵链乘积（英语：Matrix chain multiplication，或Matrix Chain Ordering Problem，MCOP）是可用动态规划解决的最佳化问题。给定一序列矩阵，期望求出相乘这些矩阵的最有效方法。此问题并不是真的去执行其乘法，而只是决定执行乘法的顺序而已。\n因为矩阵乘法具有结合律，所有其运算顺序有很多种选择。换句话说，不论如何括号其乘积，最后结果都会是一样的。例如，若有四个矩阵ABCD，将可以有：\nABCD&#x3D;(AB)(CD)&#x3D;A(BCD)&#x3D;A(BC)D&#x3D;…\n但括号其乘积的顺序是会影响到需计算乘积所需简单算术运算的数目，即其效率。例如，设A为一10 X 30矩阵，B为30 X 5矩阵与C为5 X 60矩阵，则：\n\n\n明显地，第一种方式要有效多了。既然已确认过此问题了，那要如何决定n个矩阵相乘的最佳顺序呢？可以比较每一顺序的运算量（使用蛮力），但这将需要时间O(2n)，是一种非常慢且对大n不实在的方法。那解决方法，如我们将看到的，是将问题分成一套相关的子问题。以解答子问题一次而再使用其解答数次，即可以彻底地得出其所需时间。此一方法称为动态规划。\nN个矩阵（A1，A2，A3，，，An）链乘的最佳顺序，对于这个问题，它的子问题是什么？如何将它拆分成更小的子问题呢？\n可以将这N个矩阵分成两部分，第一部分的最佳顺序是一个子问题，第二部分的最佳顺序也是一个子问题。那这两个子问题和大问题又如何建立联系呢？\n将N个矩阵分成两部分，有多种不同的划分方法，三个矩阵链乘有2种划分方法：（AB）C和A（BC）\n我们去尝试所有的划分方法，求得每种划分方法需要的计算数，取最小的作为N个矩阵链乘的最优解。\n划分而得的两部分又可以拆分成更小的子问题，这时候动态规划就能发挥威力，我们自下而上去求解，将求得的结果存在一张表中，方便复用。\n由此可见，动态规划问题的主要求解思路就是如何寻找最优解问题的子问题，以及如何将大问题和子问题联系起来。\n\n\n一些输入：\n** Matrix-chain product. The following are some instances. \na)    &lt;3, 5, 2, 1,10&gt;\nb)    &lt;2, 7, 3, 6, 10&gt;\nc)     &lt;10, 3, 15, 12, 7, 2&gt;\nd)    &lt;7, 2, 4, 15, 20, 5&gt;\npackage mainimport (   &quot;fmt&quot;   &quot;math&quot;)const INFINITY = math.MaxInt64func main() &#123;   nums1 := []int&#123;3, 5, 2, 1, 10&#125;   //nums2 := []int&#123;2, 7, 3, 6, 10&#125;   //nums3 := []int&#123;10, 3, 15, 12, 7, 2&#125;   //nums4 := []int&#123;7, 2, 4, 15, 20, 5&#125;   MatrixChainMultiplication(nums1)   //MatrixChainMultiplication(nums2)   //MatrixChainMultiplication(nums3)   //MatrixChainMultiplication(nums4)&#125;// 输出最优解和计算次数func MatrixChainMultiplication(p []int) &#123;   // 矩阵个数为 len(p) - 1   n := len(p) - 1   // m[i][j]表示第i个矩阵到第j个矩阵进行矩阵链乘的最小计算数   m := make([][]int, n+1)   for i := range m &#123;      m[i] = make([]int, n+1)   &#125;   // s[i][j]表示使得 第i个矩阵到第j个矩阵进行矩阵链乘的计算数最小 的分割点   s := make([][]int, n+1)   for i := range s &#123;      s[i] = make([]int, n+1)   &#125;   for l := 2; l &lt;= n; l++ &#123; // l：chain length      for i := 1; i &lt;= n-l+1; i++ &#123;         j := i + l - 1         m[i][j] = INFINITY         for k := i; k &lt;= j-1; k++ &#123;            q := m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]            if q &lt; m[i][j] &#123;               m[i][j] = q               s[i][j] = k            &#125;         &#125;      &#125;   &#125;   fmt.Println(&quot;矩阵M：&quot;)   for _, v := range m &#123;      fmt.Println(v)   &#125;   fmt.Println(&quot;矩阵链乘的最小计算数：&quot;, m[1][n])   fmt.Println(&quot;----------------------&quot;)   fmt.Println(&quot;矩阵S：&quot;)   for _, v := range s &#123;      fmt.Println(v)   &#125;   fmt.Println(&quot;使得矩阵链乘计算数最小的计算次序：&quot;)   displayPriority(s, 1, n)&#125;// 根据断点位置递归的去加括号func displayPriority(s [][]int, i, j int) &#123;   if i == j &#123;      fmt.Printf(&quot;A%d&quot;, i)   &#125; else &#123;      fmt.Print(&quot;(&quot;)      displayPriority(s, i, s[i][j])      displayPriority(s, s[i][j]+1, j)      fmt.Print(&quot;)&quot;)   &#125;&#125;\n\n","categories":["数据结构与算法"]},{"title":"系统测试","url":"/2020/08/11/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/","content":"软件配置软件生存周期各个阶段活动的产物经审批后即可称之为软件配置项\n过程\nFunction Test\nPerformance Test\nAcceptance Test\nInstallation Test\n\n\n\n功能测试Cause-and-Effect Graph\nInputs\nOutputs\n\n性能测试Stress Test\ndefinition\n\nEvaluate the system when stressed to it limits over a period of time\n\n\n\nVolume Test\ndefinition\n\nAddress the handling of large amount of data  in the system.\n\n\nexample\n\nHandle up to a Stack or Queue ,if their size can accommodate all the expected data.\n\n\n\nConfiguration  Test\ndefinition\n\nAnalyze the various software and hardware configurations.\n\n\n\nCompatibility  Test\ndefinition\n\nWhen a system interface with other systems, find out whether the interface functions perform according to the requirement.\n\n\nexample\n\nThe system communicate with a large data base system, check out The speed and accuracy of data retrieval\n\n\n\nRegression  Test\nThe system is replacing an exist system.\n\nSecurity  TestTiming  TestEnvironment  TestQuality TestRecovery Test\nResponse to the presence of faults or to the loss of data\n\nMaintenance  TestDocumentation TestHuman Factor Test其他特性Reliability\ndefinition\n\nThe probability that a system will operate without failure  under given conditions for a given time interval.\n\n\nmeasure\n\nR &#x3D; MTTF&#x2F;(1+MTTF)\n\n\n\nAvailability\ndefinition\n\nThe probability that a system is operating successfully according to specification at a given point of time.\n\n\nmeasure\n\nA &#x3D; MTBF&#x2F;(1+MTBF)\n\n\n\nMaintainability\ndefinition\n\nThe probability that , for a given condition of use, a maintenance activity can be carried out within a stated time interval and using stated procedures and resources.\n\n\nmeasure\n\nM &#x3D; 1&#x2F; (1+MTTR)\n\n\n\nAcceptance TestingPurpose\nTo enable the customers and users to determine if the system We built really meets their needs and expectations.\n\nTypes\nBenchmark Test\nPilot Test\nParallel Test\n\n","categories":["软件工程概论"]},{"title":"系统维护","url":"/2020/08/20/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/","content":"类型改正性维护\n维持控制日常功能\n\n适应性维护\n维持控制系统修改\n\n完善性维护\n完善现有功能\n\n预防性维护\n防止系统性能掉到不可接受的水平\n\n\n\n可维护性的度量外部方法\n记录时间\n\nreport问题需要的时间\n由于administrative delay消耗的时间\n分析问题需要的时间\n确定进行哪种改动需要的时间\n进行改动需要的时间\n测试改动需要的时间\n记录改动需要的时间\n\n\n\n内部方法\n环路数\n\n代码中判定语句+1\n\n\n\n","categories":["软件工程概论"]},{"title":"系统设计","url":"/2020/08/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","content":"设计的定义Design is the creative process of transforming the problem into a solution, the description of the solution is call the DESIGN.\n\n\n软件体系结构的定义和要素软件体系结构&#x3D;{构件，连接件，约束}\nThree level\nArchitectrue\nCode design\nExecutable design\n\n体系结构风格与策略\nPiper-and-Filter\n\nClient-Server\n\nPeer-to-Peer\n\nPublish-Subscribe\n\nRepositories\n\nLaying\n\n\n设计特性\n独立性\n一个模块具有独立的功能，和其它模块之间没有过多的相互作用\n独立的模块容易开发，容易测试维护，有效阻断错误传播\n\n内聚与耦合\n耦合等级\n\n内容耦合\n公共耦合\n控制耦合\n标记耦合\n数据耦合\n非直接耦合\n\n\n内聚等级\n\n功能性内聚\n顺序内聚\n通信内聚\n过程内聚\n时间内聚\n逻辑内聚\n偶然内聚\n\n\n\n\n\n","categories":["软件工程概论"]},{"title":"索引","url":"/2020/12/15/%E7%B4%A2%E5%BC%95/","content":"\n\n\n索引索引是一种由原数据生成的具有特殊数据结构的数据，根据其特殊的结构，在某方面（如查找）会比无序的数据更有优势\nB+ Tree结构\nB Tree + 叶子节点的顺序访问指针\n\n操作\n查找\n\n从根节点开始，递归地二分查找\n\n\n插入\n\n插入操作后会破坏二叉树的平衡性\n通过分裂、合并、旋转来维护平衡性\n\n\n\nB+ Tree VS 红黑树\nB+ Tree树的高度更低\n磁盘寻道的次数与树高成正比，所以红黑树更耗时\n磁盘的预读不进行寻道\n\n使用的条件小的表使用全局扫描更有效中大型的表索引非常有效特大型的表，建立和维护索引的代价很大分类B+ Tree索引\n\n地位\n\nMySQL大多数存储引擎的默认索引类型\n\n\n特点\n\n无需全表扫描，只需搜索树\nB+ Tree有序，可以查找、排序、分组\n\n\nInnoDB\n\n主索引\n\n叶子节点存储数据\n\n\n辅助索引\n\n叶子节点存储主键值\n\n\n\n\n\n哈希索引\n特点\n\n查找O（1）\n无有序性，无法排序、分组\n只支持精确查找\n\n\n自适应哈希索引\n\n当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引\n\n\n\n全文索引\nMyISAM存储引擎支持全文索引，可以查找文本中的关键字（InnoDB新版本也支持）\n使用倒排索引记录着关键词到文档的映射\n\n空间数据索引优化独立的列\n索引列不能是表达式的一部分，也不能是函数的参数\n\n多列索引\n使用多列索引比使用多个单列索引性能更好\n\n索引列的顺序\n让选择性最强的索引列放在前面\n\n前缀索引\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符\n\n覆盖索引\n索引包含所有需要查询的字段的值\n\n","categories":["数据库"]},{"title":"线性代数考点","url":"/2019/08/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%80%83%E7%82%B9/","content":"\n\n\n\n\n\n线性代数考点行列式行列式的性质\n初等行变换不改变值\n\n交换行或列添负号\n\n某一行或列的公因式可以提出\n\n幂\n\n|AB|&#x3D;|A||B|\n\n伴随矩阵\n\nAA*&#x3D;A*A&#x3D;|A|E\nA*&#x3D;A^(-1)|A|\n|A*|&#x3D;|A|^(n-1)\n\n\n\n有特点的行列式\n范德蒙德行列式\n通过行列式的性质可以把一些类似行列式转化为范德蒙行列式\n行列式的性质：初等行变换不改变行列式的值每一行每一列可以提出公因式到行列式外对换两行要添负号\n\n形式\n\n行等比数列\n列等比数列\n\n\n值\n\n取决于第二行\n后面的项减前面的项的乘积\n\n\n\n\n（分块）上&#x2F;下三角行列式\n由行列式性质将一些行列式化为上下三角形分块矩阵有相同的运算规则\n\n主对角线形式\n\n行列式值为主对角线元素乘积\n\n\n辐对角线形式\n\n统计交换次数n\n行列式值为-1^n 乘主对角线元素乘积\n\n\n\n\n行和相等の行列式\n\n形式\n\n特点\n\n每一行的值相等\n\n\n操作\n\n把所有列加到第一列\n第一列按列展开得到三角行列式\n\n\n\n\n两线一星行列式\n\n形式\n\n特点\n\n两线\n\n每条线上的元素相同\n不同线上的元素可能不同\n\n\n星\n\n孤单的非零元素\n\n\n\n\n操作\n\n按星所在的行或列直接展开\n得到对角阵\n\n\n\n\nX形行列式\n\n形式\n\n特点\n\n不同颜色元素的值不同\n\n\n操作\n\n通过行列变换集齐四色龙珠召唤神龙\n\n\n公式\n\n2n阶x形行列式的值：龙珠的n次幂\n\n\n\n\n箭头形行列式\n\n形式\n\n特点\n\n每行两个元素\n\n\n操作\n\n每一列提出公因式 使每行的两个元素互为相反数\n将第一列&#x2F;最后一列化0\n得到三角行列式\n\n\n\n\n夹逼行列式\n\n形式\n\n操作\n\n加上一行一列\n变身箭头行列式\n\n\n\n\n抽象形行列式\n\n操作\n\n“正交化”\n\n\n\n\n\n求逆矩阵一般矩阵\n初等变换法\n\n对角矩阵\n主对角线形式\n\n辐对角线形式\n\n交换次序\n\n\n\n二阶矩阵\n伴随矩阵法\n\n二阶矩阵的伴随矩阵\n\n主对角线元素对调\n辐对角线元素添负号\n\n\n二阶矩阵的行列式\n\n\n\n\n抽象矩阵\n操作\n\n将所求为一因子分解因式\n\n\n\n代数余子式余子式和代数余子式可能相差负号\n线性方程组齐次线性方程组有无非零解\n定理\n\n对象\n\n矩阵行列式\n秩\n解的情况\n\n\n关系：等价\n\n满秩\n|A|≠0\n矩阵可逆\nAx&#x3D;0有唯一零解\n降秩\n|A|&#x3D;0\n矩阵不可逆\nAx&#x3D;0有无穷非零解\n\n\n\n\n\n非齐次线性方程组解的情况\n定理\n\n对象\n\n矩阵行列式\n\n秩\n\n系数矩阵的秩\n增广矩阵的秩\n\n\n阶数\n\n解的情况\n\n\n\n关系:等价\n\n|A|≠0\n\nR(A)&#x3D;R(A,b)&#x3D;n\n\nAx&#x3D;b有唯一解\n\n|A|&#x3D;0\n\n无解或无穷多解\n\n无解\n\nR(A)&lt;R(A,b)\n\n\n无穷多解\n\nR(A)&#x3D;R(a,b)&lt;n\n\n求通解\n\n自由未知量\n\n个数\n\nn-r\n\n\n\n\n齐次方程的通解\n\n令自由未知量为1\n\n\n非齐次方程的特解\n\n令自由未知量为0\n\n\n\n\n\n\n\n\n\n\n\n\n\n解线性方程组\n齐次线性方程组\n\n系数矩阵\n行最简型\nn-r个自由变量\n给自由变量赋值得到一组基础解系\n基础解系的线性组合就是通解\n\n\n非齐次线性方程组\n\n对应齐次线性方程组的通解\n令自由变量全为0得到一个特解\n齐次的通解+非齐次的特解即为非齐次的通解\n\n\n\n初等变换和初等矩阵初等变换\n行变换\n列变换\n\n初等矩阵\n定义\n\n单位矩阵经过一次初等变换\n\n\n性质\n\n左乘行变换\n右乘列变换\n\n\n\n可逆矩阵\n分解\n\n若干个初等矩阵的积\n\n\n\n向量组的线性相关性对象\n向量组a1,a2,…,an∈Rn\nRn是n维向量空间n维向量空间中的向量是n维向量\n\n向量组对应的矩阵An\n\n\n关系：等价到底有没有水货？全是干货——满秩有水货——降秩\n\n|A|≠0\nA满秩\n向量组线性无关\n|A|&#x3D;0\nA降秩\n向量组线性相关\n\n一个定理\n线性无关的向量组增加分量（维数）仍然线性无关\n\n极大无关组原文：初等变换的应用\n作出对应的矩阵化为行阶梯型非零行的每一行的首非零元素所在列的向量构成极大线性无关组极大先行无关组并不唯一取每一行第一个首非零元素所在列的向量构成的极大先行无关组可能是若干个极大先行无关组的一个秩即为极大先行无关组中向量的个数每个阶梯上取一个向量\n得到极大先行无关组和向量组的秩化二次型为标准型正交变换法\n基础知识\n\n二次型对应一个实对称矩阵\n对角矩阵对应二次型的标准型\n实对称矩阵一定可以化成对角阵\n\n\n步骤\n\n求出二次型的矩阵A\n求出A的所有特征值\n求出特征值对应的特征向量\n将特征向量正交化、单位化作为列向量组成矩阵C\n作正交变换x&#x3D;Cy得到f的标准型\n\n\n\n配方法\n先把含x1的项集中起来\n交叉项提取公因式x1\n配方\n递归\n\n初等变换法\n上面行列变换\n下面列变换\n\n特征值计算方面的性质\n幂\n\n函数\n\nf(λ)&#x3D;f(A)\n\n\n行列式\n\n特征值乘积\n\n\n\n正交矩阵特点\n任意两行两列向量正交\n行列向量为单位向量\n\n伴随矩阵的秩R(A*)性质\n条件\n\n结论\n\n\nR(A)&#x3D;n\n\nR(A*)&#x3D;n\n\n\nR(A)&#x3D;n-1\n\nR(A*)&#x3D;1\n\n\nR(A)&lt;n-1\n\nR(A*)&#x3D;0\n\n\n\n证明\n定理\n\n最高阶非零余子式\n秩\n\n\n\n相似矩阵定义\n存在可逆矩阵P，P^(-1)AP&#x3D;B\n\n性质\n秩相同\n\n特征值相同\n\n行列式值相同\n\n迹相同\n迹——trace——主对角线元素和\n\n\n正定二次型充要条件\n顺序主子式全部大于0\n特征值全部大于0\n与单位矩阵合同\n\n充分条件\n行列式大于0\n\n","categories":["线代"]},{"title":"线程池","url":"/2020/12/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"\n\n\n概念管理一组线程的对象\n作用线程的创建和销毁需要消耗相当的资源，利用线程池可以提高创建线程的速度，并且线程可以被重复利用\n创建ThreadPoolExecutor\n参数\n\nint corePoolSize\n\n核心线程数量\n\n\nint maximumPoolSize\n\n线程池的最大线程数（核心线程+非核心线程）\n\n\nlong keepAliveTime\n\n非核心线程的存活时间\n\n\nTimeUnit unit\n\nBlockingQueue workQueue\n\n存放任务的阻塞队列\n\n\nThreadFactory threadFactory\n\nRejectedExecutionHandler handler\n\n线程池饱和如何处理\n\n\n\n\n\n执行流程\n核心线程\n\n阻塞队列\n\n线程池\n\nHandler\n\n\n\n\n\n\n\n拒绝策略线程池满了之后，再提交任务如何处理的问题\n\nAbort（直接抛异常）\nDiscard（忽略新提交的任务）\nDiscardOldest（移除阻塞队列最旧的）\nCallerRun（交给线程池调用者处理）\n\n异常处理线程池内发生异常悄无声息，可能无法感知，需要主动去处理\n\n直接在任务内部try+catch\n用try+catch包裹future.submit\n为工作线程设置UncaughtExceptionHandler\n覆写线程池的AfterExcute方法\n\n线程池的工作队列阻塞队列，类似经典的IPC问题：生产-消费者问题，一个线程消耗，一个线程生产，在适当的时候需要阻塞线程\nArrayBlockingQueue\n用数组实现\nFIFO\n容量无法改变\n\nLinkedBlockingQueue\n用链表实现\n可设置大小，默认Integer.MAX_VALUE\nFixedThreadPool采用这种阻塞队列\n\nDelayQueue\n根据指定的时间（1st）和进入队列的时间（2nd）排序\nScheduledThreadPool采用这种阻塞队列\n\nPriorityBlockingQueueSynchronousQueue\n内部只能包含一个元素，插入元素的线程被阻塞，直到另一个线程获取了队列中的元素，反之亦然\nCachedThreadPool采用这种阻塞队列\n\n常用线程池FixedThreadPool\n特点\n\n核心线程数和最大线程数相等\n\nkeepAliveTime&#x3D;0\n\n使用LinkedBlockingQueue（无界）\n使用无界队列可能会使内存占用飙升，最终OOM\n\n\n\n流程\n\n核心线程–&gt;阻塞队列–&gt;OOM\n\n\n使用场景\n\n适合执行长期的，CPU密集型任务\n\n\n\nCachedThreadPool\n特点\n\n核心线程数为0，最大线程数Integer.MAX_VALUE\n都是打工仔，没有一个有编制\n\n使用SynchronousQueue\n\n非核心线程存活时间60s\n\n\n\n流程\n\n阻塞队列–&gt;非核心线程–&gt;非核心线程的销毁\n\n\n使用场景\n\n并发执行大量短期的小任务\n\n\n\nSingleThreadExecutor\n特点\n\n只有一个核心线程\n使用LinkedBlockingQueue（无界）\n\n\n流程\n\n一个线程日以继夜，笔耕不辍\n\n\n使用场景\n\n串行执行的任务\n\n\n\nScheduledThreadPool\n特点\n\n使用DelayQueue作为阻塞队列\n没有非核心线程\n可以设置周期和延迟\n\n\n流程\n\nDelayQueue–&gt;核心线程–&gt;DelayQueue\n\n\n使用场景\n\n周期性的任务\n\n\n\n","categories":["Java"]},{"title":"组合逻辑电路","url":"/2020/08/06/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","content":"定义\n输出仅仅与该时刻的输入有关\n\n和该时刻以前的输入无关\n\n无记忆的电路， 在电路中没有反馈回路\n\n\n\n\n分析\n由给定逻辑电路图写出输出端逻辑表达式\n\n\n\n\n列出真值表从中概括出逻辑功能\n\n\n\n\n改进设计寻找最佳方案\n\n\n\n设计\n将文字描述的逻辑转为真值表\n\n\n\n\n画卡诺图写函数（根据选择什么门）\n\n\n\n\n画出逻辑电路\n\n中规模组合逻辑部件中规模组合逻辑部件VS基本逻辑门器件\n集成度不同\n\n最基本的逻辑门器件\n轮子\n\n\n门器件的缺点\n\n门器件多\n焊点多\n连线多\n\n\nMSI、LSI的优点\n\n集成度高、体积小\n功耗低、速度快\n可靠性高\n抗干扰能力强\n\n\n\n常见器件\n半加器、全加器\n\n半加器\n\n不考虑低位进位\n\n\n全加器\n\n考虑低位进位\n\n应用\n\n实现十进制加法\n实现二进制加减法\n实现二进制乘法\n实现码制转换\n实现异或运算\n\n\n\n\n\n\n编码器、译码器\n\n编码\n\n将特定的信息用二进制代码表示\n\n\n译码\n\n将二进制代码转为特定的信息\n\n应用\n\n实现函数\n\n将输出函数转为最小项的标准式\n\n\n\n\n\n\n\n\n\n数据选择器\n\n输出表达式\n\n\n\n\n应用\n\n实现组合逻辑函数\n\n栗子\n\n\n\n\n\n\n\n数据比较器\n\n图\n\n\n两位输入\n\n三位输出\n\n\n\n\n竞争与冒险竞争现象\n一个变量可以通过不同的路径到达输出门的输入端\n\n冒险现象\n分类\n\n偏1冒险\n\n负脉冲\n\n\n偏0冒险\n\n正脉冲\n\n\n\n\n判断\n\n代数法\n\n对竞争变量以外的赋值，只剩下竞争变量，与则是偏0，或则是偏1\n\n\n\n\n\n","categories":["数电"]},{"title":"缓存","url":"/2021/04/25/%E7%BC%93%E5%AD%98/","content":"\n\n\n\nLRU GO 实现package mainimport &quot;fmt&quot;type LRUCache struct &#123;\tlimit   int\thashMap map[int]*Node\thead    *Node\ttail    *Node&#125;type Node struct &#123;\tkey  int\tval  int\tpre  *Node\tnext *Node&#125;func NewNode(k, v int) *Node &#123;\treturn &amp;Node&#123;\t\tkey: k,\t\tval: v,\t&#125;&#125;func NewLRUCache(cap int) LRUCache &#123;\tc := LRUCache&#123;\t\tlimit:   cap,\t\thashMap: make(map[int]*Node),\t\thead:    NewNode(0, 0), // dummy node\t\ttail:    NewNode(0, 0), // dummy node\t&#125;\tc.head.next = c.tail\tc.tail.pre = c.head\treturn c&#125;func (c *LRUCache) Get(key int) int &#123;\tif node, ok := c.hashMap[key]; ok &#123;\t\tc.moveToHead(node)\t\treturn node.val\t&#125;\t// if not found, return -1\treturn -1&#125;func (c *LRUCache) Put(k, v int) &#123;\tif node, ok := c.hashMap[k]; !ok &#123;\t\tif len(c.hashMap) &gt;= c.limit &#123;\t\t\ttail := c.removeTail()\t\t\tdelete(c.hashMap, tail.key)\t\t&#125;\t\tnode = NewNode(k, v)\t\tc.hashMap[k] = node\t\tc.addToHead(node)\t&#125; else &#123;\t\tnode.val = v\t\tc.moveToHead(node)\t&#125;&#125;func (c *LRUCache) moveToHead(node *Node) &#123;\tc.removeNode(node)\tc.addToHead(node)&#125;func (c *LRUCache) removeNode(node *Node) &#123;\tnode.pre.next = node.next\tnode.next.pre = node.pre&#125;func (c *LRUCache) removeTail() *Node &#123;\ttail := c.tail.pre\tc.removeNode(tail)\treturn tail&#125;func (c *LRUCache) addToHead(node *Node) &#123;\tnode.pre = c.head\tnode.next = c.head.next\tc.head.next.pre = node\tc.head.next = node&#125;func main() &#123;\tcache := NewLRUCache(3)\tcache.Put(1,1)\tcache.Put(2,2)\tcache.Put(3,3)\tcache.Put(4,4)\tfmt.Println(cache.Get(3))&#125;\n\n","categories":["系统设计"]},{"title":"网络层","url":"/2020/12/09/%E7%BD%91%E7%BB%9C%E5%B1%82/","content":"\n\n\n作用使用IP协议，可以把异构的物理网络连接起来，实现主机之间的通信协议IPARP\n\n概念\n\nAddress Resolution Protocol\n\n\n作用\n\n由IP地址得到MAC地址\n网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。\n\n\n\nARP高速缓存\n\n包含本局域网内网络设备IP地址到MAC地址的映射\n如果映射表里找不到就发送ARP广播寻找\n\n\n\nICMP\n概念\n\nInternet Control Message Protocol\n\n\n作用\n\n更有效地转发 IP 数据报和提高交付成功的机会\n\n\n位置\n\nIP数据包的数据部分\n\n\n报文分类\n\n差错报告报文\n询问报文\n\n\n应用\n\nPing\n\n向目的主机发送ICMP echo请求报文\n\n\nTraceroute\n\n发送方在ip数据包里封装无法交付的UDP用户数据报，并且将数据包的生存时间TTL++发送给路由器\n\n\n\n\n\nIGMPIP数据包格式\n构成\n版本\n\nIPv4\nIPv6\n\n\n首部长度\n\n值为1表示4个字节\n\n\n区分服务\n\n一般不用\n\n\n总长度\n\n首部长度+数据长度\n\n\n生存时间\n\nTTL，为0时丢弃\n\n\n协议\n\n传输层的协议，如TCP，UDP\n\n\n首部检验和\n\n数据包每经过一个路由器，都要重新计算检验和\n\n\n标识\n\n如果数据包长度过长而分片，相同数据包的不同分片有相同的标识符\n\n\n片偏移\n\n用来区分分片，单位为8字节\n\n\n\n\nIP地址编址方式分类\n网络号\n\nA类\n\n8位\n\n\nB类\n\n16位\n\n\nC类\n\n24位\n\n\n\n\n主机号\n\n\n子网划分\n在主机号中拿一部分作为子网号，把两级IP划分为三级IP\n\n子网掩码\n\n作用\n\n确定网段\n同一个网段的设备可以直接通信，不同网段的设备通信需要网关协助\n\n\n\n\n\n外部网络看不到子网的存在\n\n\n无分类在之前的分类网络中，IP地址的分配把IP地址的32位按每8位为一段分开。这使得前缀必须为8，16或者24位。因此，可分配的最小的地址块有256（24位前缀，8位主机地址，28&#x3D;256）个地址，而这对大多数企业来说太少了。大一点的地址块包含65536（16位前缀，16位主机，216&#x3D;65536）个地址，而这对大公司来说都太多了。这导致不能充分使用IP地址和在路由上的不便，因为大量的需要单独路由的小型网络（C类网络）因在地域上分得很开而很难进行聚合路由，于是给路由设备增加了很多负担。\n\n构成\n\n网络前缀\n主机号\n\n\n路由聚合\n通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网\n\n匹配\n\n用网络前缀匹配的结果可能不止一个，应该选用最长前缀匹配规则\n\n\n\n技术VPN\n概念\n\n由于IP地址的紧缺，一个机构可以使用专用ip地址（仅在本机构有效的ip地址）\nVPN使用互联网作为本机构专用网之间的通信载体，虚拟一词体现在好像是专用网，但其实也有用到互联网\n\n\n实现\n\n用两台路由器包装一下\n\n\n\n\nNATNetwork Address Translation\n\n作用\n\n将本地IP转换为全球IP，使得多个专用网内部的多个主机公用一个全球IP地址\n\n\n实现\n\n对于因特网上的通信，路由器本身充当源和目的，再根据端口号区分不同的主机。\n\n\n\n路由器结构\n路由选择\n交换结构\n输入输出端口\n\n分组转发过程\n从数据包里提取目的地址D，并得到对应的网络地址N\n判断得到的网络地址N是否是与该路由器直接相连的网络的网络地址之一，如果是，直接进行交付\n如果路由表中有目的地址D对应的路由，则把数据包发送给该路由\n如果路由表中有到达N的路由，则把数据包发送给该路由\n如果有默认路由，发送给默认路由\n报告分组出错\n\n路由选择协议\n自治系统内部的路由选择\n\nRIP\n\n每隔30秒会与相邻的路由器交换子消息，以动态的创建路由表。\n\n距离向量算法\n\n缺点\n\n网络规模小\n需要较长时间将故障信息传给所有路由器\n\n\n\n\nOSPF\n\n开放最短路径优先\n所有的路由器都有全网的拓扑结构\n\n\n\n\n自治系统间的路由选择\n\nBGP\n\n\n\n","categories":["计网"]},{"title":"网络编程","url":"/2020/05/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"\n\n\n\n网络编程基础计算机网络\n多台计算机通过通讯线路相连接\n\n互联网\n将所有计算机网络相连接\n\n协议\n\nTCP\nIP\n\n\n\nIP地址\n标识一个网络接口\n\n一台接入互联网的计算机至少有一个IP地址\n我感觉应该是一块无线网卡对应一个ip地址\n\n分类\n\n按格式\n\nIPV4\n\n32位整数\n耗尽\n\n\nIPV6\n\n\n\n按范围\n\n公网\n内网（局域网）\n\n\n\n\n\n\n\n网络号\n获得\n\nip地址经过子网掩码过滤\n\n\n用途\n\n网络号相同\n\n设备在同一个网络下，可以直接通信\n\n\n网络号不同\n\n设备不在一个网络下，要依靠路由器或交换机通信\n\n\n\n\n\n网络设备\n网关\n\n路由器\n交换机\n\n\n\n路由\n通过网关把一个网络的数据包发送到另一个网络\n\n域名\n为什么存在？\n\n因为IP地址太难记\n也就是说 域名就是给ip地址起个小名儿 叫起来方便\n\n\n\n特殊的localhost\n\n因为特殊所以特殊\n我看了C盘windows下的那个hosts文件，就像是字典一样，一个ip地址对应一个域名，我怀疑域名解析就是靠这个实现的。\n\n127.0.0.1\n\n\n\n\n\n网络模型\n分层\n\n原因\n\n因为复杂所以分层\n\n\n目的\n\n简化网络操作\n\n\n有哪些层呢\n\n应用层\n\n提供应用程序之间的通信\n\n\n传输层\n\n提供端到端的传输\n\n\nIP层\n\n根据目标地址选择路由传输数据\n\n\n网络接口层\n\n处理数据然后通过物理设备（网线\\wifi）传输\n\n\n\n\n\n\n\n协议\n作用\n\n交易之前总得商量好吧\n\n\n常用协议\n\nIP协议\n\n负责发数据包\n好像是瞎jb‘发的 据说不保证顺序 正确与否也不知道是不是真的\n\n\n\nTCP协议\n\n负责控制数据包传输\n负责的协议，通过一些手段（目前我还听不懂的名词）保证可靠、正确、稳定。\n\n建立连接\n传输数据\n断开连接\n\n\n\n\nUDP\n\nVS TCP\n\nUDP完任务型选手\n我只管传输数据，有没有人接受我不care\n\n无连接\n\n速度更快\n\n协议更简单\n\n质量更垃圾\n\n数据必丢失\n\n\n\n应用\n\n能容忍数据丢失的场合\n据说音视频通话比较常用，我想也是，能听来或者看来个百分之八九十就可了。\n\n\n\n\n\n\n\n\nTCP编程socket据说socket、tcp和部分ip的功能是由操作系统实现并提供的，不同的语言只是对操作系统提供的接口进行了一些包装\n\n啥是socket\n\napplication通过socket在网络间传输数据\nsocket通过TCP&#x2F;IP协议在网络间传输数据\n\n\n为啥需要socket\n\nip地址是网卡的标识\n说的粗糙一点就是 设备的标识\n\nip地址过于粗糙\n\nsocket精确到application\n\n\n\nsocket长啥样啊\n\nip地址再加点儿料（端口）\n\n\n端口\n\n为啥需要端口啊\nip地址标识网络接口，if我的电脑有一个网卡，这个网卡有一个ip地址，我的电脑上运行了好多需要联网的应用，比如qq、战网、steam，还有很多其他应用。我的网卡对于从远方发过来的包照单全收，但这些包都是名花有主的，因为物质资料还没有到极大丰富的地步，所以不能实行共产主义平均分配或者每人来一份，我们得按需分配，按闹分配，比如qq你只能领取属于自己的包，那怎么实现这样的需求呢？咱这样，你们每个应用，给自己整一个端口，比如战网，你的port是988，那我网卡以后就通过这个端口跟你keep touch，其他应用都要有自己的端口，俺网卡按照包的标识，按照咱约定好的端口，按需分配，这样就解决问题了。\n\n因为socket\n\n\n特权端口\n比如我的应用是用一个普通user打开的，那这个应用就不能使用1024以下的端口\n\n1024以下需要管理员权限\n\n\n\n\nsocket编程\n\n服务器端\n\n服务客户端的端\n\n服务端会监听某个端口\n\n\n\n从端口获得数据包然后服务客户端（我猜的\n\n代码\npackage Laboratory;import javax.xml.crypto.Data;import java.io.*;import java.net.*;import java.nio.charset.StandardCharsets;public class Experiment &#123;    public static void main(String[] args) throws IOException &#123;        //服务器端，可能会有很多客户端请求与我共舞        //监听指定的端口，可以指定ip地址，ip地址标识网络接口，如果不指定ip地址，表明监听计算机上的所有网络接口        ServerSocket serverSocket = new ServerSocket(6666);        System.out.println(&quot;server is running&quot;);        //处理和客户端之间的连接        while (true) &#123;            //ServerSocket的accept方法，如果有客户端请求连接，我就整个socket对象给他，如果没有人请求连接，这个方法就会block            Socket socket = serverSocket.accept();            System.out.println(&quot;Connected from &quot; + socket.getRemoteSocketAddress());            Thread thread = new Handler(socket);            thread.start();        &#125;    &#125;&#125;class Handler extends Thread &#123;    Socket socket;    public Handler(Socket socket) &#123;        this.socket = socket;    &#125;        @Override    public void run() &#123;        try (InputStream inputStream = this.socket.getInputStream()) &#123;            try (OutputStream outputStream = this.socket.getOutputStream()) &#123;                handle(inputStream, outputStream);            &#125;        &#125; catch (Exception e) &#123;            try &#123;                this.socket.close();            &#125; catch (IOException ioe) &#123;            &#125;            System.out.println(&quot;Client disconnected&quot;);        &#125;    &#125;        private void handle(InputStream inputStream, OutputStream outputStream) throws IOException &#123;        var writer = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));        var reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));        writer.write(&quot;Fku\\n&quot;);        writer.flush();        while (true) &#123;            String s = reader.readLine();            if (s.equals(&quot;bye&quot;)) &#123;                writer.write(&quot;bye too&quot;);                writer.flush();                break;            &#125;            writer.write(&quot;fku 3000 times &quot; + s);           writer.flush();        &#125;   &#125;&#125;\n\n  \t    \t    \n\n\n客户端\n\n主动连接服务器的ip和指定端口\n\n代码\npackage Laboratory;import java.io.*;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.util.Scanner;public class Experiment &#123;    public static void main(String[] args) throws IOException &#123;        //客户端的TCP程序        //连接指定的服务器和端口，如果连接成功，会返回一个socket实例，用于日后的通信        Socket socket = new Socket(&quot;localhost&quot;, 6666);        try (InputStream inputStream = socket.getInputStream()) &#123;            try (OutputStream outputStream = socket.getOutputStream()) &#123;                handle(inputStream, outputStream);            &#125;        &#125;        socket.close();        System.out.println(&quot;Disconnected&quot;);    &#125;    private static void handle(InputStream inputStream, OutputStream outputStream) throws IOException &#123;        var reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));        var writer = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;[server] &quot; + reader.readLine());        while (true) &#123;            System.out.print(&quot;&gt;&gt;&gt; &quot;);       //打印提示            String s = scanner.nextLine();      //读取一行输入             writer.write(s);            writer.newLine();          writer.flush();            String str = reader.readLine();            System.out.println(&quot;&lt;&lt;&lt;&quot; + str);            if (str.equals(&quot;bye&quot;)) &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\n编程使得客户端和服务端进行通信\n\n\n\n\n\n\n三次握手tcp是要和服务器建立连接的啊\n\n屌丝：可以吗？\n女神：可以，你想什么时候？\n屌丝：今ここだ\n\nUDP编程UDP VS TCP\nUDP不需要建立连接\n当然也就不需要断开连接\n\nUDP没有流的概念\n\n两者的端口相互独立\n就是 假如有两个应用，一个用UDP，一个用TCP，就算两个用一个端口也没事儿\n\n\n服务器端\n监听指定的端口\n\n代码\npackage Laboratory;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;import java.nio.charset.StandardCharsets;public class Experiment &#123;    public static void main(String[] args) throws IOException &#123;        //服务端的操作：准备一个datagramSocket对象，利用他的receive和send方法接收和发送数据        //服务器端首先使用如下语句在指定的端口监听UDP数据包：        DatagramSocket datagramSocket = new DatagramSocket(6666);        while (true) &#123;            //准备一个byte[]类型的缓冲包用来接收来自端口的数据            byte[] buffer = new byte[1024];            //通过DatagramPacket对象的方法receive接收数据包            DatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length);            datagramSocket.receive(datagramPacket);            //通过DatagramPacket的getOffset和getLength方法确定接收到的数据在缓冲区的起始位置            String s = new String(datagramPacket.getData(), datagramPacket.getOffset(), datagramPacket.getLength(), StandardCharsets.UTF_8);            byte[] data = &quot;ACK&quot;.getBytes(StandardCharsets.UTF_8);            datagramPacket.setData(data);            datagramSocket.send(datagramPacket);        &#125;    &#125;&#125;\n\n客户端\n操作\n\n向服务器发送UDP包\n接收服务器返回的UDP包\n\n\n代码\npackage Laboratory;import javax.xml.crypto.Data;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.nio.charset.StandardCharsets;public class Experiment &#123;    public static void main(String[] args) throws IOException &#123;        //客户端        //客户端创建DatagramSocket的时候不需要指定端口，分配端口这个活儿是OS干的，所以说OS是程序员的好朋友        DatagramSocket datagramSocket = new DatagramSocket();        //此处有别于服务器端，服务器端可以循环到天荒地老，但客户端有所不同，需要设置最长等待时间，过期不候        datagramSocket.setSoTimeout(1000);        //UDP不需要建立连接，没错，这里的connect并不是真连接，而是想把服务器的ip和端口保存下来，以便之后向服务器发送UDP数据包        datagramSocket.connect(InetAddress.getByName(&quot;localhost&quot;), 6666);        //现在可以发送数据了        //先来点数据        byte[] data = &quot;What&#x27;s going on?&quot;.getBytes();        //和DatagramPacket绑在一起        DatagramPacket datagramPacket = new DatagramPacket(data, data.length);        //通过Socket的方法send将Packet发送到服务器，必须是先发再收，不然服务器不知道客户端的ip和端口号        datagramSocket.send(datagramPacket);        //发送之后就可以接受数据了        //接受数据，和服务端一样        //先准备一个byte数组用来接受数据        byte[] buffer = new byte[1024];        //把buffer和packet绑定起来        datagramPacket = new DatagramPacket(buffer, buffer.length);        //通过socket的receive方法接受数据存到预先设定的packet里        datagramSocket.receive(datagramPacket);        //转换成String        String str = new String(datagramPacket.getData(), datagramPacket.getOffset(), datagramPacket.getLength());        //如果可以，可以选择断开连接        //既然不存在连接，当然也就不存在断开的对象，确实如此，此处的disconnect只是把socket对象恢复出厂设置，以便于socket可以再利用而已        datagramSocket.disconnect();    &#125;&#125;\n\nEmail发送\n传统的邮件\n\n投递到邮局——邮局2——邮局3——信箱\n\n\n电子邮件\n\n从用户的邮箱软件发送到服务器——服务器2——服务器3——邮箱\n\n\n邮箱软件\n\nMUA\nMail User Agent\n\n\n邮件服务器\n\nMTA\n\nMDA\n\n邮件最终的归属\n或许是某个服务器的某块硬盘\n\n\n\n\n代码\n   import javax.mail.*; import javax.mail.internet.AddressException; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import java.util.Properties;  public class Mail &#123;     public static void main(String[] args) throws MessagingException &#123;         String smtp = &quot;smtp.qq.com&quot;;         String username = &quot;674602921@qq.com&quot;;         String password = &quot;grzbslakcefkbceg&quot;;         Properties properties = new Properties();         properties.put(&quot;mail.smtp.host&quot;, smtp);         properties.put(&quot;mail.smtp.port&quot;, 465);         properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);         properties.put(&quot;mail.starttls.enable&quot;, &quot;true&quot;);         properties.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);         Session session = Session.getInstance(properties, new Authenticator() &#123;             @Override             protected PasswordAuthentication getPasswordAuthentication() &#123;                 return new PasswordAuthentication(username, password);             &#125;         &#125;);         session.setDebug(true);         MimeMessage message = new MimeMessage(session);         message.setFrom(new InternetAddress(&quot;674602921@qq.com&quot;));         message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;ljm158675@gmail.com&quot;));         message.setSubject(&quot;Hey&quot;, &quot;UTF-8&quot;);         message.setText(&quot;Java,please!&quot;);         Transport.send(message);     &#125; &#125;  public class Mail &#123;     public static void main(String[] args) throws MessagingException &#123;         String smtp = &quot;smtp.qq.com&quot;;         String username = &quot;674602921@qq.com&quot;;         String password = &quot;grzbslakcefkbceg&quot;;         Properties properties = new Properties();         properties.put(&quot;mail.smtp.host&quot;, smtp);         properties.put(&quot;mail.smtp.port&quot;, 465);         properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);         properties.put(&quot;mail.starttls.enable&quot;, &quot;true&quot;);         properties.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);         Session session = Session.getInstance(properties, new Authenticator() &#123;             @Override             protected PasswordAuthentication getPasswordAuthentication() &#123;                 return new PasswordAuthentication(username, password);             &#125;         &#125;);         session.setDebug(true);         MimeMessage message = new MimeMessage(session);         message.setFrom(new InternetAddress(&quot;674602921@qq.com&quot;));         message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;ljm158675@gmail.com&quot;));         message.setSubject(&quot;Hey&quot;, &quot;UTF-8&quot;);         message.setText(&quot;Java,please!&quot;);         Transport.send(message);     &#125; &#125;\n\n接收\n代码\n  import com.sun.mail.pop3.POP3SSLStore;    import javax.mail.*;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import java.io.IOException;import java.util.Properties;  public class Mail &#123;    public static void main(String[] args) throws MessagingException, IOException &#123;        String host = &quot;pop3.example.com&quot;;        String username = &quot;bob@example.com&quot;;        String password = &quot;********&quot;;        int port = 995;        Properties properties = new Properties();        properties.setProperty(&quot;mail.store.protocol&quot;, &quot;pop3&quot;);        properties.setProperty(&quot;mail.pop3.host&quot;, host);        properties.setProperty(&quot;mail.pop3.port&quot;, String.valueOf(port));        properties.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);        properties.put(&quot;mail.smtp.socketFactory.port&quot;, String.valueOf(port));        URLName urlName = new URLName(&quot;pop3&quot;, host, port, &quot;&quot;, username, password);        Session session = Session.getInstance(properties, null);        session.setDebug(true);        Store store = new POP3SSLStore(session, urlName);        store.connect();        // 获取收件箱:        Folder folder = store.getFolder(&quot;INBOX&quot;);// 以读写方式打开:        folder.open(Folder.READ_WRITE);// 打印邮件总数/新邮件数量/未读数量/已删除数量:        System.out.println(&quot;Total messages: &quot; + folder.getMessageCount());        System.out.println(&quot;New messages: &quot; + folder.getNewMessageCount());        System.out.println(&quot;Unread messages: &quot; + folder.getUnreadMessageCount());        System.out.println(&quot;Deleted messages: &quot; + folder.getDeletedMessageCount());// 获取每一封邮件:        Message[] messages = folder.getMessages();        for (Message message : messages) &#123;            // 打印每一封邮件:            printMessage((MimeMessage) message);        &#125;    &#125;      static void printMessage(MimeMessage msg) throws IOException, MessagingException &#123;        // 邮件主题:        System.out.println(&quot;Subject: &quot; + MimeUtility.decodeText(msg.getSubject()));        // 发件人:        Address[] froms = msg.getFrom();        InternetAddress address = (InternetAddress) froms[0];        String personal = address.getPersonal();        String from = personal == null ? address.getAddress() : (MimeUtility.decodeText(personal) + &quot; &lt;&quot; + address.getAddress() + &quot;&gt;&quot;);        System.out.println(&quot;From: &quot; + from);        // 继续打印收件人:    &#125;  &#125;\n\nHTTP编程建立TCP连接请求（HTTP，浏览器）\nHTTP HEADER\nHTTP BODY\n\n响应（HTTP，服务器）","categories":["计网"]},{"title":"虚拟机体系结构风格","url":"/2021/04/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC/","content":"","categories":["软件体系结构"]},{"title":"西电晨午晚检自动填报工具","url":"/2020/10/22/%E8%A5%BF%E7%94%B5%E6%99%A8%E5%8D%88%E6%99%9A%E6%A3%80%E8%87%AA%E5%8A%A8%E5%A1%AB%E6%8A%A5%E5%B7%A5%E5%85%B7/","content":"使用方法不打包运行修改src\\main\\resources\\account.properties的内容为自己的学号和密码，以及src\\main\\resources\\data.json的内容为要上报的信息。\n&#123;        &quot;sfzx&quot;: &quot;1&quot;, # 是否在校(0-&gt;否, 1-&gt;是)        &quot;tw&quot;: &quot;1&quot;, # 体温 (36℃-&gt;0, 36℃到36.5℃-&gt;1, 36.5℃到36.9℃-&gt;2, 36.9℃到37℃.3-&gt;3, 37.3℃到38℃-&gt;4, 38℃到38.5℃-&gt;5, 38.5℃到39℃-&gt;6, 39℃到40℃-&gt;7, 40℃以上-&gt;8)        &quot;sfcyglq&quot;: &quot;0&quot;, # 是否处于隔离期? (0-&gt;否, 1-&gt;是)        &quot;sfyzz&quot;: &quot;0&quot;, # 是否出现乏力、干咳、呼吸困难等症状？ (0-&gt;否, 1-&gt;是)        &quot;qtqk&quot;: &quot;&quot;, # 其他情况 (文本)        &quot;askforleave&quot;: &quot;0&quot; # 是否请假外出? (0-&gt;否, 1-&gt;是)&#125;\n\n打包运行修改jar包中account.properties和data.json文件同上。\njava -jar -Dfile.encoding&#x3D;UTF-8 xxxxx.jar\n实现思路向https://xxcapp.xidian.edu.cn/uc/wap/login/check发送post请求获取cookie，再带着获得的cookie向https://xxcapp.xidian.edu.cn/xisuncov/wap/open-report/save发送post请求上传数据。\n通过Timer使这个过程每两个小时重复一次，把程序挂在服务器就可以高枕无忧了。\n源码https://github.com/carpediemtal/XDCOV\n\n\nCovid.javapackage eternal.fire.entity;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;import java.io.InputStreamReader;import java.net.URI;import java.net.URISyntaxException;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.nio.charset.StandardCharsets;import java.util.Properties;public class Covid &#123;    private final static String LOGIN_URL = &quot;https://xxcapp.xidian.edu.cn/uc/wap/login/check&quot;;    private final static String UPLOAD_URL = &quot;https://xxcapp.xidian.edu.cn/xisuncov/wap/open-report/save&quot;;    private final static HttpClient httpClient = HttpClient.newBuilder().build();    private final String username;    private final String password;    private final ObjectMapper mapper;    public Covid(String username, String password) &#123;        this.username = username;        this.password = password;        this.mapper = new ObjectMapper();        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);    &#125;    public Covid() throws IOException &#123;        var account = getAccountFromFile();        this.username = account[0];        this.password = account[1];        this.mapper = new ObjectMapper();        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);    &#125;    public void uploadData() throws InterruptedException, IOException, URISyntaxException &#123;        String cookie;        try &#123;            cookie = getCookieByLogIn();        &#125; catch (RuntimeException e) &#123;            System.out.println(e.getMessage());            return;        &#125;        String data = getContentFromFile();        HttpRequest request = HttpRequest.newBuilder(new URI(UPLOAD_URL))                .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)                .headers(&quot;Cookie&quot;, cookie)                .POST(HttpRequest.BodyPublishers.ofString(data, StandardCharsets.UTF_8))                .build();        var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());        Message message = mapper.readValue(response.body(), Message.class);        if (message.getE() == 0) &#123;            System.out.println(&quot;上报成功&quot;);        &#125; else &#123;            System.out.println(&quot;上报失败：&quot; + message.getM());        &#125;    &#125;    private String getCookieByLogIn() throws IOException, InterruptedException, URISyntaxException &#123;        String body = String.format(&quot;username=%s&amp;password=%s&quot;, username, password);        HttpRequest request = HttpRequest.newBuilder(new URI(LOGIN_URL))                .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)                .POST(HttpRequest.BodyPublishers.ofString(body, StandardCharsets.UTF_8))                .build();        var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());        System.out.println(response.body());        Message message = mapper.readValue(response.body(), Message.class);        if (message.getE() == 0) &#123;            var cookies = response.headers().allValues(&quot;set-cookie&quot;);            StringBuilder ans = new StringBuilder();            for (var cookie : cookies) &#123;                ans.append(purifyCookie(cookie));            &#125;            return ans.toString();        &#125;        throw new RuntimeException(&quot;登录失败，请检查用户名和密码是否正确&quot;);    &#125;    private String purifyCookie(String cookie) &#123;        int index = cookie.indexOf(&#x27;;&#x27;);        return cookie.substring(0, index + 2);    &#125;    private String getContentFromFile() throws IOException &#123;        InputStreamReader reader = new InputStreamReader(Covid.class.getResourceAsStream(&quot;/data.json&quot;));        StringBuilder data = new StringBuilder();        char[] buffer = new char[1024];        if (reader.read(buffer) != -1) &#123;            for (var ch : buffer) &#123;                data.append(ch);            &#125;        &#125;        return data.toString();    &#125;    public String[] getAccountFromFile() throws IOException &#123;        Properties properties = new Properties();        properties.load(Covid.class.getResourceAsStream(&quot;/account.properties&quot;));        String[] ans = new String[2];        ans[0] = properties.getProperty(&quot;username&quot;);        ans[1] = properties.getProperty(&quot;password&quot;);        return ans;    &#125;&#125;\n\nMessage.javapackage eternal.fire.entity;public class Message &#123;    private int e;    private String m;    public Message() &#123;    &#125;    public int getE() &#123;        return e;    &#125;    public void setE(int e) &#123;        this.e = e;    &#125;    public String getM() &#123;        return m;    &#125;    public void setM(String m) &#123;        this.m = m;    &#125;    public Message(int e, String m) &#123;        this.e = e;        this.m = m;    &#125;&#125;\n\nCovidTimerTask.javapackage eternal.fire.utils;import eternal.fire.entity.Covid;import java.io.IOException;import java.net.URISyntaxException;import java.util.TimerTask;public class CovidTimerTask extends TimerTask &#123;    private final Covid covid;    public CovidTimerTask() throws IOException &#123;        this.covid = new Covid();    &#125;    @Override    public void run() &#123;        try &#123;            this.covid.uploadData();        &#125; catch (InterruptedException | IOException | URISyntaxException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\nSchedule.javapackage eternal.fire.utils;import java.io.IOException;import java.util.Timer;public class Schedule &#123;    public static void uploadDataEveryTwoHours() throws IOException &#123;        Timer timer = new Timer();        timer.schedule(new CovidTimerTask(), 0, 1000 * 60 * 60 * 2);    &#125;&#125;\n\nApplication.javapackage eternal.fire;import eternal.fire.utils.Schedule;import java.io.IOException;public class Application &#123;    public static void main(String[] args) throws IOException &#123;        Schedule.uploadDataEveryTwoHours();    &#125;&#125;","categories":["Fun"]},{"title":"触发器","url":"/2020/08/22/%E8%A7%A6%E5%8F%91%E5%99%A8/","content":"时序电路概念\n输出信号与输入信号和过去的状态有关\n电路里必须有具备记忆功能的器件\n\n\n\n同步时序和异步时序\n同步时序\n\n触发器状态的转换同时完成\n\n\n异步时序\n\n触发器状态的转换不同时进行\n\n\n\n米里型时序和莫尔型时序\n米里型\n\n输出与输入和现态有关\n\n\n莫尔型\n\n输出仅与现态有关\n\n\n\n状态表性质\n具有两个稳定的状态，0和1\n\n稳态变化必须有触发\n\n两个输出端：源码输出和反码输出\n\n\n基本触发器基本RS触发器\n状态\n\n置位状态\n复位状态\n维持状态\n\n\n真值表\n\n\n钟控rs触发器\n性质和基本rs触发器刚好相反\n\nD触发器\n输出\n\n特点\n\nCP为0的时候维持状态\nCP为1的时候和D保持一样\n\n\n\n\n波形判断\n\n根据CD还是CD非判断\n\n上升沿触发\n下降沿触发\n\n\n边沿处的次态&#x3D;此刻的输入状态\n\n\n\n\nT触发器\n输出\n\nT&#x3D;0，维持\nT&#x3D;1，翻转\n\n\n\nJK触发器\n表达式\n\n输出\n\nJK&#x3D;00\n\n维持\n\n\nJK&#x3D;01\n\n置0\n\n\nJK&#x3D;10\n\n置1\n\n\nJK&#x3D;11\n\n翻转\n\n\n\n\n翻转时波形判断\n\n根据CD还是CD非判断\n\n上升沿触发\n下降沿触发\n\n\n边沿处的次态&#x3D;此刻的输入状态\n\n\n\n\n","categories":["数电"]},{"title":"计算表达式","url":"/2021/04/13/%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"一类经典的题目是，给定一个表达式，表达式根据操作符的种类数，是否考虑小数，形态各异，有针对于某一种形态的解法，也有很通用的办法：\n\n\n源代码package mainimport (\t&quot;bufio&quot;\t&quot;bytes&quot;\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;strconv&quot;\t&quot;strings&quot;\t&quot;unicode&quot;)// 优先级var priority = make(map[rune]int)// 数字栈var nums []int// 操作符栈（包含括号）var ops []rune// 暂时存储读到的数字var numBuf bytes.Bufferfunc main() &#123;\tscanner := bufio.NewScanner(os.Stdin)\tfor scanner.Scan() &#123;\t\texp := scanner.Text()\t\tval := calculate(exp)\t\tfmt.Println(val)\t&#125;&#125;func calculate(expression string) int &#123;\t// 预处理\texpression = preprocess(expression)\tfor i, ch := range expression &#123;\t\tswitch &#123;\t\tcase ch == &#x27;(&#x27;:\t\t\tops = append(ops, ch)\t\tcase ch == &#x27;)&#x27;: // 先算括号里面的\t\t\tnumBufFlush()\t\t\tfor &#123;\t\t\t\tif ops[len(ops)-1] != &#x27;(&#x27; &#123;\t\t\t\t\tcal()\t\t\t\t&#125; else &#123;\t\t\t\t\tops = ops[:len(ops)-1]\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\tcase unicode.IsNumber(ch):\t\t\tnumBuf.WriteRune(ch)\t\t\tif i == len(expression)-1 &#123;\t\t\t\tnumBufFlush()\t\t\t&#125;\t\tcase isOperator(ch):\t\t\tnumBufFlush()\t\t\tfor len(ops) != 0 &amp;&amp; ops[len(ops)-1] != &#x27;(&#x27; &#123;\t\t\t\t// 遇到操作符，计算栈内所有可计算的表达式（优先级大于等于当前操作符的）\t\t\t\tif priority[ops[len(ops)-1]] &gt;= priority[ch] &#123;\t\t\t\t\tcal()\t\t\t\t&#125; else &#123;\t\t\t\t\tbreak\t\t\t\t&#125;\t\t\t&#125;\t\t\tops = append(ops, ch)\t\t&#125;\t&#125;\t// 残留\tfor len(ops) != 0 &#123;\t\tcal()\t&#125;\treturn nums[len(nums)-1]&#125;func isOperator(ch rune) bool &#123;\tif ch == &#x27;+&#x27; || ch == &#x27;-&#x27; || ch == &#x27;*&#x27; || ch == &#x27;/&#x27; &#123;\t\treturn true\t&#125;\treturn false&#125;func numBufFlush() &#123;\tnum, err := strconv.Atoi(numBuf.String())\t// 空的numBuf\tif err != nil &#123;\t\treturn\t&#125;\tnums = append(nums, num)\tnumBuf.Reset()&#125;// 用栈顶的数字和运算符计算一次func cal() &#123;\tif len(nums) &lt;= 1 || len(ops) == 0 &#123;\t\treturn\t&#125;\ta, b := nums[len(nums)-2], nums[len(nums)-1]\tnums = nums[:len(nums)-2]\top := ops[len(ops)-1]\tops = ops[:len(ops)-1]\tswitch op &#123;\tcase &#x27;+&#x27;:\t\tnums = append(nums, a+b)\tcase &#x27;-&#x27;:\t\tnums = append(nums, a-b)\tcase &#x27;*&#x27;:\t\tnums = append(nums, a*b)\tcase &#x27;/&#x27;:\t\tnums = append(nums, a/b)\t&#125;&#125;// 初始的替换func preprocess(exp string) string &#123;\texp = strings.ReplaceAll(exp, &quot;&#123;&quot;, &quot;(&quot;)\texp = strings.ReplaceAll(exp, &quot;[&quot;, &quot;(&quot;)\texp = strings.ReplaceAll(exp, &quot;&#125;&quot;, &quot;)&quot;)\texp = strings.ReplaceAll(exp, &quot;]&quot;, &quot;)&quot;)\texp = strings.ReplaceAll(exp, &quot; &quot;, &quot;&quot;)\texp = strings.ReplaceAll(exp, &quot;(-&quot;, &quot;(0-&quot;)\texp = strings.ReplaceAll(exp, &quot;(+&quot;, &quot;(0+&quot;)\treturn exp&#125;func init() &#123;\t// 优先级定义\tpriority[&#x27;+&#x27;] = 0\tpriority[&#x27;-&#x27;] = 0\tpriority[&#x27;*&#x27;] = 1\tpriority[&#x27;/&#x27;] = 1\t// 表达式的第一个字符可能为正负号\tnums = append(nums, 0)&#125;\n\n思路使用两个栈：存放数字的栈 和 存放操作符的栈\n\n遇到数字：把整个数字入栈\n遇到操作符：比较栈顶操作符和当前操作符的优先级，如果栈顶操作符的优先级不低于当前操作符，就取栈顶的元素和操作符进行计算，将计算后的结果入栈。\n遇到括号：遇到左括号直接入栈，遇到右括号就不听的取栈顶元素和操作符计算，直到遇到左括号\n\n最终栈顶的元素即为所求。\n实际中还有很多特殊情况要考虑，比如表达式以正负号开头，含有空白字符等。\n","categories":["数据结构与算法"]},{"title":"计网概述","url":"/2020/12/07/%E8%AE%A1%E7%BD%91%E6%A6%82%E8%BF%B0/","content":"\n\n\nInternet网络把主机连接起来，而互联网把网络连接起来\nISP（Internet Service Provider）ISP从互联网管理机构获得IP地址，拥有通信线路和路由器等设备，用户通过ISP接入互联网\n主机之间的通信方式CS\n客户端\n服务器\n\nP2P\n对等\n\n电路交换和分组交换电路交换（Circuit Switching）\n分类\n\n时分交换（TDS）\n空分交换（SDS）\n\n\n缺点\n\n两个用户要通信之前需要建立一条专用的物理链路，电路空闲时的信道容量存在大的浪费\n\n\n\n分组交换（Packet Switching）\n优点\n\n不同的分组有首部尾部，包含原地址和目标地址等控制信息，不同的分组可以在同一条数据链路上传输，通信资源利用率高\n\n\n\n时延（Delay）排队时延\n进入路由器后等待处理\n处理完成后等待被发出\n\n处理时延\n分组在主机或路由器中处理的时间\n\n分析首部，尾部\n从分组中提取数据\n路由算法\n\n\n\n传输时延\n概念\n\n主机或者路由器传输数据帧所需的时间\n\n\n计算\n\n数据帧长度（bit）&#x2F;传输速率（bit&#x2F;s）\n\n\n\n传播时延\n电磁波\n\n网络体系结构OSI（七层）在五层结构里，表示层、会话层和应用层在一起实现\n\n应用层\n\n表示层\n\n数据压缩、加密、描述\n\n\n会话层\n\n建立及管理会话\n\n\n传输层\n\n网络层\n\n数据链路层\n\n物理层\n\n\n五层协议\n应用层\n\n功能\n\n为应用程序提供数据传输服务\n\n\n数据单位\n\n报文\n\n\n栗子\n\nHTTP、（HTTPS）、DNS、FTP、SFTP、SMTP、POP3、DHCP\n\n\n\n\n传输层\n\n功能\n\n为进程提供 通用 数据传输服务\n\n通用性可以支持不断增多的应用层协议\n五层结构里，应用层和物理层发展最快，新的东西最多\n\n\n\n协议\n\nTCP\n\n特点\n\n面向连接（connection-oriented）\n可靠（reliable）\n提供完整性服务\n\n\n数据单位\n\n报文段\n\n\n\n\nUDP\n\n特点\n\n无连接（less-connection）\n\n尽力而为（best-effort）\n虽然是“尽力而为”，但却是“最坏的结果”。如果有人对你的请求说尽力而为，那你并未得到他的保证\n\n提供及时性服务\n\n\n\n数据单位\n\n用户数据报\n\n\n\n\n\n\n\n\n网络层\n\n功能\n\n为主机提供数据传输服务，网络层把从传输层得到的数据再封装一层，成为分组（packet）\n\n\n数据单位\n\nPacket（分组）\n\n\n\n\n数据链路层\n\n功能\n\n为同一链路的主机提供数据传输服务，把从网络层得到的数据再封装一层，成为数据帧（Frame）\n\n\n数据单位\n\n数据帧\n\n\n\n\n物理层\n\n功能\n\n实现在不同的传输介质上传输数据比特流，尽可能使数据链路层感受不到传输介质和通信手段的差异（不论是Ethernet还是WIFI或者是Bluetooth）\n\n\n数据单位\n\n比特\n\n\n\n\n\nTCP&#x2F;IP协议（四层）\n应用层\n传输层\n网际层\n网络接口层\n应用层可能会直接使用网络层和网络接口层\n\n可以公开的情报\n数据在各层的传输过程\n\n从上到下：接收数据、打包、发给下面一层\n从下到上：接受数据、拆包、发给上面一层\n\n\n路由器不需要应用层和传输层，所以只有下面三层协议\n\n\n","categories":["计网"]},{"title":"计算机中的数据表示","url":"/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/","content":"数据编码数值数据的编码\n\n\n数据\n\n分类\n\n根据小数点\n\n定点数\n\n定点整数（纯整数）\n\n符号位\n数值位\n小数点位\n编码表示范围\n\n\n定点小数\n\n符号位\n数值位\n小数点位\n编码表示范围\n\n\n\n\n浮点数\n\n数符\n阶符\n阶码\n尾数\n\n\n\n\n根据符号\n\n无符号数\n有符号数\n\n\n\n\n进制转换\n\n整数部分\n小数部分不断×2取整数部分做尾数直到小数部分为0\n\n\n\n\n编码\n\n原码\n\n符号位\n\n最高位\n\n1\n\n负\n\n\n0\n\n正\n\n\n\n\n\n\n数值0\n\n两种表示\n\n\n原码和真值的转换\n\n把符号位改成﹢或-\n\n\n优劣\n\n优势\n\n简单直观\n转换容易\n\n\n劣势\n\n0的表示不唯一\n\n加减复杂\n\n乘除简单\n\n真值相乘判断正负\n\n\n\n\n\n\nn位源码的表示范围\n\n整数\n纯小数\n\n\n\n\n补码\n\n作用\n\n把减法变成加法\n\n\n整数补码\n\n值\n\n正数的补码是其本身\n\n负数的补码计算（以-35为例）\n\n将+35原码表示，所有位取反，最低位加1\n将-35原码表示，除了符号位所有位取反，最低位加1\n将+35原码表示，从低位向高位，找到第一个1不变，之后全部取反\n\n\n\n\n表示范围\n\n最大值和原码最大值相同\n\n最小值比原码最小值小1\n\n补码里0的表示只有一种\n\n\n\n\n\n\n小数补码\n\n值\n\n和整数补码有相同的计算方法\n\n\n表示范围\n\n最大值和原码最大值相同\n最小值可以取到边界值-1\n\n\n\n\n\n\n反码\n\n求补码的过渡\n\n取值\n\n正数不变\n负数除了符号位所有位按位取反\n\n\n表示范围\n\n和原码一样\n\n\n\n\n移码\n\n数值部分和补码相同\n符号部分和补码相反\n\n\n求补运算\n\n所有位按位取反，末位加1\n\n\n算数左移&#x2F;右移\n\n左移\n\n最高位移除，最低位补0\n\n\n右移\n\n最高位不变，最低位移除\n\n\n\n\n\n\n\n数据的浮点表示\n浮点数表示法\n\n概念\n\n类似科学计数法\n\n\n组成\n\n尾数（用补码或原码表示）\n\n数值部分\n数符部分\n\n\n基数（一般为2，不表示）\n\n阶码（用移码表示）\n\n数值部分\n数符部分\n\n\n\n\n\n\n浮点数所表示的数据范围\n\n浮点数分类\n\n非规格化浮点数\n\n规格化浮点数\n\n将尾数的绝对值限定在某个范围内\n规格化浮点数的第一位数值位和数符位必须相反\n范围\n例题\n\n\n\n\n规格化\n\n左规\n右规\n\n\n溢出\n\n上溢\n\n正\n负\n\n\n下溢\n\n正\n负\n\n\n\n\n\n\n\n检错与纠错编码\n奇偶校验码\n\n概念\n\n事先约定好用奇或偶校验\n补一位0或1使其有奇数或偶数个1\n\n\n分类\n\n水平奇偶校验\n\n垂直奇偶校验\n\n水平垂直奇偶校验\n\n水平＋垂直\n\n\n\n\n\n\n海明码\n\n概念\n\n具有一位纠错能力的编码\n\n\n编码距离\n\n\n\n循环冗余校验码CRC\n\n概念\n\n做除法运算除尽则编码正确否则余数指出错误位置\n\n\n做法\n\n获得CRC码\n\n将有效信息左移k位（k&#x3D;生成多项式位数-1）\n做除法运算得到余数补到有效信息后面得到CRC码\n\n\n解码\n\n用CRC码对生成多项式做除法运算\n余数为出错位置（从1开始从右向左数）\n\n\n\n\n\n\n\n","categories":["计组"]},{"title":"让CPU使用率百分百的程序","url":"/2021/05/09/%E8%AE%A9CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E7%99%BE%E5%88%86%E7%99%BE%E7%9A%84%E7%A8%8B%E5%BA%8F/","content":"写一个程序让CPU使用率达到100%？\n\n\nCPU使用率首先，什么是CPU使用率？\n我觉得在不同的语境下，这个概念应该有不同的含义。\n\n如果说的是CPU本身的使用率，则可以这样理解：存在一个任务队列等待CPU去执行，如果任务队列为空，CPU就会处于“空闲”状态，这时候CPU会去执行一个idle线程，这个线程用来统计进程的信息、降低CPU功耗（我记得当初写汇编的时候，8086有一个halt指令，可以暂停CPU，降低功耗也许和此有关）等。假如让CPU空闲时也不停空转，可以想见的是，我们的电脑即使什么也不做，CPU就会烫到能煮鸡蛋了。这时候，CPU使用率 &#x3D; 非idle时间&#x2F;总CPU时间。\n\n\n\ntop命令第三行的 98.7 id，就是idle状态占用CPU时间的百分比。\n参考：TOP | Ming (gitee.io)\n\n如果说的是某个程序的CPU使用率，则可以这样理解：操作系统将CPU时间划分成很多时间片，每个线程都有机会得到CPU时间。这时候，CPU使用率 &#x3D; 一定时间内线程消耗的CPU时间&#x2F;总CPU时间。图中每个进程的%CPU即为该进程的CPU使用率。\n\n如果想要某个线程的CPU使用率达到100%，意味着这个程序占用了所有的CPU时间，因此键盘、鼠标、其它程序也不会再有响应，进入了“死机”的状态。因为操作系统的调度，这种状态似乎很难达到。\n\n关于死机：\n我们用户态的所有的程序都是由操作系统去调度的，我们写的程序可能会崩溃，可能会死锁，死循环，但因为有操作系统的存在，就算出现了这些问题，别的程序也能够及时得到相应。\n但操作系统本身也是一种程序，如果操作系统的代码出了意想不到的问题（栗如死循环），我们用户态的所有的程序就再也得不到CPU时间了。这种情况下，操作系统选择直接死机，避免更进一步的错误发生。\n\n但如果只是让CPU总的使用率100%的话，还是很容易的，从定义出发，只要让CPU别闲下来就好。\n代码linux和win10都试试。\n值得一提的是，任务管理器显示的CPU使用率和top命令在linux下显示的CPU使用率含义略有不同，任务管理器显示的是多个核的平均值，最大值100%，而top显示所有核的总和，可能会超过100%。\nLinux环境：很低配的单核服务器\n\n\n写一个死循环：\n\n查看运行状况：\n\n\nidle时间为0，正如之前所说，整个CPU使用率达到了100%，但该进程（circle）最多到99.9%。\nWindows环境：我八核十六线程的锐龙2700，AMD YES\n\n\n\n\n写个死循环：\n\n\n我的锐龙波澜不惊：\n\n\n多起几个线程：（因为go routine和线程不是一对一的关系，所以go几下\n\n\n\n\n可见总的CPU使用率已经到了100%，而Go程序的使用率来到了98.4%，并未达到100%，这也是我还能截图的原因。\n\n\nreferenceTOP | Ming (gitee.io)\nlinux kernel - What does an idle CPU process do? - Unix &amp; Linux Stack Exchange\n","categories":["Linux"],"tags":["Linux","OS"]},{"title":"论守望先锋的成瘾性","url":"/2019/10/03/%E8%AE%BA%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%E7%9A%84%E6%88%90%E7%98%BE%E6%80%A7/","content":"今天是国庆假期的第三天，我已经打了三天守望先锋了，我知道不能再打了，身体却还是诚实地再来一局。我是万年钻石，自开服以来，就没有长进（曾经混到过大师）。为什么守望先锋类的游戏，很容易让人深陷其中呢。\n\n\n排位东亚人谁能抵抗的了排位赛的诱惑呢？\n如果没有段位，没有排名，这个游戏就不能称之为一款竞技游戏。\n我也看到过很多高等级的人，从来不打竞技。竞技也是有利有弊，没有竞技的时候，守望环境相当和谐，人人为我我为人人。一旦当玩家对获胜有强烈的执念，如果战败就会感受到比较强的挫败感，容易口吐芬芳。\n及时合理的正反馈在游戏里有很多正反馈，比如造成伤害的音效，击杀的语音，在焦灼中拿下一血的紧张刺激。推车图都有三个点，每推到一个点就能得到一些反馈。\n不仅如此，还有充能机制。造成伤害可以充能，充能100%就可以释放英雄终极技能，这个游戏里没人能抵挡住拔刀的诱惑。\nWhite Tiger Becomes Me！\n游戏的打击感非常棒，地图里很多物品都有互动效果，巴黎的钢琴，花村的游戏机。\n这些正反馈都让玩家欲罢不能。\n精美的画面作为2016年年度最佳游戏，守望先锋的画面也是上乘。在接触守望先锋之后，再看CF的画面，惨不忍睹。\n语音我最喜欢猎空的The world could always use more heroes。\n游戏里做仌现实里的loser，游戏里的master.\n","categories":["Essay"]},{"title":"设备管理","url":"/2020/12/11/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","content":"\n\n\n磁盘结构图\nPlatter（盘面）\n磁盘有多个盘面\n\nTrack（磁道）\n圆形带状区域\n\nTrack Sector（扇区）\n磁道上的弧段，最小的物理存储单位\n\nHead（磁头）\n读和写\n\nArm\n用于在磁道间移动磁头\n\nSpindle（主轴）\n用于旋转盘面\n\n磁盘调度算法读写时间的影响因素\n旋转时间\n\n圆周方向\n\n\n寻道时间（最长）\n\n半径方向\n\n\n数据传输时间\n\n\n分类\nFCFS\n\n不做任何优化\n\n\nSSTF\nShortest Seek Time First\n\n优先调度离磁头最近的磁道\n容易出现饥饿现象\n\n\nSCAN\n电梯调度算法\n\n磁头总是向一个方向移动，直到没有请求后改变方向\n\n\n\n","categories":["OS"]},{"title":"设计ORM","url":"/2020/05/09/%E8%AE%BE%E8%AE%A1ORM/","content":"设计ORM设计利用一些Component 像积木一样组合拼凑 成具有新的所需的特性的过程JDBC我可以在java里写java代码 但不能写SQL代码我通过SQL代码才能操纵SQLJDBC可以让我通过操纵java来操纵SQL\n\nWHY ORM？Without ORM\nConnection\nPreparedStatement\nexecuteQuery\nResultSet\nnext\nnew Java Bean\n\nWith ORM\n以MyBatis为例\n\nMapper&amp;Annotation\nMapperScan\nAutowired\nUse API\n\n\n\n查询Hibernate\nHQL语法\n\nJPA\nJPQL语法\n\nComplex尤其是Criteria\n\n\n\nMyBatis\n手撸SQL代码\n\n设计ORM接口以后理解更透彻一点再写吧\n","categories":["Spring"]},{"title":"质量属性","url":"/2021/06/22/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/","content":"Quality Attributes\n\n\n","categories":["软件体系结构"],"tags":["软件体系结构","质量属性"]},{"title":"走进Java","url":"/2020/05/09/%E8%B5%B0%E8%BF%9BJava/","content":"走进java概述优点\n用户量大\n\n一次编写，到处运行\n\n程序员只需要用JDK提供的接口，不必关心硬件如何如何\n\n\n安全的内存管理机制\n\n看过C++那丑陋的指针和引用就能明白这点\n\n\n热点代码检测和运行时编译及优化\n\n越跑越快\n\n\n各种库\n\n\n\n\njava技术体系组成\n根据功能划分\n\njava语言\n\n各种硬件平台上的JVM\n\nClass文件\n\n第三方java类库\n\n商业机构\n开源社区\n\n\njava API 类库\n\n\n\n根据服务领域划分\n\nJava Card\n\njava程序运行在小内存设备的平台\n\n\nJava ME\n\n含义\n\nmicro edition\n\n\n特点\n\n对java API有所精简\n加入了对移动终端的支持\n\n\n曾用名\n\nJ2ME\n\n\n\n\nJava SE\n\n含义\n\nstandard edition\n\n\n特点\n\n支持面向桌面级应用的java平台\n完整的java核心API\n\n\n曾用名\n\nJ2SE\n\n\n\n\nJava EE\n\n含义\n\nenterprise edition\n\n\n特点\n\n支持使用多层架构的企业应用\n对Java SE API做了扩充\n\n\n曾用名\n\nJ2EE\n\n\n\n\n\n\n\nJDK VS JRE\nJDK\n\nJava Development Kit\n\n开发java程序\n\n\n\n\nJRE\n\nJava Runtime Environment\n\n运行java程序\n\n\n\n\n\njava发展史James GoslingOakJDK 1.0\nWrite Once，Run anywhere\n\nJVM\n\nApplet\n\n可以包含在HTML里的一个小程序\n\n\nAWT\n\n类似swing、javafx这种吧，idk\n\n\n\nJDK 1.1\nJDBC\n\n程序员用java访问数据库只需要关心JDBC提供的接口，实现类由具体的数据库驱动提供\n\n\nJavaBeans\n\nRMI\n\nRemote Method Invocation\n\n\nInner class\n\n没用过，感觉不常用，好奇怪\n\n\nReflection\n\n\nJDK 1.1发布了9个版本JDK 1.2\njava技术体系被拆分\n\nJ2SE\n\nJava 2 Platform，Standard Edition\n\n面向桌面级应用\n\n\n\n\nJ2EE\n\nJava 2 Platform，Enterprise Edition\n\n面向企业级开发\n\n\n\n\nJ2ME\n\nJava 2 Platform，Micro Edition\n\n\n\n\nstrictfp关键字\n\nCollections类\n\n\nHotSpot虚拟机发布\n后来成了JDK的默认虚拟机\n\nJDK 1.3\n一些闻所未闻看不懂的新特性\n\nJDK 1.4\n走向成熟的版本\n\n正则表达式\n\n异常链\n\n你抛我，我抛他，形成永动\n\n\nNIO\n\n日志类\n\nXML解析器\n\n\n.NET Framework发布\n强势竞争\n\nJDK 1.5\n自动装箱\n\n把基本类型转换为包装类型\n\n\n泛型\n\n动态注解\n\n枚举\n\n可变长参数\n\nforeach\n\n改进了JMM\n\nJava Memory Model\n\n\n\nJDK 1.6\n全新的命名方式\n\n对虚拟机内部做了很多改进\n\n锁与同步\n垃圾收集\n类加载\n\n\n\nSun被Oracle收购展望Java的未来模块化混合语言\n催生了许多新语言\n许多老古董也有了jvm特供版\n\n多核并行\nFork&#x2F;Join\n\n丰富语法\n比如函数式编程\n\n64位虚拟机\n现在可能已经过渡完成了，毕竟我看的是9年前出版的书，那时候java8还没发布呢\n\n自己编译JDK获取JDK原码\nOPENJDK之类的\n\n构建编译环境\n说出来你可能不信，JDK使用C++编译器编译的（部分），所以要选个IDE的话，VS是不错的选择\n当然很多代码还是用java写的，所以还需要一个已经编译好的JDKhhh\n\nOPEN JDK也不是100%开源的，有些依赖项是闭包的，得手动下载那些个依赖项才好JDK plug开始编译\n细节一大堆\n\ntlds\n\n\n\n\n","categories":["JVM"]},{"title":"践行社会主义核心价值观","url":"/2019/01/16/%E8%B7%B5%E8%A1%8C%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E8%A7%82/","content":"","categories":["思修"]},{"title":"软件实现","url":"/2020/08/08/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0/","content":"标准文档\nInternal Documentation\n\nExternal Documentation\n\n\n\n\n文档化方法Internal Documentation\nHead Comment Block \nOther Program Comment\nMeaningful Variable Names and Statement Labels\nFormatting to Enhance Understanding\nDocumenting Data\n\nExternal Documentation\nDescribing  The Problem\nDescribing  The Algorithm\nDescribing  The Data\n\n"},{"title":"软件工程概述","url":"/2020/07/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/","content":"Definitions and Characteristics of SoftwareDefinition\nIntroduction\n\nprovide desired function and performance\n\n\nData Structure\n\nenable the programs to adequately manipulate information\n\n\nDocuments\n\ndescribe the operation and use of the programs\n\n\n\n\n\nCharacteristic\nSoftware is developed or engineered, it is not manufactured in the classical sense\nSoftware doesn’t “wear out”, but it does deteriorate\n\nSoftware Engineering定义\nThe application of a systematic, disciplined,  Measurable approach to the development, operation, and maintenance of software.\n\nThe study of approaches as in (1)\n\n\nThe Quality of Software定义\n软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”\n\n指标\n产品运行\n\n正确性\n可靠性\n效率\n完整性\n可使用性\n\n\n产品修正\n\n可维护性\n可测试性\n灵活性\n\n\n产品转移\n\n可移植性\n可复用性\n互连性\n\n\n\n","categories":["软件工程概论"]},{"title":"软件构件与中间件","url":"/2021/03/10/%E8%BD%AF%E4%BB%B6%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/","content":"\n\n\n\n分布式软件特点\n运行在网络环境中，多个节点通过网络连接\n每个节点由处理机硬件、OS和通信软件组成\n\n优势\n改进程序的性能\n\n基本概念\nCS架构\n\n二层结构\n\n结构\n\nDatabase Server（数据层）\n\n持久数据存储\n存储过程\n\n\nClient\n\nGUI\n业务逻辑\n\n\n\n\n缺陷\n\n客户端负担重\n客户端移植性差\n系统可维护性差\n数据安全性差\n\n\n\n\n三层结构\n\n结构\n\nDatabase Server（数据层）\n\n持久数据存储\n存储过程\n\n\n中间层应用程序\n\n业务逻辑代码\n中间层可以包括所有与存储和GUI无关的处理\n\n\nClient\n\nGUI\n\n\n\n\n优势\n\n减轻客户端负担\n提高客户端可移植性\n提高系统可维护性\n增强数据安全性\n更好的性能与可伸缩性\n\n\n\n\n\n软件构件（分布式对象）定义\n相对独立，可以被重用的软件实体\n\n与一般对象异同\n同\n\n封装、继承\n\n\n异\n\n要求更好的插入性\n关注不同进程中对象的相互调用\n访问异构（跨语言）对象\n只暴露共用接口\n\n\n\n特点\n严格定义的可插入单元，可大可小\n\n不一定基于对象\n\n封装\n\n构件的实现语言未知\n\n构件的物理位置未知\n\n相同进程、不同进程、不同物理机\n\n\n\n\n\n升级\n内部变化，暴露的接口不变\n\n相关概念\nInterface\n\n定义分布式对象的能力\n\n\nData type\n\n能再分布式对象间传递的数据类型\n\n\nMarshaling &amp; Unmarshaling\n\njson\njava bean\n\n\nObject Handle\n\n在编程语言中引用分布式对象的实例\n\n\nObject Creation\n\n常见机制是工厂\n\n\nObject Invocation\n\nObject Destruction\n\n\n中间件产生\n原因\n\n分布式软件的挑战\n\n互操作\n数据交换\n分布性\n可行性\n\n\n\n\n本质\n\n抽取共性，屏蔽底层复杂性\n\n\n栗子\n\nPC\n\nHardware\n\nSoftware\n\n共性\n\n计算机资源管理\n\n\n分离\n\nOS\n其它\n\n\n\n\n\n\nPC\n\nHardware\n\nOS\n\nApp\n\n共性\n\n数据管理\n\n\n分离\n\nDBMS\n其它\n\n\n\n\n\n\n\n\n\n位置\n应用\n\n中间件\n\n为分布式应用、web应用提供支持\n\n\nOS\n\n\n分类\n按功能\n\n数据访问中间件\n远程过程调用中间件\n消息中间件\n事务中间件\n构件中间件\n\n\n集成中间件\n\nCORBA\nCOMMON OBJECT REQUEST BROKER ARCHITECRUE\n\nJ2EE\n\n.NET\n\n\n\n\n作用\n（通过构件容器）提供构件运行环境\n\n管理构件\n\n\n互操作机制\n\n作用\n\n提供高层通信协议\n\nRemote procedure call\nJava Remote Messaging Protocol\nRemote Method Invocation\n\n\nMarshaling &amp; Unmarshaling\n\n\n\n分层\n\n数据层\n\nTelephony\n\nTelephony\n\n\n\n\n中间层\n\n客户层\n\n\n\n操作对象\n\n中间层应用构件与数据库\n客户层构件与中间层应用构件\n中间层应用构件之间\n中间层构件与公共服务构件\n\n\n\n\n公共服务\n\n命名服务\n事务服务\n安全服务\n持久性服务\n消息服务\n分布式垃圾回收服务\n资源管理服务\n\n\n\nStub&#x2F;Skeleton结构（桩–服务器框架）\n客户端程序\n\nSTUB\n\n通信总线\n\nSKELETON\n\n服务程序\n\n\n","categories":["软件构件与中间件"]},{"title":"辛亥革命与君主专制制度的终结","url":"/2019/06/14/%E8%BE%9B%E4%BA%A5%E9%9D%A9%E5%91%BD%E4%B8%8E%E5%90%9B%E4%B8%BB%E4%B8%93%E5%88%B6%E5%88%B6%E5%BA%A6%E7%9A%84%E7%BB%88%E7%BB%93/","content":"\n\n\n\n\n\n辛亥革命与君主专制制度的终结举起近代民主革命的旗帜辛亥革命爆发的历史条件\n民族危机加深、社会矛盾激化\n清末“新政”破产\n资产阶级革命派的阶级基础和骨干力量开始成熟\n\n资产阶级革命派的活动\n成立革命团体\n进行革命宣传\n成立革命政党\n\n三民主义学说和资产阶级共和国方案\n同盟会的政治纲领\n\n三民主义\n\n民族\n民权\n民生\n\n\n驱除鞑虏 恢复中华 创立民国 平均地权\n\n\n\n民族主义\n\n即民族革命，包括驱除鞑虏恢复中华。\n\n缺点\n\n没有明确提出反帝的纲领\n\n反封建不彻底\n对立满族但还有汉人\n\n\n\n\n\n民权主义\n\n即政治革命：创立民国\n\n缺点\n\n归根结底都是建立资产阶级专政的国家，广大人民群众的民主权力难以得到保证\n\n\n\n\n民生主义\n\n即社会革命：平均地权\n\n缺点\n\n平均地权并非将土地所有权分给农民，没有正面触及封建土地所有制，不能满足农民的土地要求，在革命中难以成为发动广大工农群众的理论武器\n\n\n\n\n\n关于革命与改良的辩论\n内容\n\n要不要推翻帝制，实行共和\n要不要进行社会革命\n要不要以革命手段推翻清王朝，这是双方论战的焦点\n\n\n评价\n\n划清了革命与改良的界限，传播了民主革命思想，促进了革命形势的发展，但这场论战也暴露了革命派在思想理论方面的弱点。\n\n\n\n辛亥革命与建立民国武昌起义与封建帝制的覆灭\n第一次武装起义（辛亥革命前）\n\n萍浏醴起义\n\n\n影响最大的一次武装起义（辛亥革命前）\n\n黄花岗起义\n\n\n保路风潮\n\n武昌起义\n\n\n中华民国的建立\n南京临时政府的性质\n\n资产阶级共和国性质的革命政权\n\n从政权的组成人员看，资产阶级革命派在这一政权中占有着领导和主体的地位。\n从南京临时政府制定的政策看，各项政策措施集中代表和反应了中国民族资产阶级的愿望和利益，在相当程度上也符合广大中国人民的利益。\n\n\n\n\n《中华民国临时约法》内容\n\n第一部资产阶级共和国宪法性质的法典\n中华民国之主权属于全国人民\n\n\n《中华民国临时约法》的进步性\n\n以根本大法的形式废除了两千多年来的封建君主专制制度\n临时约法是资产阶级革命的产物，有鲜明的革命性、民主性\n\n\n南京临时政府的局限性\n\n承认一切不平等条约，换取列强对中华民国的承认\n没有提出任何可以满足农民土地要求的政策和措施，反而以保护私有财产为借口，维护封建土地制度以及官僚、地主所占有的土地和财产\n\n\n\n辛亥革命的意义\n推翻了封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力，使中国反动统治者在政治上乱了阵脚\n结束了中国两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和正负，使民主共和观念深入人心。\n推动了中国人民思想解放\n促进中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化\n不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨\n\n辛亥革命的失败封建军阀专制统治的形成\n北洋政府的性质\n\n袁世凯窃夺辛亥革命胜利果实之后，建立了代表大地主和买办资产阶级利益的北洋军阀反动政权\n\n\n北洋政府在政治上的统治\n\n实行军阀官僚的专制统治\n\n北洋政府在经济上的统治\n\n竭力维护帝国主义、地主阶级和买办资产阶级的利益\n\n\n北洋政府在文化思想方面的统治\n\n尊孔复古思潮猖獗一时\n\n\n袁世凯死后，中国陷入军阀割据局面的原因\n\n中国主要是地方性的农业经济而没有形成统一的资本主义经济市场\n帝国主义国家在中国采取划分势力范围的分裂剥削政策\n\n\n\n\n\n辛亥革命失败原因和教训\n挽救共和的努力\n\n旧民主主义革命结束的标志\n\n护法运动的失败\n\n\n对孙中山的评价\n\n辛亥革命失败的原因\n\n客观\n\n从根本上说，在帝国注意时代，在半殖民地半封建的中国，资本主义的见过方案使行不通的\n\n\n主观\n\n资产阶级革命派本身存在着许多弱点和错误\n\n没有提出彻底的反帝反封建的革命纲领\n不能充分发动和依靠人民群众\n不能建立坚强的革命政党，作为团结一切革命力量的强有力的核心\n\n\n\n\n\n\n\n中国共产党人与孙中山事业的关系\n继承\n超越\n\n","categories":["近代史"]},{"title":"过程和生命期","url":"/2020/08/01/%E8%BF%87%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F/","content":"过程定义\nA Sequence Of  Steps , In the Same Order each time\nProduce an intended output of same kind\n\n\n\n特点\nThe process describes all the major process activities\nThe process uses the resources, subject to a set of constraints, and produces intermediate and final products\nThe process may be composed of sub-processes that that linked in some way.\nEach process activity has entry and exit criteria, so that we know when the activity begins and ends\nThe activities are organized in a sequence, so that it is clear when one activity is performed relative to the other activity \nEvery process has a set of guiding principles that explain the goals of each activity\nConstraints  or controls may apply to an activity, resource, or product\n\n生命期\nWhen the process involves the building of some PORDUCT\n\nWe sometime refer to the process as a Life Cycle\n\n\n模型瀑布模型\n阶段\n\nRequirements Analysis \nSystem Design\nProgram Design\nCoding\nUnit &amp; Integration Test\nSystem Test\nAcceptance Test\nOperation &amp; Maintenance\n\n\n优势\n\n一个阶段完成后只需要关注下一个阶段\n提供了一个模板、指导\n\n\n劣势\n\n线性的开发模式只有结束时才能看到结果，有很大的风险\n不能适应客户需求的变化\n把软件开发当做工业流程而不是一个创造性的流程\n\n\n\nV模型\n阶段\n\n和瀑布模型一样\n\n\n特点\n\n瀑布模型的变种版本\n在前三个阶段就分别开始测试\n最终产品最后一个步骤才出现\n\n\n\n原型模型\n很像敏捷开发\n先建立一个可以修改的源氏模型，之后和客户不断交流完善\n\n螺旋模型\n瀑布模型和原型模型的结合\n慢\n\n","categories":["软件工程概论"]},{"title":"近代史课后题","url":"/2019/06/14/%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%AF%BE%E5%90%8E%E9%A2%98/","content":"\n\n\n\n近代史课后题综述鸦片战争为什么是中国近代史的起点\n社会性质的变化\n\n封建社会\n半殖民地半封建社会\n\n\n发展方向的变化\n\n资本主义方向\n社会主义方向\n\n\n社会主要矛盾的变化\n\n农民阶级与封建地主阶级\n中华民族与外国侵略者\n\n\n革命任务的变化\n\n反封建\n反帝\n\n\n\n怎样认识近代中国的\n主要矛盾\n\n帝国主义和中华民族\n封建主义和人民大众\n\n\n社会性质及其基本特征\n\n半殖民地半封建社会\n\n基本特征\n\n资本-帝国主义侵略势力日益成为支配中国的决定性力量\n中国的封建势力成为资本-帝国主义压迫、奴役中国人民的社会基础和统治支柱\n封建地主的土地所有制依然在广大地区内保持着\n中国新兴的民族资本主义经济虽然已经产生，但它的发展很缓慢，力量很软弱\n近代中国各地区经济、政治和文化的发展是极不平衡的\n中国人民日益贫困 饥寒交迫 毫无政治权利\n\n\n\n\n\n如何理解两大任务及其相互关系\n两大任务\n\n民族独立，人民解放\n国家富强，人民富裕\n\n\n关系\n\n前提\n目的\n\n\n\n第一章资本-帝国主义的入侵给中国带来了什么\n侵略战争\n\n不平等条约\n\n赔款割地\n\n通商口岸\n\n租界\n\n\n\n\n\n\n中国当权者成为帝国主义的工具\n\n不平等条约\n\n通商口岸\n协定关税\n商品倾销\n资本输出\n\n\n文化渗透\n\n宗教\n种族主义\n\n\n不自觉的历史工具\n\n机器技术\n压制中国发展进步\n\n\n\n近代中国的反侵略战争有什么意义\n御敌\n\n打击帝国主义侵华野心\n粉碎帝国主义完全殖民图谋\n\n\n觉醒\n\n教育\n\n激励\n\n奋起直追\n\n师夷长技以制夷\n学习西方制度\n\n\n\n\n提高民族意识\n\n梁启超\n严复\n共产党\n\n\n\n\n\n历次反侵略战争失败的根本原因和教训\n原因\n\n社会政治制度的腐败\n经济技术的落后\n\n\n教训\n\n一定要反帝反封建\n落后就要挨打\n\n\n\n第二章太平天国运动\n意义\n\n对清朝\n\n沉重打击封建统治阶级\n\n动摇了清王朝封建统治的根基\n\n加速了清王朝的衰败\n\n\n\n\n农民战争的最高峰\n\n\n\n对侵略者\n\n打击了外国侵略势力\n\n\n对社会\n\n冲击了儒家之权威\n削弱了封建统治的精神支柱\n\n\n对国际\n\n同其他国家的民族解放运动一起冲击了西方殖民者的统治\n\n\n\n\n败因\n\n主观\n\n农民阶级的局限性\n战略上的失误\n拜上帝教的思想\n\n\n客观\n\n中外反动势力联合镇压\n\n\n\n\n教训\n\n农民具有伟大的革命潜力，但它自身不能担负起领导反帝反封建斗争取得胜利的重任\n\n\n\n洋务运动\n性质\n\n清朝封建统治阶级中的洋务派为了维护清朝的封建统治而进行的以常自救运动，有进步性也有落后保守性\n\n\n失败的原因\n\n封建性\n\n指导思想\n\n中体西用\n\n不改变固有制度和道德规范\n利用西方近代生产技术，维护和巩固中国封建统治\n\n\n\n\n\n\n对外国的依赖性\n\n西方不希望中国发展\n洋务派处处依赖西方\n\n\n管理具有腐朽性\n\n\n\n教训\n\n不能自强求富\n\n不触动封建专制统治\n不摆脱外国资本-帝国主义侵略与控制\n谋求通过局部的枝节改革发展本国资本主义\n\n\n\n\n\n戊戌维新运动\n意义\n\n爱国救亡运动\n\n资产阶级性质的政治改良运动\n\n思想启蒙运动\n\n京师大学堂：近代国立高等教育的发端\n\n\n\n\n失败的原因\n\n主观原因：\n\n根本原因：维新派自身的局限\n不敢否定封建主义\n对帝国主义抱有幻想\n惧怕人民群众\n\n\n客观原因\n\n以慈禧太后为首的强大的守旧势力的反对\n民族资产阶级力量弱小\n\n\n\n\n教训\n\n在半殖民地半封建的旧中国，企图通过统治阶级走自上而下的改良实现国家独立民主富强是行不通的，必须用革命的手段，反帝反封建\n\n\n\n","categories":["近代史"]},{"title":"迪杰斯特拉","url":"/2021/04/20/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89/","content":"数据结构、离散数学、计算机网络、算法，这些课都讲过这个算法，再加上我大一的时候看的《图解算法》，对迪杰斯特拉已经很熟悉了。\n戴克斯特拉算法（英语：Dijkstra’s algorithm），又译迪杰斯特拉算法，亦可不音译而称为Dijkstra算法[6]，是由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年发现的算法，并于3年后在期刊上发表[7][8][9]。戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图[9]的单源最短路径问题[10][1][2]。\n\n\nedges为一个二维数组，假设edge为其中的元素，edge[0]和edge[1]表示一条有向边上的两个节点，edge[2]表示这条边的权重。\nconst INFINITY = math.MaxInt64func Dijkstra(edges [][]int, n int, k int) int &#123;   D := make(map[int]int)  // shortest path from k to other nodes   S := make(map[int]bool) // nodes whose shortest path is already calculated   // initialize   for i := 1; i &lt;= n; i++ &#123;      D[i] = INFINITY   &#125;   D[k] = 0   DISTANCE := make(map[string]int)   for _, edge := range edges &#123;      DISTANCE[strconv.Itoa(edge[0])+&quot; &quot;+strconv.Itoa(edge[1])] = edge[2]   &#125;   for &#123;      // the nearest node to source node which is not in set S      u := extractMin(D, S)      if u == -1 &#123;         break      &#125;      S[u] = true      for v, dist := range D &#123;         if _, ok := S[v]; !ok &#123;            uv := edge(u, v, DISTANCE)            if uv != -1 &#123;               if D[u]+uv &lt; dist &#123;                  D[v] = D[u] + uv               &#125;            &#125;         &#125;      &#125;   &#125;&#125;// distance from u to v, if there is no path, return -1func edge(u, v int, distance map[string]int) int &#123;   d, ok := distance[strconv.Itoa(u)+&quot; &quot;+strconv.Itoa(v)]   if !ok &#123;      return -1   &#125;   return d&#125;// the nearest node to source node which is not in set S, if not found, return -1func extractMin(D map[int]int, S map[int]bool) int &#123;   minDistance := INFINITY   ans := -1   for node, distance := range D &#123;      if _, ok := S[node]; !ok &#123;         if distance &lt; minDistance &#123;            ans = node            minDistance = distance         &#125;      &#125;   &#125;   return ans&#125;","categories":["数据结构与算法"]},{"title":"进程管理","url":"/2020/12/07/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"进程和线程\n\n\n概念和对比\n进程\n\n概念\n\n运行中的程序\n\n\n地位\n\n资源分配的基本单位\n\n\n管理\n\nPCB\n\n\n创建和撤销\n\n操作PCB\n\n\n\n\n线程\n\n地位\n\n独立调度的基本单位\n\n\n特点\n\n共享进程资源\n\n\n\n\n区别\n\n资源\n\n调度\n\n开销\n\n通信\n\n线程通过读写同一进程的数据通信\n进程通过IPC通信\n\n\n\n\n\n进程的状态\nReady\n\n等待被调度，通过调度算法获得CPU时间，进入Running状态\n\n\nBlock\n\nRunning\n\n耗完得到的cpu时间后进入block状态\n\n\n\n进程调度算法批处理系统关心吞吐量和周转时间\n\nFCFS（先来先服务）\n\n非抢占式\n简单粗暴\n\n\nSJF（短作业优先）\n\n非抢占式\n长作业可能会饿死\n\n\nSRTF（最短剩余时间优先）\n\n抢占式\n如果新来的更短，则挂起当前的\n\n\n\n交互式系统关心快速响应\n\n时间片轮转\n\n设置时间片，快速切换\n\n时间片长度设置要合理\n时间片过短：进程频繁切换时间片过长：即时性没有保证\n\n\n\n分配优先级\n\n先执行优先级高的\n为了防止优先级低的进程饿死，可以使其优先级随时间递增\n\n\n多级反馈队列\n\n设置多个时间片不同的队列，动态地将长作业放在时间片长的队列\n\n\n\n实时系统\n软实时\n硬实时\n\n进程同步临界区（critical region）\n概念\n\n对临界资源访问的代码段\n\n\n特点\n\n访问临界资源前先进行检查以实现互斥访问\n\n\n\n同步和互斥\n同步\n\n因为多个进程之间的合作关系，进程的执行需要有一定的先后顺序\n\n\n互斥\n\n同一时刻只能有一个进程进入临界区\n\n\n\n信号量（Semaphore）\n存储位置\n\nKernel Mode\n如果信号量存在于用户态，进程结束时信号量会被销毁\n\n\n\nPV操作\n\nup\nUp之后会唤醒一个因为down操作陷入睡眠的进程\n\nsamaphore++\n\n\ndown\n进入临界区之前先down一下，如果semaphore&#x3D;0，调用down方法的进程会陷入睡眠，等待一个命中注定的人\n\nsamaphore–\n\n\n原子性\n\n可以用禁止中断来实现\n\n\n\n\nMutex\n\n简化版（单值）的Semaphore\n\n状态\n\n0\n1\n\n\n\n\n生产消费者问题\n#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123;    while(TRUE) &#123;        int item = produce_item();        down(&amp;empty);        down(&amp;mutex);        insert_item(item);        up(&amp;mutex);        up(&amp;full);    &#125;&#125;void consumer() &#123;    while(TRUE) &#123;        down(&amp;full);        down(&amp;mutex);        int item = remove_item();        consume_item(item);        up(&amp;mutex);        up(&amp;empty);    &#125;&#125;\n\n\nmutex\n\n锁\n\n\nempty\n\n剩余容量\n\n\nfull\n\n已使用容量\n\n\n\n\n管程\n\n特点：同一时刻只能有一个进程使用管程\n管程将控制操作独立出来，本质上是PV操作之上的一层包装\n\n\n\n经典同步问题\n哲学家就餐问题\n#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N    // 右邻居#define THINKING 0#define HUNGRY   1#define EATING   2typedef int semaphore;int state[N];                // 跟踪每个哲学家的状态semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥semaphore s[N];              // 每个哲学家一个信号量void philosopher(int i) &#123;    while(TRUE) &#123;        think(i);        take_two(i);        eat(i);        put_two(i);    &#125;&#125;void take_two(int i) &#123;    down(&amp;mutex);    state[i] = HUNGRY;    check(i);    up(&amp;mutex);    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去&#125;void put_two(i) &#123;    down(&amp;mutex);    state[i] = THINKING;    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了    check(RIGHT);    up(&amp;mutex);&#125;void eat(int i) &#123;    down(&amp;mutex);    state[i] = EATING;    up(&amp;mutex);&#125;// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行void check(i) &#123;             if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;        state[i] = EATING;        up(&amp;s[i]);    &#125;&#125;\n\n\n哲学家\n\nthink()\neat()\n\n\n死锁问题\n\n当所有哲学家同时拿起左手的筷子\n\n\n解决\n\ntakeTwo()\n\nputTwo()\n\ncheck(i)\n\n在邻居没有进餐的情况下才可以进餐\n\n\n\n\n\n\n读者–写者问题\ntypedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123;    while(TRUE) &#123;        down(&amp;count_mutex);        count++;        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问        up(&amp;count_mutex);        read();        down(&amp;count_mutex);        count--;        if(count == 0) up(&amp;data_mutex);        up(&amp;count_mutex);    &#125;&#125;void writer() &#123;    while(TRUE) &#123;        down(&amp;data_mutex);        write();        up(&amp;data_mutex);    &#125;&#125;\n\n\n可以同时读，但读和写以及写和写不能同时发生\n第一个读者为数据上锁避免写者访问数据\n\n\n\nIPC进程通信VS进程同步\n通信是手段，同步是目的\n\n通信方式\n（匿名）管道（pipe）\n\n特点\n\nonly半双工\nonly父子进程或者兄弟进程\n存放于内存\n类似队列，一端写入，一端读出\n\n\n图\n\n\n\n\nFIFO（命名管道）\n\n与一般的管道相比，没有进程关系限制，存放于文件系统\n多用于CS架构作为汇聚点，在客户进程和服务器进程之间传递数据\n图\n\n\n\n消息队列\n\n可以独立于读写进程存在\n读进程可以根据消息类型有选择地接收消息\n\n\n信号量\n\nSemaphore\nMutex\n\n\n共享存储&#x2F;共享内存\n\n特点\n\n效率高（不需要数据的复制）\n\n\n存在的问题\n\n各进程间的同步问题，常配合信号量使用\n\n\n\n\nSocket（套接字）\n\n可用于不同主机的进程间通信\n\n\n\n","categories":["OS"]},{"title":"银行家算法","url":"/2020/08/17/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/","content":"图\n\n\n\n\n","categories":["OS"]},{"title":"链接","url":"/2020/12/11/%E9%93%BE%E6%8E%A5/","content":"\n\n\n相关概念C语言编译过程\n预处理\n\n编译\n\n翻译成汇编文件\n\n\n汇编\n\n汇编文件–&gt;可重定位目标文件\n\n\n链接\n\n\n目标文件\n可执行目标文件\n可重定位目标文件\n共享目标文件\n\n静态链接作用\n一组可重定位目标文件–&gt;完全链接的可执行目标文件\n\n步骤\n符号解析\n\n变量、函数&lt;–&gt;符号\n\n\n重定位\n\n符号&lt;–&gt;内存位置，修改引用，使其指向对应的内存\n\n\n\n缺点\n浪费资源，如有改动需要重新链接\n\n动态链接\n动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入\n动态库大伙儿共享\n","categories":["OS"]},{"title":"链路层","url":"/2020/12/08/%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"\n\n\n基本问题封装成数据帧\n给从网络层得到的Packet（分组）加上头部和尾部，标记帧的开始和结束\n\n透明传输\n对数据的一部分进行转义，传输过程传输转义后的数据，接收方收到数据帧后又会取消转义，这一过程对用户不可见\n\n差错检测\nCRC（循环冗余校验）\n\n信道分类广播信道\n一对多：一个节点发送的数据能被信道上的所有节点收到\n\n冲突（collision）避免\n\n信道复用技术\nCSMA&#x2F;CD\n\n\n\n点对点信道\n一对一通信，使用PPP协议\n\n信道复用技术频分复用\n所有主机在相同时间占用不同频率的带宽资源\n\n时分复用\n所有主机在不同的时间占用相同频率的带宽资源\n\n统计时分复用\n对时分复用的一种改进，不固定每个用户在复用帧中的位置\n\n波分复用\n光的频分复用（光习惯说波长）\n\n码分复用\n为用户分配m bits的码片（大小和用户数有关），所有的码片正交。\n发送的0和1改为码片或者码片的补码\n码分复用需要发送的数据量为原先的n倍\n\n协议CSMA&#x2F;CD\nCarrier Sense Multiple Access with Collision Detection（载波侦听多路访问&#x2F;冲突检测）\n\n概念\n\n载波侦听\n\n持续监听信道，信道空闲才能发送\n\n\n多路访问\n\n总线型网络，许多主机以点的方式接入总线\n\n\n冲突检测\n\n载波侦听不能避免碰撞，发送数据途中如果发现有主机也在发送，说明产生了碰撞\n\n\n\n\n争用期\n\n端到端的传播时间为τ，过了2τ之后才有把握说之前没有碰撞并且之后也不会碰撞\n\n\n截断二进制指数退避算法\n\n碰了之后，双方要等一个随机的时间后再发送\n\n\n\nPPP\nPoint to Point Protocol\n\n使用场景\n\n用户计算机和ISP通信\n\n\nPPP的帧格式\n\n\nMAC地址地位\n链路层地址，唯一表示网络适配器（网卡）\n一台主机可以有多个网卡，但每个网卡只有唯一的MAC地址\n\n\n局域网信道类型\n广播\n\n特点\n网络为一个单位所有，范围和数量有限\n\n技术\n以太网\n\n拓扑结构\n\n星型\n\n早期\n\n集线器\n\n物理层设备\n作用于比特，放大能量\n\n\n\n\n近期\n\n交换机\n\n链路层设备\n\n根据MAC地址存储转发\n\n自学习能力\n\n表里没有目的地就广播\nMAC地址——接口\n\n\n\n\n\n\n\n\n\n\n帧\n\n大小要求\n\n长度在46-1500之间，太小则需要填充\n\n\nFCS\n\n帧检验序列，CRC\n\n\n\n\n\n\n令牌环网\n\nFDDI\n\nATM\n\n\n分类\n星型\n环型\n直线型\n\nVLAN\n使用 VLAN 干线连接交换机来建立虚拟局域网，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。\n实现\nIEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。\n\n","categories":["计网"]},{"title":"阿里云服务器git clone速度慢的解决方案","url":"/2020/12/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8git-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"可行的解决方案修改/etc/ssh/ssh_config文件：\nnano /etc/ssh/ssh_config\n\n\n取消GSSAPIAuthentication no的注释，保存并退出（可能会遇到权限不够的问题，su root可以解决）。\n之后下载速度快到飞起。\n","categories":["Experience"]},{"title":"隔离级别","url":"/2020/12/11/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","content":"\n\n\n\n\nRead Uncommitted（未提交读）\n可以Read没有Commit的记录\n事务中的修改，即使没有提交，对其它事务也是可见的\n\nRead Committed（提交读）描述\n不可以Read没有Commit的记录\n只能Read已经Commit的记录\n一个事务只能读取已经提交的事务所做的修改。\n一个事务所做的修改在提交之前对其它事务是不可见的\n\n现象\n必不可能脏读（Dirty Read）\n可能会不可重复读（Non Repeatable Read）\n\nRepeatable Read（可重复读）描述\n保证在同一个事务中多次读取同一数据的结果是一样的\n\n现象\n避免不可重复读（Non Repeatable Read）\n可能会幻读（Phantom Read）\n\nSerializable（可串行化）描述\n强制事务串行执行\n\n通过上锁来实现，同一时间只有一个事务在执行\n\n\n多个事务互不干扰\n\n不会出现并发一致性问题\n\n\n现象\n绝对的一致性\n\n\n","categories":["数据库"]},{"title":"集成MyBatis","url":"/2020/05/09/%E9%9B%86%E6%88%90MyBatis/","content":"集成MyBatisORM分类\nHibernate\nJPA\n\n功能\n简化数据库操作\n\n起初：通过SQL语句增删改查\n现在：通过对一个实例增删改查后调用接口\n\n\n\n实现\n前提：ORM获得了一些信息（注解）\n\n把ResultSet的每一行映射成javaBean\n\n把javaBean映射成SQL语句的参数\n\nORM如何检视javaBean的修改\n\nProxy\n\n\n\n\n\n\n\n全自动ORM和半自动ORM和不自动的全自动的有些问题 不好优化\n比如hibernate\n\n半自动面向SQL 就很灵活\n比如myBatis\n\n不自动的 很满发\n比如JdbcTemplate\n\nMyBatis的优缺点缺点\n所有的SQL语句都要我自己写\n\n优点\n所有SQL语句都是我自己写的\n\n","categories":["Spring"]},{"title":"需求分析","url":"/2020/08/06/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","content":"定义是开发人员经过深入细致的调研和分析，准确理解用户和项目的功能、性能、可靠性等具体要求，将用户非形式的需求表述转化为完整的需求定义，从而确定系统必须做什么的过程\n\n\n需求类型\nFunctional Requirements\n\nDesign Constraints\n\nProcess Constraints\n\nQuality (Non-functional)\n\nRequirement Documents\n\n\n需求特点\nCorrect\n\nConsistent\n\nUnambiguous\n\nComplete\n\nFeasible\n\nRelevant\n\nTestable\n\nTraceable\n\n\n需求的表示方法及其应用Entity-Relationship Diagram (ER图)\n实体\n属性\n关系\n\nData-Flow Diagram (数据流图)\nProcess\nData flow\nData source\n\nDecision Table(用例图)判定表代数规格说明需求文档Requirement Definition\nfor customer\n\nRequirement Specification\nfor developer\n\n","categories":["软件工程概论"]},{"title":"面试题-16.11","url":"/2020/07/08/%E9%9D%A2%E8%AF%95%E9%A2%98-16-11/","content":"面试题-16.11  跳水板题目\n\n\n\n结果\n\n代码class Solution &#123;    public int[] divingBoard(int shorter, int longer, int k) &#123;        // 特殊情况        if (k == 0) &#123;            return new int[]&#123;&#125;;        &#125;        // 特殊情况，只要shorter！=longer，数组就不会有重复元素        if (shorter == longer) &#123;            return new int[]&#123;shorter * k&#125;;        &#125;        int[] ans = new int[k + 1];        for (int i = 0; i &lt;= k; i++) &#123;            ans[i] = (k - i) * shorter + i * longer;        &#125;        return ans;    &#125;&#125;\n\n","categories":["程序员面试金典"]},{"title":"面试题 16.26. 计算器","url":"/2021/01/23/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.26.%20%E8%AE%A1%E7%AE%97%E5%99%A8/","content":"题目面试题 16.26. 计算器\n\n\n\n结果\n代码先处理输入，由中缀表达式获得后缀表达式，再借助一个栈，由后缀表达式求出最终结果。\npackage mainimport (   &quot;strconv&quot;   &quot;unicode&quot;)func main() &#123;   println(calculate(&quot;3+2*2&quot;))&#125;var priority = map[rune]int&#123;   &#x27;+&#x27;: 0,   &#x27;-&#x27;: 0,   &#x27;*&#x27;: 1,   &#x27;/&#x27;: 1,&#125;type elem struct &#123;   val  int   flag bool // number or operator&#125;func calculate(s string) int &#123;   return val(expr(s))&#125;// convert in-order sequence to after-order sequencefunc expr(src string) []elem &#123;   var exprStk []elem   var opStk []rune   // ignore or not when encounter a digit   var jump bool   for i, v := range src &#123;      switch &#123;      case unicode.IsSpace(v):         continue      case unicode.IsDigit(v):         if !jump &#123;            exprStk = append(exprStk, elem&#123;val: nextNum(src, i)&#125;)            jump = true         &#125;      default: // operator: + - * /         jump = false         if len(opStk) == 0 || priority[v] &gt; priority[opStk[len(opStk)-1]] &#123;            opStk = append(opStk, v)            continue         &#125;         for len(opStk) != 0 &#123;            // pop the operators which have higher or same priority            top := opStk[len(opStk)-1]            if priority[v] &lt;= priority[top] &#123;               exprStk = append(exprStk, elem&#123;                  val:  int(top),                  flag: true,               &#125;)               opStk = opStk[:len(opStk)-1]            &#125; else &#123;               break            &#125;         &#125;         opStk = append(opStk, v)      &#125;   &#125;   // push the rest operators into the exprStk   for len(opStk) != 0 &#123;      top := opStk[len(opStk)-1]      exprStk = append(exprStk, elem&#123;         val:  int(top),         flag: true,      &#125;)      opStk = opStk[:len(opStk)-1]   &#125;   return exprStk&#125;func val(expr []elem) int &#123;   stk := make([]int, 0)   for _, v := range expr &#123;      switch v.flag &#123;      case false: // number         stk = append(stk, v.val)      case true: // operator         b := stk[len(stk)-1]         stk = stk[:len(stk)-1]         a := stk[len(stk)-1]         stk = stk[:len(stk)-1]         switch v.val &#123;         case &#x27;+&#x27;:            stk = append(stk, a+b)         case &#x27;-&#x27;:            stk = append(stk, a-b)         case &#x27;*&#x27;:            stk = append(stk, a*b)         case &#x27;/&#x27;:            stk = append(stk, a/b)         &#125;      &#125;   &#125;   return stk[0]&#125;func nextNum(expr string, index int) int &#123;   var str string   for i := index; i &lt; len(expr); i++ &#123;      if !unicode.IsDigit(rune(expr[i])) &#123;         break      &#125;      str += string(expr[i])   &#125;   ans, _ := strconv.ParseInt(str, 10, 64)   return int(ans)&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（n）\n应该都是线性级别的复杂度\n","categories":["程序员面试金典"]},{"title":"面试题-08.03","url":"/2020/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98-08-03/","content":"题目\n\n\n\n结果\n\n代码class Solution &#123;    public int findMagicIndex(int[] nums) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (nums[i] == i) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;\n\n复杂度时间复杂度：O（n）\n空间复杂度：O（1）\n","categories":["程序员面试金典"]},{"title":"项目管理","url":"/2020/08/05/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","content":"WBS\nWork Breakdown Structure\n\n项目范围的WBS表示\n\n\n\n\n关键路径定义\nMinimum Amount of Time it will be take to complete the Project\n\n特点\nThe Slack at every node is Zero\nThere may be more than one critical path\n\n计算\n最长的那条路径\n从左面开始，计算每项作业的最早结束时间\n该时间等于最早可能的开始时间（ES）加上该作业的持续时间\n\n甘特图example\n\n\n\n","categories":["软件工程概论"]}]